# Experimental live content collections and more

# Experimental live content collections

# Experimental live content collections

**Type:** `boolean`
 **Default:** `false`

 **Added in:** `astro@5.10.0`

Enables support for live content collections in your project.

Live content collections are a new type of [content collection](https://docs.astro.build/en/guides/content-collections/) that fetch their data at runtime rather than build time. This allows you to access frequently updated data from CMSs, APIs, databases, or other sources using a unified API, without needing to rebuild your site when the data changes.

## Basic usage

[Section titled “Basic usage”](#basic-usage)

To enable the feature, make sure you have an adapter configured for [on-demand rendering](https://docs.astro.build/en/guides/on-demand-rendering/) and add the `experimental.liveContentCollections` flag to your `astro.config.mjs` file:

 astro.config.mjs

```
{  experimental: {    liveContentCollections: true,  },}
```

Then create a new `src/live.config.ts` file (alongside your `src/content.config.ts` if you have one) to define your live collections with a [live loader](#creating-a-live-loader) and optionally a [schema](#using-zod-schemas) using the new `defineLiveCollection()` function from the `astro:content` module.

 src/live.config.ts

```
import { defineLiveCollection } from 'astro:content';import { storeLoader } from '@mystore/astro-loader';
const products = defineLiveCollection({  loader: storeLoader({    apiKey: process.env.STORE_API_KEY,    endpoint: 'https://api.mystore.com/v1',  }),});
export const collections = { products };
```

You can then use the dedicated `getLiveCollection()` and `getLiveEntry()` functions to access your live data:

```
---export const prerender = false; // Not needed in 'server' mode
import { getLiveCollection, getLiveEntry } from 'astro:content';
// Get all productsconst { entries: allProducts, error } = await getLiveCollection('products');if (error) {  // Handle error appropriately  console.error(error.message);}
// Get products with a filter (if supported by your loader)const { entries: electronics } = await getLiveCollection('products', { category: 'electronics' });
// Get a single product by ID (string syntax)const { entry: product, error: productError } = await getLiveEntry('products', Astro.params.id);if (productError) {  return Astro.redirect('/404');}
// Get a single product with a custom query (if supported by your loader) using a filter objectconst { entry: productBySlug } = await getLiveEntry('products', { slug: Astro.params.slug });---
```

## When to use live content collections

[Section titled “When to use live content collections”](#when-to-use-live-content-collections)

Live content collections are designed for data that changes frequently and needs to be up-to-date when a page is requested. Consider using them when:

- **You need real-time information** (e.g. user-specific data, current stock levels)
- **You want to avoid constant rebuilds** for content that changes often
- **Your data updates frequently** (e.g. up-to-the-minute product inventory, prices, availability)
- **You need to pass dynamic filters** to your data source based on user input or request parameters
- **You’re building preview functionality** for a CMS where editors need to see draft content immediately

In contrast, use build-time content collections when:

- **Performance is critical** and you want to pre-render data at build time
- **Your data is relatively static** (e.g., blog posts, documentation, product descriptions)
- **You want to benefit from build-time optimization** and caching
- **You need to process MDX** or perform image optimization
- **Your data can be fetched once and reused** across multiple builds

See the [limitations of experimental live collections](#live-collection-limitations) and [key differences from build-time collections](#differences-from-build-time-collections) for more details on choosing between live and preloaded collections.

## Using live collections

[Section titled “Using live collections”](#using-live-collections)

You can [create your own live loaders](#creating-a-live-loader) for your data source, or you can use community loaders distributed as npm packages. Here’s how you could use example CMS and e-commerce loaders:

 src/live.config.ts

```
import { defineLiveCollection } from 'astro:content';import { cmsLoader } from '@example/cms-astro-loader';import { productLoader } from '@example/store-astro-loader';
const articles = defineLiveCollection({  loader: cmsLoader({    apiKey: process.env.CMS_API_KEY,    contentType: 'article',  }),});
const products = defineLiveCollection({  loader: productLoader({    apiKey: process.env.STORE_API_KEY,  }),});
export const collections = { articles, products };
```

You can then get content from both loaders with a unified API:

```
---export const prerender = false; // Not needed in 'server' mode
import { getLiveCollection, getLiveEntry } from 'astro:content';
// Use loader-specific filtersconst { entries: draftArticles } = await getLiveCollection('articles', {  status: 'draft',  author: 'john-doe',});
// Get a specific product by IDconst { entry: product } = await getLiveEntry('products', Astro.params.slug);---
```

### Error handling

[Section titled “Error handling”](#error-handling)

Live loaders can fail due to network issues, API errors, or validation problems. The API is designed to make error handling explicit.

When you call `getLiveCollection()` or `getLiveEntry()`, the error will be one of:

- The error type defined by the loader (if it returned an error)
- A `LiveEntryNotFoundError` if the entry was not found
- A `LiveCollectionValidationError` if the collection data does not match the expected schema
- A `LiveCollectionCacheHintError` if the cache hint is invalid
- A `LiveCollectionError` for other errors, such as uncaught errors thrown in the loader

These errors have a static `is()` method that you can use to check the type of error at runtime:

```
---export const prerender = false; // Not needed in 'server' mode
import { getLiveEntry, LiveEntryNotFoundError } from 'astro:content';
const { entry, error } = await getLiveEntry('products', Astro.params.id);
if (error) {  if (LiveEntryNotFoundError.is(error)) {    console.error(`Product not found: ${error.message}`);    Astro.response.status = 404;  } else {    console.error(`Error loading product: ${error.message}`);    return Astro.redirect('/500');  }}---
```

## Creating a live loader

[Section titled “Creating a live loader”](#creating-a-live-loader)

A live loader is an object with two methods: `loadCollection()` and `loadEntry()`. These methods should handle errors gracefully and return either data or an [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object.

The standard pattern is to export a function that returns this loader object, allowing you to pass configuration options like API keys or endpoints.

Here’s a basic example:

 myloader.ts

```
import type { LiveLoader } from 'astro/loaders';import { fetchFromCMS } from './cms-client.js';
interface Article {  id: string;  title: string;  content: string;  author: string;}
export function articleLoader(config: { apiKey: string }): LiveLoader<Article> {  return {    name: 'article-loader',    loadCollection: async ({ filter }) => {      try {        const articles = await fetchFromCMS({          apiKey: config.apiKey,          type: 'article',          filter,        });
        return {          entries: articles.map((article) => ({            id: article.id,            data: article,          })),        };      } catch (error) {        return {          error: new Error(`Failed to load articles: ${error.message}`),        };      }    },    loadEntry: async ({ filter }) => {      try {        // filter will be { id: "some-id" } when called with a string        const article = await fetchFromCMS({          apiKey: config.apiKey,          type: 'article',          id: filter.id,        });
        if (!article) {          return {            error: new Error('Article not found'),          };        }
        return {          id: article.id,          data: article,        };      } catch (error) {        return {          error: new Error(`Failed to load article: ${error.message}`),        };      }    },  };}
```

### Rendering content

[Section titled “Rendering content”](#rendering-content)

A loader can add support for directly rendered content by returning [arenderedproperty](https://docs.astro.build/en/reference/content-loader-reference/#rendered) in the entry. This allows you to use [therender()function and<Content />component](https://docs.astro.build/en/guides/content-collections/#rendering-body-content) to render the content directly in your pages.
If the loader does not return a `rendered` property for an entry, the `<Content />` component will render nothing.

 myloader.ts

```
// ...export function articleLoader(config: { apiKey: string }): LiveLoader<Article> {  return {    name: 'article-loader',    loadEntry: async ({ filter }) => {      try {        const article = await fetchFromCMS({          apiKey: config.apiKey,          type: 'article',          id: filter.id,        });
        return {          id: article.id,          data: article,          rendered: {            // Assuming the CMS returns HTML content            html: article.htmlContent,          },        };      } catch (error) {        return {          error: new Error(`Failed to load article: ${error.message}`),        };      }    },    // ...  };}
```

You can then render both content and metadata from live collection entries in pages using the same method as built-time collections. You also have access to any [error returned by the live loader](#error-handling-in-loaders), for example, to rewrite to a 404 page when content cannot be displayed:

```
---export const prerender = false; // Not needed in 'server' mode
import { getLiveEntry, render } from 'astro:content';const { entry, error } = await getLiveEntry('articles', Astro.params.id);if (error) {  return Astro.rewrite('/404');}
const { Content } = await render(entry);---
<h1>{entry.data.title}</h1><Content />
```

### Error handling in loaders

[Section titled “Error handling in loaders”](#error-handling-in-loaders)

Loaders should handle all errors and return an [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) subclass for errors. You can create custom error types and use them for more specific error handling if needed. If an error is thrown in the loader, it will be caught and returned, wrapped in a `LiveCollectionError`. You can also create [custom error types](#custom-error-types) for proper typing.

Astro will generate some errors itself, depending on the response from the loader:

- If `loadEntry` returns `undefined`, Astro will return a `LiveEntryNotFoundError` to the user.
- If a schema is defined for the collection and the data does not match the schema, Astro will return a `LiveCollectionValidationError`.
- If the loader returns an invalid cache hint, Astro will return a `LiveCollectionCacheHintError`. The `cacheHint` field is optional, so if you do not have valid data to return, you can simply omit it.

 my-loader.ts

```
import type { LiveLoader } from 'astro/loaders';import { MyLoaderError } from './errors.js';
export function myLoader(config): LiveLoader<MyData, undefined, undefined, MyLoaderError> {  return {    name: 'my-loader',    loadCollection: async ({ filter }) => {      // Return your custom error type      return {        error: new MyLoaderError('Failed to load', 'LOAD_ERROR'),      };    },    // ...  };}
```

### Distributing your loader

[Section titled “Distributing your loader”](#distributing-your-loader)

Loaders can be defined in your site or as a separate npm package. If you want to share your loader with the community, you can [publish it to NPM with theastro-componentandastro-loaderkeywords](https://docs.astro.build/en/reference/publish-to-npm/#packagejson-data).

The loader should export a function that returns the `LiveLoader` object, allowing users to configure it with their own settings.

## Type safety

[Section titled “Type safety”](#type-safety)

Like regular content collections, live collections can be typed to ensure type safety in your data. [Using Zod schemas](#using-zod-schemas) is supported, but not required to define types for live collections. Unlike preloaded collections defined at build time, live loaders can instead choose to pass generic types to the `LiveLoader` interface.
You can define the types for your collection and entry data, as well as custom filter types for querying, and custom error types for error handling.

### Type-safe data

[Section titled “Type-safe data”](#type-safe-data)

Live loaders can define types for the data they return. This allows TypeScript to provide type checking and autocompletion when working with the data in your components.

 store-loader.ts

```
import type { LiveLoader } from 'astro/loaders';import { fetchProduct, fetchCategory, type Product } from './store-client';
export function storeLoader(): LiveLoader<Product> {  // ...}
```

When you use `getLiveCollection()` or `getLiveEntry()`, TypeScript will infer the types based on the loader’s definition:

```
---export const prerender = false; // Not needed in 'server' mode
import { getLiveEntry } from 'astro:content';const { entry: product } = await getLiveEntry('products', '123');// TypeScript knows product.data is of type Productconsole.log(product?.data.name);---
```

### Type-safe filters

[Section titled “Type-safe filters”](#type-safe-filters)

Live loaders can define custom filter types for both `getLiveCollection()` and `getLiveEntry()`. This enables type-safe querying that matches your API’s capabilities, making it easier for users to discover available filters and ensure they are used correctly. If you include JSDoc comments in your filter types, the user will see these in their IDE as hints when using the loader.

 store-loader.ts

```
import type { LiveLoader } from 'astro/loaders';import { fetchProduct, fetchCategory, type Product } from './store-client';
interface CollectionFilter {  category?: string;  /** Minimum price to filter products */  minPrice?: number;  /** Maximum price to filter products */  maxPrice?: number;}
interface EntryFilter {  /** Alias for `sku` */  id?: string;  slug?: string;  sku?: string;}
export function productLoader(config: {  apiKey: string;  endpoint: string;}): LiveLoader<Product, EntryFilter, CollectionFilter> {  return {    name: 'product-loader',    loadCollection: async ({ filter }) => {      // filter is typed as CollectionFilter      const data = await fetchCategory({        apiKey: config.apiKey,        category: filter?.category ?? 'all',        minPrice: filter?.minPrice,        maxPrice: filter?.maxPrice,      });
      return {        entries: data.products.map((product) => ({          id: product.sku,          data: product,        })),      };    },    loadEntry: async ({ filter }) => {      // filter is typed as EntryFilter | { id: string }      const product = await fetchProduct({        apiKey: config.apiKey,        slug: filter.slug,        sku: filter.sku || filter.id,      });      if (!product) {        return {          error: new Error('Product not found'),        };      }      return {        id: product.sku,        entry: product,      };    },  };}
```

### Custom error types

[Section titled “Custom error types”](#custom-error-types)

You can create custom error types for [errors returned by your loader](#error-handling-in-loaders) and pass them as a generic to get proper typing:

 my-loader.ts

```
class MyLoaderError extends Error {  constructor(    message: string,    public code?: string  ) {    super(message);    this.name = 'MyLoaderError';  }}
export function myLoader(config): LiveLoader<MyData, undefined, undefined, MyLoaderError> {  return {    name: 'my-loader',    loadCollection: async ({ filter }) => {      // Return your custom error type      return {        error: new MyLoaderError('Failed to load', 'LOAD_ERROR'),      };    },    // ...  };}
```

When you use `getLiveCollection()` or `getLiveEntry()`, TypeScript will infer the custom error type, allowing you to handle it appropriately:

```
---export const prerender = false; // Not needed in 'server' mode
import { getLiveEntry } from 'astro:content';
const { entry, error } = await getLiveEntry('products', '123');
if (error) {  if (error.name === 'MyLoaderError') {    console.error(`Loader error: ${error.message} (code: ${error.code})`);  } else {    console.error(`Unexpected error: ${error.message}`);  }  return Astro.rewrite('/500');}---
```

## Using Zod schemas

[Section titled “Using Zod schemas”](#using-zod-schemas)

Just like with build-time collections, you can use [Zod schemas](https://docs.astro.build/en/guides/content-collections/#defining-the-collection-schema) with live collections to validate and transform data at runtime. When you define a schema, it takes precedence over [the loader’s types](#type-safe-data) when you query the collection:

 src/live.config.ts

```
import { defineLiveCollection } from 'astro:content';import { z } from 'astro/zod';import { apiLoader } from './loaders/api-loader';
const products = defineLiveCollection({  loader: apiLoader({ endpoint: process.env.API_URL }),  schema: z    .object({      id: z.string(),      name: z.string(),      price: z.number(),      // Transform the API's category format      category: z.string().transform((str) => str.toLowerCase().replace(/\s+/g, '-')),      // Coerce the date to a Date object      createdAt: z.coerce.date(),    })    .transform((data) => ({      ...data,      // Add a formatted price field      displayPrice: `$${data.price.toFixed(2)}`,    })),});
export const collections = { products };
```

When using Zod schemas, validation errors are automatically caught and returned as `AstroError` objects:

```
---export const prerender = false; // Not needed in 'server' mode
import { getLiveEntry, LiveCollectionValidationError } from 'astro:content';
const { entry, error } = await getLiveEntry('products', '123');
// You can handle validation errors specificallyif (LiveCollectionValidationError.is(error)) {  console.error(error.message);  return Astro.rewrite('/500');}
// TypeScript knows entry.data matches your Zod schema, not the loader's typeconsole.log(entry?.data.displayPrice); // e.g., "$29.99"---
```

## Cache hints

[Section titled “Cache hints”](#cache-hints)

Live loaders can provide cache hints to help with response caching. You can use this data to send HTTP cache headers or otherwise inform your caching strategy.

 my-loader.ts

```
import type { LiveLoader } from "astro/loaders";import { loadStoreProduct, loadStoreProducts, getLastModifiedDate } from "./store";import type { MyData } from "./types";
export function myLoader(config): LiveLoader<MyData> {  return {    name: 'cached-loader',    loadCollection: async ({ filter }) => {      const products = await loadStoreProducts(filter);      return {        entries: products.map((item) => ({          id: item.id,          data: item,          // You can optionally provide cache hints for each entry          cacheHint: {            tags: [`product-${item.id}`, `category-${item.category}`],          },        })),        cacheHint: {          // All fields are optional, and are combined with each entry's cache hints          // tags are merged from all entries          // lastModified is the most recent lastModified of all entries and the collection          lastModified: getLastModifiedDate(products),          tags: ['products'],        },      };    },    loadEntry: async ({ filter }) => {      const item = await loadStoreProduct(filter);      return {        id: item.id,        data: item,        cacheHint: {          lastModified: new Date(item.lastModified),          tags: [`product-${item.id}`, `category-${item.category}`],        },      };    },  };}
```

You can then use these hints in your pages:

```
---export const prerender = false; // Not needed in 'server' mode
import { getLiveEntry } from 'astro:content';
const { entry, error, cacheHint } = await getLiveEntry('products', Astro.params.id);
if (error) {  return Astro.redirect('/404');}
// Apply cache hints to response headersif (cacheHint?.tags) {  Astro.response.headers.set('Cache-Tag', cacheHint.tags.join(','));}if (cacheHint?.lastModified) {  Astro.response.headers.set('Last-Modified', cacheHint.lastModified.toUTCString());}---
<h1>{entry.data.name}</h1><p>{entry.data.description}</p>
```

## Live collection limitations

[Section titled “Live collection limitations”](#live-collection-limitations)

Live content collections have some limitations compared to build-time collections:

- **No MDX support**: MDX cannot be rendered at runtime
- **No image optimization**: Images cannot be processed at runtime
- **Performance considerations**: Data is fetched on each request (unless cached)
- **No data store persistence**: Data is not saved to the content layer data store

## Differences from build-time collections

[Section titled “Differences from build-time collections”](#differences-from-build-time-collections)

Live collections use a different API than current preloaded content collections. Key differences include:

1. **Execution time**: Run at request time instead of build time
2. **Configuration file**: Use `src/live.config.ts` instead of `src/content.config.ts`
3. **Collection definition**: Use `defineLiveCollection()` instead of `defineCollection()`
4. **Loader API**: Implement `loadCollection` and `loadEntry` methods instead of the `load` method
5. **Data return**: Return data directly instead of storing in the data store
6. **User-facing functions**: Use `getLiveCollection`/`getLiveEntry` instead of `getCollection`/`getEntry`

For a complete overview and to give feedback on this experimental API, see the [Live Content collections RFC](https://github.com/withastro/roadmap/blob/feat/live-loaders/proposals/0055-live-content-loaders.md).

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Experimental preserve scripts order

# Experimental preserve scripts order

**Type:** `boolean`
 **Default:** `false`

 **Added in:** `astro@5.5.0`

Renders multiple `<style>` and `<script>` tags in the same order as they were declared in the source code.

To enable this behavior, add the `experimental.preserveScriptOrder` feature flag to your Astro config:

 astro.config.mjs

```
import { defineConfig } from "astro/config"
export default defineConfig({  experimental: {    preserveScriptOrder: true  }})
```

## Usage

[Section titled “Usage”](#usage)

This experimental flag requires no specific usage and only affects the order in which Astro renders your styles and scripts.

When rendering multiple `<style>` and `<script>` tags on the same page, Astro currently reverses their order in your generated HTML output. This can give unexpected results, for example, CSS styles being overridden by earlier defined style tags when your site is built. This experimental flag instead renders `<script>` and `<style>` tags in the order they are defined.

For example, the following component has two `<style>` tags and two `<script>` tags:

 src/components/MyComponent.astro

```
<p>I am a component</p><style>  body {    background: red;  }</style><style>  body {    background: yellow;  }</style><script>    console.log("hello")</script><script>    console.log("world!")</script>
```

After compiling, Astro’s default behavior will create an inline style where `yellow` appears first, and then `red`. This means the `red` background is applied. Similarly with the two scripts, the word `world!` is logged first, and then `hello` second:

```
body {background:#ff0} body {background:red}
```

```
console.log("world!")console.log("hello")
```

When `experimental.preserveScriptOrder` is set to `true`, the rendering order of `<style>` and `<script>` tags matches the order in which they are written. For the same example component, the style generated `red` appears first, and then `yellow`; as for the scripts, `hello` is logged first, and then `world!`:

```
body {background:red} body {background:#ff0}
```

```
console.log("hello")console.log("world!")
```

In a future major version, Astro will preserve style and script order by default, but you can opt in to the future behavior early using the `experimental.preserveScriptOrder` flag.

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Experimental private meta environment variables inlining

# Experimental private meta environment variables inlining

**Type:** `boolean`
 **Default:** `false`

 **Added in:** `astro@5.13.0`

Astro allows you to configure a [type-safe schema for your environment variables](https://docs.astro.build/en/guides/environment-variables/#type-safe-environment-variables), and converts variables imported via `astro:env` into the expected type. This is the recommended way to use environment variables in Astro, as it allows you to easily see and manage whether your variables are public or secret, available on the client or only on the server at build time, and the data type of your values.

However, you can still access your environment variables through `process.env` as well as `import.meta.env` directly if needed. This was the only way to use environment variables in Astro before `astro:env` was added in Astro 5.0, and its handling of `import.meta.env` includes some logic that was intended for earlier versions of Astro that is no longer necessary.

The `experimental.staticImportMetaEnv` flag updates the behavior when accessing `import.meta.env` directly to align with [Vite’s handling of environment variables](https://vite.dev/guide/env-and-mode.html#env-variables) and ensures that `import.meta.env` values are always inlined.

Currently, non-public environment variables are replaced by a reference to `process.env`. Additionally, Astro may also convert the value type of your environment variables used through `import.meta.env`, which can prevent access to some values such as the strings `"true"` (which is converted to a boolean value), and `"1"` (which is converted to a number).

The `experimental.staticImportMetaEnv` flag simplifies Astro’s default behavior, making it easier to understand and use. Astro will no longer replace any `import.meta.env` environment variables with a `process.env` call, nor will it coerce values.

To enable this feature, add the experimental flag in your Astro config:

 astro.config.mjs

```
import { defineConfig } from "astro/config"
export default defineConfig({  experimental: {    staticImportMetaEnv: true,  }})
```

## Usage

[Section titled “Usage”](#usage)

Enabling this experimental flag will no longer convert string values into booleans or numbers, nor turn `import.meta.env` values into `process.env` calls. This aligns `import.meta.env`’s behavior in Astro with [Vite](https://vite.dev/guide/env-and-mode.html#env-variables).

In a future major version, Astro will switch to this behavior by default, but you can opt in to the future behavior early using the `experimental.staticImportMetaEnv` flag and, if necessary, [updating your project](#updating-your-project) accordingly.

### Updating your project

[Section titled “Updating your project”](#updating-your-project)

If you were relying on coercion, you may need to update your project code to apply it manually:

 src/components/MyComponent.astro

```
const enabled: boolean = import.meta.env.ENABLED;const enabled: boolean = import.meta.env.ENABLED === "true";
```

If you were relying on the transformation into `process.env`, you may need to update your project code to apply it manually:

 src/components/MyComponent.astro

```
const enabled: boolean = import.meta.env.DB_PASSWORD;const enabled: boolean = process.env.DB_PASSWORD;
```

You may also need to update types:

 src/env.d.ts

```
interface ImportMetaEnv {  readonly PUBLIC_POKEAPI: string;  readonly DB_PASSWORD: string;  readonly ENABLED: boolean;  readonly ENABLED: string;}
interface ImportMeta {  readonly env: ImportMetaEnv;}
namespace NodeJS {  interface ProcessEnv {    DB_PASSWORD: string;  }}
```

If you need more control over environment variables in Astro, we recommend you use [astro:env](https://docs.astro.build/en/guides/environment-variables/).

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Experimental SVG optimization

# Experimental SVG optimization

**Type:** `boolean | object`
 **Default:** `false`

 **Added in:** `astro@5.16.0`

This experimental feature enables automatic optimization of your [SVG components](https://docs.astro.build/en/guides/images/#svg-components) using [SVGO](https://svgo.dev/) during build time.

When enabled, your imported SVG files used as components will be optimized for smaller file sizes and better performance while maintaining visual quality. This can significantly reduce the size of your SVG assets by removing unnecessary metadata, comments, and redundant code.

To enable this feature with default settings, set it to `true` in your Astro config:

 astro.config.mjs

```
import { defineConfig } from "astro/config"
export default defineConfig({  experimental: {    svgo: true  }})
```

## Usage

[Section titled “Usage”](#usage)

No change to using SVG components is required to take advantage of this feature. With experimental `svgo` enabled, all your SVG component import files will be automatically optimized:

 src/pages/index.astro

```
---import Logo from '../assets/logo.svg';---
<Logo />
```

The SVG will be optimized during the build process, resulting in smaller file sizes in your production build.

Note that this optimization applies to every SVG component import in your project. It is not possible to opt out on a per-component basis.

## Configuration

[Section titled “Configuration”](#configuration)

You can pass a [SVGO configuration object](https://github.com/svg/svgo/blob/66d503a48c6c95661726262a3068053c429b06a9/lib/types.ts#L335) to customize optimization behavior:

 astro.config.mjs

```
export default defineConfig({  experimental: {    svgo: {      plugins: [        'preset-default',        {          name: 'removeViewBox',          active: false        }      ]    }  }})
```

### plugins

[Section titled “plugins”](#plugins)

**Type:** `Array<string | PluginConfig>`
 **Default:** `[]`

An array of [SVGO plugins](https://svgo.dev/docs/plugins/) that will be used to optimize your SVG component imports.

This can include any plugins by ID name, including SVGO’s `preset-default` collection of plugins. A plugin can optionally be passed as an object including both its `name` and `active` status, to enable or disable as necessary.

 astro.config.mjs

```
export default defineConfig({  experimental: {    svgo: {      plugins: [        'preset-default',        {          name: 'removeViewBox',          active: false        }      ]    }  }})
```

### Other configuration options

[Section titled “Other configuration options”](#other-configuration-options)

You can also pass [other SVGO configuration options](https://github.com/svg/svgo/blob/66d503a48c6c95661726262a3068053c429b06a9/lib/types.ts#L335), such as `floatPrecision` and `multipass`, directly to your config object:

 astro.config.mjs

```
export default defineConfig({  experimental: {    svgo: {      floatPrecision: 2,      multipass: true    }  }})
```

## Common use cases

[Section titled “Common use cases”](#common-use-cases)

SVGO provides an extensive [default plugin list](https://svgo.dev/docs/preset-default/) with opinionated optimizations that is more convenient than adding each plugin individually. However, you may need to customize it further for your needs. For example, it may remove items or clean up too aggressively for your situation.

### Preserve specific attributes

[Section titled “Preserve specific attributes”](#preserve-specific-attributes)

You may want to preserve certain SVG attributes, such as the `viewBox`, that SVGO removes by default:

 astro.config.mjs

```
export default defineConfig({  experimental: {    svgo: {      plugins: [        'preset-default',        {          name: 'removeViewBox',          active: false // Preserve viewBox attribute        }      ]    }  }})
```

### Remove specific elements

[Section titled “Remove specific elements”](#remove-specific-elements)

You can configure plugins to remove specific unwanted elements like metadata or hidden layers. Note that many plugins are already included in `preset-default`, so you typically only need to configure their behavior:

 astro.config.mjs

```
export default defineConfig({  experimental: {    svgo: {      plugins: [        'preset-default',        {          name: 'removeMetadata',          active: true        }      ]    }  }})
```

### Custom precision

[Section titled “Custom precision”](#custom-precision)

Control the precision of numeric values in path data:

 astro.config.mjs

```
export default defineConfig({  experimental: {    svgo: {      floatPrecision: 2    }  }})
```

## How it works

[Section titled “How it works”](#how-it-works)

SVG optimization happens during the build process, not at runtime:

- In **development mode**, SVG files are not optimized to ensure faster rebuild times and a smoother development experience.
- In **production builds**, all imported SVG files are optimized once during the build process, resulting in smaller file sizes.
- There is **no runtime overhead** - optimized SVGs are served as pre-processed static assets.

While the optimization process may slightly increase your build times, the result is smaller file sizes and faster page loads for your users.

## Further reading

[Section titled “Further reading”](#further-reading)

- [SVGO documentation](https://svgo.dev/)

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Configuring experimental flags

# Configuring experimental flags

Experimental features are available only after enabling a flag in the Astro configuration file.

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({    experimental: {        // enable experimental flags        // to try out new features    },});
```

Astro offers experimental flags to give users early access to new features for testing and feedback.

These flags allow you to participate in feature development by reporting issues and sharing your opinions. These features are not guaranteed to be stable and may include breaking changes even in small `patch` releases while the feature is actively developed.

We recommend [updating Astro](https://docs.astro.build/en/upgrade-astro/#upgrade-to-the-latest-version) frequently, and keeping up with release notes in the [Astro changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) which will inform you of any changes needed to your project code. The experimental feature documentation will always be updated for the current released version only.

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Image Service API

# Image Service API

`astro:assets` was designed to make it easy for any image optimization service to build a service on top of Astro.

## What is an Image Service?

[Section titled “What is an Image Service?”](#what-is-an-image-service)

Astro provides two types of image services: Local and External.

- **Local services** handle image transformations directly at build for static sites, or at runtime both in development mode and for on-demand rendering. These are often wrappers around libraries like Sharp, ImageMagick, or Squoosh. In dev mode and in production routes rendered on demand, local services use an API endpoint to do the transformation.
- **External services** point to URLs and can add support for services such as Cloudinary, Vercel, or any [RIAPI](https://github.com/riapi/riapi)-compliant server.

## Building using the Image Services API

[Section titled “Building using the Image Services API”](#building-using-the-image-services-api)

Service definitions take the shape of an exported default object with various required methods (“hooks”).

External services provide a `getURL()` that points to the `src` of the output `<img>` tag.

Local services provide a `transform()` method to perform transformations on your image, and  `getURL()` and `parseURL()` methods to use an endpoint for dev mode and when rendered on demand.

Both types of services can provide `getHTMLAttributes()` to determine the other attributes of the output `<img>` and `validateOptions()` to validate and augment the passed options.

### External Services

[Section titled “External Services”](#external-services)

An external service points to a remote URL to be used as the `src` attribute of the final `<img>` tag. This remote URL is responsible for downloading, transforming, and returning the image.

```
import type { ExternalImageService, ImageTransform, AstroConfig } from "astro";
const service: ExternalImageService = {  validateOptions(options: ImageTransform, imageConfig: AstroConfig['image']) {    const serviceConfig = imageConfig.service.config;
    // Enforce the user set max width.    if (options.width && options.width > serviceConfig.maxWidth) {      console.warn(`Image width ${options.width} exceeds max width ${serviceConfig.maxWidth}. Falling back to max width.`);      options.width = serviceConfig.maxWidth;    }
    return options;  },  getURL(options, imageConfig) {    return `https://mysupercdn.com/${options.src}?q=${options.quality}&w=${options.width}&h=${options.height}`;  },  getHTMLAttributes(options, imageConfig) {    const { src, format, quality, ...attributes } = options;    return {      ...attributes,      loading: options.loading ?? 'lazy',      decoding: options.decoding ?? 'async',    };  }};

export default service;
```

### Local Services

[Section titled “Local Services”](#local-services)

To create your own local service, you can point to the [built-in endpoint](https://github.com/withastro/astro/blob/main/packages/astro/src/assets/endpoint/generic.ts) (`/_image`), or you can additionally create your own endpoint that can call the service’s methods.

```
import type { ImageTransform, LocalImageService, AstroConfig } from "astro";
const service: LocalImageService<AstroConfig["image"]> = {  getURL(options: ImageTransform, imageConfig) {    const searchParams = new URLSearchParams();    searchParams.append('href', typeof options.src === "string" ? options.src : options.src.src);    options.width && searchParams.append('w', options.width.toString());    options.height && searchParams.append('h', options.height.toString());    options.quality && searchParams.append('q', options.quality.toString());    options.format && searchParams.append('f', options.format);    return `/my_custom_endpoint_that_transforms_images?${searchParams}`;    // Or use the built-in endpoint, which will call your parseURL and transform functions:    // return `/_image?${searchParams}`;  },  parseURL(url: URL, imageConfig) {    const params = url.searchParams;    return {      src: params.get('href')!,      width: params.has('w') ? parseInt(params.get('w')!) : undefined,      height: params.has('h') ? parseInt(params.get('h')!) : undefined,      format: params.get('f'),      quality: params.get('q'),    };  },  async transform(inputBuffer: Uint8Array, options: { src: string, [key: string]: any }, imageConfig) {    const { buffer } = await mySuperLibraryThatEncodesImages(options);    return {      data: buffer,      format: options.format,    };  },  getHTMLAttributes(options, imageConfig) {    let targetWidth = options.width;    let targetHeight = options.height;    if (typeof options.src === "object") {      const aspectRatio = options.src.width / options.src.height;
      if (targetHeight && !targetWidth) {        targetWidth = Math.round(targetHeight * aspectRatio);      } else if (targetWidth && !targetHeight) {        targetHeight = Math.round(targetWidth / aspectRatio);      }    }
    const { src, width, height, format, quality, ...attributes } = options;
    return {      ...attributes,      width: targetWidth,      height: targetHeight,      loading: attributes.loading ?? 'lazy',      decoding: attributes.decoding ?? 'async',    };  },  propertiesToHash: ['src', 'width', 'height', 'format', 'quality'],};export default service;
```

At build time for static sites and pre-rendered routes, both `<Image />` and `getImage(options)` call the `transform()` function. They pass options either through component attributes or an `options` argument, respectively. The transformed images will be built to a `dist/_astro` folder. Their file names will contain a hash of the properties passed to `propertiesToHash`. This property is optional and will default to `['src', 'width', 'height', 'format', 'quality']`. If your custom image service has more options that change the generated images, add these to the array.

In dev mode and when using an adapter to render on demand, Astro doesn’t know ahead of time which images need to be optimized. Astro uses a GET endpoint (by default, `/_image`) to process the images at runtime. `<Image />` and `getImage()` pass their options to `getURL()`, which will return the endpoint URL. Then, the endpoint calls `parseURL()` and passes the resulting properties to `transform()`.

#### getConfiguredImageService & imageConfig

[Section titled “getConfiguredImageService & imageConfig”](#getconfiguredimageservice--imageconfig)

If you implement your own endpoint as an Astro endpoint, you can use [getConfiguredImageService](https://docs.astro.build/en/reference/modules/astro-assets/#getconfiguredimageservice) and [imageConfig](https://docs.astro.build/en/reference/modules/astro-assets/#imageconfig) to call your service’s `parseURL` and `transform` methods and provide the image config.

To access the image service config ([image.service.config](https://docs.astro.build/en/reference/configuration-reference/#imageservice)), you can use `imageConfig.service.config`.

 src/api/my_custom_endpoint_that_transforms_images.ts

```
import type { APIRoute } from "astro";import { getConfiguredImageService, imageConfig } from 'astro:assets';
export const GET: APIRoute = async ({ request }) => {  const imageService = await getConfiguredImageService();
  const imageTransform = imageService.parseURL(new URL(request.url), imageConfig);  // ... fetch the image from imageTransform.src and store it in inputBuffer  const { data, format } = await imageService.transform(inputBuffer, imageTransform, imageConfig);  return new Response(data, {      status: 200,      headers: {        'Content-Type': mime.getType(format) || ''      }    }  );}
```

[See the built-in endpoint](https://github.com/withastro/astro/blob/main/packages/astro/src/assets/endpoint/generic.ts) for a full example.

## Hooks

[Section titled “Hooks”](#hooks)

### getURL()

[Section titled “getURL()”](#geturl)

**Type:** `(options: ImageTransform, imageConfig: AstroConfig[‘image’]) => string | Promise<string>`

 **Added in:** `astro@2.1.0`

**Required for local and external services**

For local services, this hook returns the URL of the endpoint that generates your image (for on-demand rendering and in dev mode). It is unused during build. The local endpoint that `getURL()` points to may call both `parseURL()` and `transform()`.

For external services, this hook returns the final URL of the image.

For both types of services, `options` are the properties passed by the user as attributes of the `<Image />` component or as options to `getImage()`.

### parseURL()

[Section titled “parseURL()”](#parseurl)

**Type:** `(url: URL, imageConfig: AstroConfig[‘image’]) => { src: string, [key: string]: any } | undefined | Promise<{ src: string, [key: string]: any }> | Promise<undefined>`

 **Added in:** `astro@2.1.0`

**Required for local services only; unavailable for external services**

This hook parses the generated URLs by `getURL()` back into an object with the different properties to be used by `transform` (for on-demand rendering and in dev mode). It is unused during build.

### transform()

[Section titled “transform()”](#transform)

**Type:** `(inputBuffer: Uint8Array, options: { src: string, [key: string]: any }, imageConfig: AstroConfig[‘image’]) => Promise<{ data: Uint8Array; format: ImageOutputFormat }>`

 **Added in:** `astro@2.1.0`

**Required for local services only; unavailable for external services**

This hook transforms and returns the image and is called during the build to create the final asset files.

You must return a `format` to ensure that the proper MIME type is served to users for on-demand rendering and development mode.

### getHTMLAttributes()

[Section titled “getHTMLAttributes()”](#gethtmlattributes)

**Type:** `(options: ImageTransform, imageConfig: AstroConfig[‘image’] ) => Record<string, any> | Promise<Record<string, any>>`

 **Added in:** `astro@2.1.0`

**Optional for both local and external services**

This hook returns all additional attributes used to render the image as HTML, based on the parameters passed by the user (`options`).

### getSrcSet()

[Section titled “getSrcSet()”](#getsrcset)

**Type:** `(options: ImageTransform, imageConfig: AstroConfig[‘image’] ) => UnresolvedSrcSetValue[] | Promise<UnresolvedSrcSetValue[]>`

 **Added in:** `astro@3.3.0`

**Optional for both local and external services.**

This hook generates multiple variants of the specified image, for example, to generate a `srcset` attribute on an `<img>` or `<picture>`’s `source`.

This hook returns an array of objects with the following properties:

```
export type UnresolvedSrcSetValue = {  transform: ImageTransform;  descriptor?: string;  attributes?: Record<string, any>;};
```

### validateOptions()

[Section titled “validateOptions()”](#validateoptions)

**Type:** `(options: ImageTransform, imageConfig: AstroConfig[‘image’] ) => ImageTransform | Promise<ImageTransform>`

 **Added in:** `astro@2.1.4`

**Optional for both local and external services**

This hook allows you to validate and augment the options passed by the user. This is useful for setting default options, or telling the user that a parameter is required.

[See howvalidateOptions()is used in Astro built-in services](https://github.com/withastro/astro/blob/0ab6bad7dffd413c975ab00e545f8bc150f6a92f/packages/astro/src/assets/services/service.ts#L124).

## User configuration

[Section titled “User configuration”](#user-configuration)

Configure the image service to use in `astro.config.mjs`. The config takes the following form:

 astro.config.mjs

```
import { defineConfig } from "astro/config";
export default defineConfig({  image: {    service: {      entrypoint: "your-entrypoint", // 'astro/assets/services/sharp' | string,      config: {        // ... service-specific config. Optional.      }    }  },});
```

## Typing custom image service props

[Section titled “Typing custom image service props”](#typing-custom-image-service-props)

**Added in:** `astro@5.16.6`

If your image service supports additional props in Astro’s `<Image>` component, `<Picture>` component, or the `getImage()` function, you can add types for these by extending the `Astro.CustomImageProps` interface.

For example, to add a custom `blur` prop that your image service supports:

```
declare namespace Astro {  interface CustomImageProps {    /** Apply a Gaussian blur with this radius to the image. */    blur?: number;  }}
```

You can expose these types to users by making your image service an [Astro integration](https://docs.astro.build/en/reference/integrations-reference/) and using the [injectTypes()](https://docs.astro.build/en/reference/integrations-reference/#injecttypes-option) helper.

Then, users will be able to get autocomplete and type safety for your custom props:

```
<Image blur="yes" src={myPhoto}  />//     ^^^^^^^^^^//     Type 'string' is not assignable to type 'number | undefined'.
```

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
