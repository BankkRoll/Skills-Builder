# Storyblok & Astro and more

# Storyblok & Astro

> Add content to your Astro project using Storyblok as a CMS

# Storyblok & Astro

[Storyblok](https://www.storyblok.com/) is a component-based headless CMS that allows you to manage your content using reusable components called Bloks.

## Integrating with Astro

[Section titled “Integrating with Astro”](#integrating-with-astro)

In this section, you will use the [Storyblok integration](https://github.com/storyblok/monoblok/tree/main/packages/astro) to connect Storyblok to Astro.

### Prerequisites

[Section titled “Prerequisites”](#prerequisites)

To get started, you will need to have the following:

1. **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](https://docs.astro.build/en/install-and-setup/) will get you up and running in no time.
2. **A Storyblok account and space** - If you don’t have an account yet, [sign up for free](https://app.storyblok.com/#/signup) and create a new space.
3. **Storyblok Preview token** - This token will be used to fetch drafts and published versions of your content. You can find and generate your API token in the Access Tokens tab of your Storyblok space settings.

### Setting up credentials

[Section titled “Setting up credentials”](#setting-up-credentials)

To add your Storyblok credentials to Astro, create a `.env` file in the root of your project with the following variable:

 .env

```
STORYBLOK_TOKEN=YOUR_PREVIEW_TOKEN
```

Now, you should be able to use these environment variables in your project.

Your root directory should now include this new file:

- Directorysrc/
  - …
- **.env**
- astro.config.mjs
- package.json

### Installing dependencies

[Section titled “Installing dependencies”](#installing-dependencies)

To connect Astro with your Storyblok space, install the official [Storyblok integration](https://github.com/storyblok/monoblok/tree/main/packages/astro) using the command below for your preferred package manager:

- [npm](#tab-panel-2798)
- [pnpm](#tab-panel-2799)
- [Yarn](#tab-panel-2800)

   Terminal window

```
npm install @storyblok/astro vite
```

   Terminal window

```
pnpm add @storyblok/astro vite
```

   Terminal window

```
yarn add @storyblok/astro vite
```

### Configuring Storyblok

[Section titled “Configuring Storyblok”](#configuring-storyblok)

Modify your Astro config file to include the Storyblok integration:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';import { storyblok } from '@storyblok/astro';import { loadEnv } from 'vite';
const env = loadEnv("", process.cwd(), 'STORYBLOK');
export default defineConfig({  integrations: [    storyblok({      accessToken: env.STORYBLOK_TOKEN,      components: {        // Add your components here      },      apiOptions: {        // Choose your Storyblok space region        region: 'us', // optional,  or 'eu' (default)      },    })  ],});
```

The Storyblok integration requires an object with the following properties:

1. `accessToken` - This references the Storyblok API token that you added in the previous step.
2. `components` - An object that maps Storyblok component names to paths to your local components. This is required to render your Storyblok Bloks in Astro.
3. `apiOptions` - An object containing [Storyblok API options](https://www.storyblok.com/docs/packages/storyblok-astro#api).

### Connecting Bloks to Astro components

[Section titled “Connecting Bloks to Astro components”](#connecting-bloks-to-astro-components)

To connect your Bloks to Astro, create a new folder named `storyblok` in the `src` directory. This folder will contain all the Astro components that will match your Bloks in your Storyblok Blok library.

In this example, you have a `blogPost` Blok content type in your Storyblok library with the following fields:

- `title` - A text field
- `description` - A text field
- `content` - A rich text field

Our goal is to create the equivalent Astro component that will use these fields to render its content. To do this, create a new file named `BlogPost.astro` inside `src/storyblok` with the following content:

 src/storyblok/BlogPost.astro

```
---import { storyblokEditable, renderRichText } from '@storyblok/astro'
const { blok } = Astro.propsconst content = renderRichText(blok.content)---
<article {...storyblokEditable(blok)}>  <h1>{blok.title}</h1>  <p>{blok.description}</p>  <Fragment set:html={content} /></article>
```

The `blok` property contains the data that you will receive from Storyblok. It also contains the fields that were defined in the `blogPost` content type Blok in Storyblok.

To render our content, the integration provides utility functions such as:

- `storyblokEditable` - it adds the necessary attributes to the elements so that you can edit them in Storyblok.
- `renderRichText` - it transforms the rich text field into HTML.

Your root directory should include this new file:

- Directorysrc/
  - Directorystoryblok/
    - **BlogPost.astro**
- .env
- astro.config.mjs
- package.json

Finally, to connect the `blogPost` Blok to the `BlogPost` component, add a new property to your components object in your Astro config file.

- The key is the name of the Blok in Storyblok. In this case, it is `blogPost`.
- The value is the path to the component. In this case, it is `storyblok/BlogPost`.

  astro.config.mjs

```
import { defineConfig } from 'astro/config';import { storyblok } from '@storyblok/astro';import { loadEnv } from 'vite';
const env = loadEnv("", process.cwd(), 'STORYBLOK');
export default defineConfig({  integrations: [    storyblok({      accessToken: env.STORYBLOK_TOKEN,      components: {        blogPost: 'storyblok/BlogPost',      },      apiOptions: {        region: 'us',      },    })  ],});
```

### Fetching data

[Section titled “Fetching data”](#fetching-data)

To test the setup, in Storyblok create a new story with the `blogPost` content type named `test-post`.
In Astro, create a new page in the `src/pages/` directory named `test-post.astro` with the following content:

 src/pages/test-post.astro

```
---import { useStoryblokApi } from '@storyblok/astro'import StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro'
const storyblokApi = useStoryblokApi()
const { data } = await storyblokApi.get("cdn/stories/test-post", {  version: import.meta.env.DEV ? "draft" : "published",});
const content = data.story.content;---<StoryblokComponent blok={content} />
```

To query your data, use the `useStoryblokApi` hook. This will initialize a new client instance using your integration configuration.

To render your content, pass the `content` property of the Story to the `StoryblokComponent` as a `blok` prop. This component will render the Bloks that are defined inside the `content` property. In this case, it will render the `BlogPost` component.

## Making a blog with Astro and Storyblok

[Section titled “Making a blog with Astro and Storyblok”](#making-a-blog-with-astro-and-storyblok)

With the integration set up, you can now create a blog with Astro and Storyblok.

### Prerequisites

[Section titled “Prerequisites”](#prerequisites-1)

1. **A Storyblok space** - For this tutorial, we recommend using a new space. If you already have a space with Bloks, feel free to use them, but you will need to modify the code to match the Blok names and content types.
2. **An Astro project integrated with Storyblok** - See [integrating with Astro](#integrating-with-astro) for instructions on how to set up the integration.

### Creating a blok library

[Section titled “Creating a blok library”](#creating-a-blok-library)

To create Bloks, go to the Storyblok app and click on the **Block Library** tab. Click on the + New blok button and create the following Bloks:

1. `blogPost` - A content type Blok with the following fields:
  - `title` - A text field
  - `description` - A text field
  - `content` - A rich text field
2. `blogPostList` - An empty nestable Blok
3. `page` - A content type Blok with the following fields:
  - `body` - A nestable Blok

### Creating content

[Section titled “Creating content”](#creating-content)

To add new content, go to the content section by clicking on the **Content** tab. Using the Blok library that you created in the previous step, create the following stories:

1. `home` - A content type story with the `page` Blok. Inside the `body` field, add a `blogPostList` Blok.
2. `blog/no-javascript` - A story with the `blogPost` content type inside the blog folder.
  ```
  title: No JavaScriptdescription: A sample blog postcontent: Hi there! This blog post doesn't use JavaScript.
  ```
3. `blog/astro-is-amazing` - A story with the `blogPost` content type inside the blog folder.
  ```
  title: Astro is amazingdescription: We love Astrocontent: Hi there! This blog post was build with Astro.
  ```

Now that you have your content ready, return to your Astro project and start building your blog.

### Connecting Bloks to components

[Section titled “Connecting Bloks to components”](#connecting-bloks-to-components)

To connect your newly created Bloks to Astro components, create a new folder named `storyblok` in your `src` directory and add the following files:

`Page.astro` is a nestable Block content type component that will recursively render all the Bloks inside the `body` property of the `page` Blok. It also adds the `storyblokEditable` attributes to the parent element which will allow us to edit the page in Storyblok.

 src/storyblok/Page.astro

```
---import { storyblokEditable } from '@storyblok/astro'import StoryblokComponent from "@storyblok/astro/StoryblokComponent.astro";const { blok } = Astro.props---
<main {...storyblokEditable(blok)}>  {    blok.body?.map((blok) => {      return <StoryblokComponent blok={blok} />    })  }</main>
```

`BlogPost.astro` will render the `title`, `description` and `content` properties of the `blogPost` Blok.

To transform the `content` property from a rich text field to HTML, you can use the `renderRichText` helper function.

 src/storyblok/BlogPost.astro

```
---import { storyblokEditable, renderRichText } from '@storyblok/astro'const { blok } = Astro.propsconst content = renderRichText(blok.content)---<article {...storyblokEditable(blok)}>  <h1>{blok.title}</h1>  <p>{blok.description}</p>  <Fragment set:html={content} /></article>
```

`BlogPostList.astro` is a nestable Blok content type component that will render a list of blog post previews.

It uses the `useStoryblokApi` hook to fetch all the stories with the content type of `blogPost`. It uses the `version` query parameter to fetch the draft versions of the stories when in development mode and the published versions when building for production.

`Astro.props` is used to set up the editor in Storyblok. Additional props can also be passed to your component here, if needed.

 src/storyblok/BlogPostList.astro

```
---import { storyblokEditable } from '@storyblok/astro'import { useStoryblokApi } from '@storyblok/astro'
const storyblokApi = useStoryblokApi();
const { data } = await storyblokApi.get('cdn/stories', {  version: import.meta.env.DEV ? "draft" : "published",  content_type: 'blogPost',})
const posts = data.stories.map(story => {  return {    title: story.content.title,    date: new Date(story.published_at).toLocaleDateString("en-US", {dateStyle: "full"}),    description: story.content.description,    slug: story.full_slug,  }})
const { blok } = Astro.props---
<ul {...storyblokEditable(blok)}>  {posts.map(post => (    <li>      <time>{post.date}</time>      <a href={post.slug}>{post.title}</a>      <p>{post.description}</p>    </li>  ))}</ul>
```

Finally, add your components to the `components` property of the `storyblok` config object in `astro.config.mjs`. The key is the name of the Blok in Storyblok, and the value is the path to the component relative to `src`.

 astro.config.mjs

```
import { defineConfig } from 'astro/config';import { storyblok } from '@storyblok/astro';import { loadEnv } from 'vite';
const env = loadEnv("", process.cwd(), 'STORYBLOK');
export default defineConfig({  integrations: [    storyblok({      accessToken: env.STORYBLOK_TOKEN,      components: {        blogPost: 'storyblok/BlogPost',        blogPostList: 'storyblok/BlogPostList',        page: 'storyblok/Page',      },      apiOptions: {        region: 'us',      },    })  ],});
```

### Generating pages

[Section titled “Generating pages”](#generating-pages)

To create a route for a specific `page`, you can fetch its content directly from the Storyblok API and pass it to the `StoryblokComponent` component.  Remember to make sure you have added the `Page` component to your astro.config.mjs.

Create an `index.astro` file in `src/pages/` to render the `home` page:

 src/pages/index.astro

```
---import { useStoryblokApi } from '@storyblok/astro'import StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro'import BaseLayout from '../layouts/BaseLayout.astro'
const storyblokApi = useStoryblokApi();const { data } = await storyblokApi.get('cdn/stories/home', {  version: import.meta.env.DEV ? "draft" : "published",});const content = data.story.content;---<html lang="en">  <head>    <title>Storyblok & Astro</title>  </head>  <body>    <StoryblokComponent blok={content} />  </body></html>
```

To generate pages for all of your blog posts, create a `.astro` page that will create dynamic routes. This approach varies depending on whether your routes are prerendered (the default in Astro) or [rendered on demand](https://docs.astro.build/en/guides/on-demand-rendering/).

#### Static site generation

[Section titled “Static site generation”](#static-site-generation)

If you are using Astro’s default static site generation, you will use [dynamic routes](https://docs.astro.build/en/guides/routing/#dynamic-routes) and the `getStaticPaths` function to generate your project pages.

Create a new directory `src/pages/blog/` and add a new file called `[...slug].astro` with the following code:

 src/pages/blog/[...slug].astro

```
---import { useStoryblokApi } from '@storyblok/astro'import StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro'
export async function getStaticPaths() {  const sbApi = useStoryblokApi();
  const { data } = await sbApi.get("cdn/stories", {    content_type: "blogPost",    version: import.meta.env.DEV ? "draft" : "published",  });
  const stories = Object.values(data.stories);
  return stories.map((story) => {    return {      params: { slug: story.slug },    };  });}
const sbApi = useStoryblokApi();const { slug } = Astro.params;const { data } = await sbApi.get(`cdn/stories/blog/${slug}`, {  version: import.meta.env.DEV ? "draft" : "published",});
const story = data.story;---
<html lang="en">  <head>    <title>Storyblok & Astro</title>  </head>  <body>    <StoryblokComponent blok={story.content} />  </body></html>
```

This file will generate a page for each story, with the slug and content fetched from the Storyblok API.

#### On-demand rendering

[Section titled “On-demand rendering”](#on-demand-rendering)

If you are [rendering your routes on demand with an adapter](https://docs.astro.build/en/guides/on-demand-rendering/), you will use dynamic routes to fetch the page data from Storyblok.

Create a new directory `src/pages/blog/` and add a new file called `[...slug].astro` with the following code:

 src/pages/blog/[...slug].astro

```
---import { useStoryblokApi } from '@storyblok/astro'import StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro'const storyblokApi = useStoryblokApi()const slug = Astro.params.slug;let content;try {  const { data } = await storyblokApi.get(`cdn/stories/blog/${slug}`, {    version: import.meta.env.DEV ? "draft" : "published",  });  content = data.story.content} catch (error) {  return Astro.redirect('/404')}---<html lang="en">  <head>    <title>Storyblok & Astro</title>  </head>  <body>    <StoryblokComponent blok={content} />  </body></html>
```

This file will fetch and render the page data from Storyblok that matches the dynamic `slug` parameter.

Since you are using a redirect to `/404`, create a 404 page in `src/pages`:

 src/pages/404.astro

```
<html lang="en">  <head>    <title>Not found</title>  </head>  <body>    <p>Sorry, this page does not exist.</p>  </body></html>
```

If the story is not found, the request will be redirected to the 404 page.

### Publishing your site

[Section titled “Publishing your site”](#publishing-your-site)

To deploy your website, visit our [deployment guides](https://docs.astro.build/en/guides/deploy/) and follow the instructions for your preferred hosting provider.

#### Rebuild on Storyblok changes

[Section titled “Rebuild on Storyblok changes”](#rebuild-on-storyblok-changes)

If your project is using Astro’s default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Storyblok events.

##### Netlify

[Section titled “Netlify”](#netlify)

To set up a webhook in Netlify:

1. Go to your site dashboard and click on **Build & deploy**.
2. Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.
3. Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.

##### Vercel

[Section titled “Vercel”](#vercel)

To set up a webhook in Vercel:

1. Go to your project dashboard and click on **Settings**.
2. Under the **Git** tab, find the **Deploy Hooks** section.
3. Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.

##### Adding a webhook to Storyblok

[Section titled “Adding a webhook to Storyblok”](#adding-a-webhook-to-storyblok)

In your Storyblok space **Settings**, click on the **Webhooks** tab. Paste the webhook URL you copied in the **Story published & unpublished** field and hit Save to create a webhook.

Now, whenever you publish a new story, a new build will be triggered and your blog will be updated.

## Official Resources

[Section titled “Official Resources”](#official-resources)

- [Storyblok Astro Integration](https://www.storyblok.com/mp/announcing-storyblok-astro) to add Storyblok to your project.
- [Storyblok Astro guide](https://www.storyblok.com/docs/guides/astro/)
- [Storyblok Astro package reference](https://www.storyblok.com/docs/packages/storyblok-astro)

## Community Resources

[Section titled “Community Resources”](#community-resources)

- [Getting the Visual Editor to work for Storyblok + Astro](https://dev.to/sandrarodgers/getting-the-visual-editor-to-work-for-storyblok-astro-2gja) by Sandra Rodgers
- [Astro + Storyblok: SSR preview for instant visual editing](https://dev.to/jgierer12/astro-storyblok-ssr-preview-for-instant-visual-editing-3g9m) by Jonas Gierer
- [Astro-Storyblok Previews Site with Netlify’s Branch Deploys Feature](https://dev.to/sandrarodgers/astro-storyblok-previews-site-with-netlifys-branch-deploys-feature-44dh) by Sandra Rodgers

## More CMS guides

- ![](https://docs.astro.build/logos/apostrophecms.svg)
  ### ApostropheCMS
- ![](https://docs.astro.build/logos/builderio.svg)
  ### Builder.io
- ![](https://docs.astro.build/logos/buttercms.svg)
  ### ButterCMS
- ![](https://docs.astro.build/logos/caisy.svg)
  ### Caisy
- ![](https://docs.astro.build/logos/cloudcannon.svg)
  ### CloudCannon
- ![](https://docs.astro.build/logos/contentful.svg)
  ### Contentful
- ![](https://docs.astro.build/logos/cosmic.svg)
  ### Cosmic
- ![](https://docs.astro.build/logos/craft-cms.svg)
  ### Craft CMS
- ![](https://docs.astro.build/logos/craft-cross-cms.svg)
  ### Craft Cross CMS
- ![](https://docs.astro.build/logos/crystallize.svg)
  ### Crystallize
- ![](https://docs.astro.build/logos/datocms.svg)
  ### DatoCMS
- ![](https://docs.astro.build/logos/decap-cms.svg)
  ### Decap CMS
- ![](https://docs.astro.build/logos/directus.svg)
  ### Directus
- ![](https://docs.astro.build/logos/drupal.svg)
  ### Drupal
- ![](https://docs.astro.build/logos/flotiq.svg)
  ### Flotiq
- ![](https://docs.astro.build/logos/frontmatter-cms.svg)
  ### Front Matter CMS
- ![](https://docs.astro.build/logos/ghost.png)
  ### Ghost
- ![](https://docs.astro.build/logos/gitcms.svg)
  ### GitCMS
- ![](https://docs.astro.build/logos/hashnode.png)
  ### Hashnode
- ![](https://docs.astro.build/logos/hygraph.svg)
  ### Hygraph
- ![](https://docs.astro.build/logos/jekyllpad.svg)
  ### JekyllPad
- ![](https://docs.astro.build/logos/keystatic.svg)
  ### Keystatic
- ![](https://docs.astro.build/logos/keystonejs.svg)
  ### KeystoneJS
- ![](https://docs.astro.build/logos/kontent-ai.svg)
  ### Kontent.ai
- ![](https://docs.astro.build/logos/microcms.svg)
  ### microCMS
- ![](https://docs.astro.build/logos/optimizely.svg)
  ### Optimizely CMS
- ![](https://docs.astro.build/logos/payload.svg)
  ### Payload CMS
- ![](https://docs.astro.build/logos/preprcms.svg)
  ### Prepr CMS
- ![](https://docs.astro.build/logos/prismic.svg)
  ### Prismic
- ![](https://docs.astro.build/logos/sanity.svg)
  ### Sanity
- ![](https://docs.astro.build/logos/sitecore.svg)
  ### Sitecore XM
- ![](https://docs.astro.build/logos/sitepins.svg)
  ### Sitepins
- ![](https://docs.astro.build/logos/spinal.svg)
  ### Spinal
- ![](https://docs.astro.build/logos/statamic.svg)
  ### Statamic
- ![](https://docs.astro.build/logos/storyblok.svg)
  ### Storyblok
- ![](https://docs.astro.build/logos/strapi.svg)
  ### Strapi
- ![](https://docs.astro.build/logos/studiocms.svg)
  ### StudioCMS
- ![](https://docs.astro.build/logos/tina-cms.svg)
  ### Tina CMS
- ![](https://docs.astro.build/logos/umbraco.svg)
  ### Umbraco
- ![](https://docs.astro.build/logos/wordpress.svg)
  ### Wordpress

   Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Strapi & Astro

> Add content to your Astro project using Strapi Headless CMS

# Strapi & Astro

[Strapi](https://strapi.io/) is an open-source, customizable, headless CMS.

## Integrating with Astro

[Section titled “Integrating with Astro”](#integrating-with-astro)

This guide will build a wrapper function to connect Strapi with Astro.

### Prerequisites

[Section titled “Prerequisites”](#prerequisites)

To get started, you will need to have the following:

1. **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](https://docs.astro.build/en/install-and-setup/) will get you up and running in no time.
2. **A Strapi CMS server** - You can [set up a Strapi server on a local environment](https://docs.strapi.io/dev-docs/quick-start).

### Adding the Strapi URL in.env

[Section titled “Adding the Strapi URL in .env”](#adding-the-strapi-url-in-env)

To add your Strapi URL to Astro, create a `.env` file in the root of your project (if one does not already exist) and add the following variable:

 .env

```
STRAPI_URL="http://127.0.0.1:1337" # or use your IP address
```

Restart the dev server to use this environment variable in your Astro project.

If you would like to have IntelliSense for your environment variable, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

 src/env.d.ts

```
interface ImportMetaEnv {  readonly STRAPI_URL: string;}
```

Your root directory should now include the new file(s):

- Directorysrc/
  - **env.d.ts**
- **.env**
- astro.config.mjs
- package.json

   Learn more about [environment variables](https://docs.astro.build/en/guides/environment-variables/) and `.env` files in Astro.

### Creating the API wrapper

[Section titled “Creating the API wrapper”](#creating-the-api-wrapper)

Create a new file at `src/lib/strapi.ts` and add the following wrapper function to interact with the Strapi API:

 src/lib/strapi.ts

```
interface Props {  endpoint: string;  query?: Record<string, string>;  wrappedByKey?: string;  wrappedByList?: boolean;}
/** * Fetches data from the Strapi API * @param endpoint - The endpoint to fetch from * @param query - The query parameters to add to the url * @param wrappedByKey - The key to unwrap the response from * @param wrappedByList - If the response is a list, unwrap it * @returns */export default async function fetchApi<T>({  endpoint,  query,  wrappedByKey,  wrappedByList,}: Props): Promise<T> {  if (endpoint.startsWith('/')) {    endpoint = endpoint.slice(1);  }
  const url = new URL(`${import.meta.env.STRAPI_URL}/api/${endpoint}`);
  if (query) {    Object.entries(query).forEach(([key, value]) => {      url.searchParams.append(key, value);    });  }  const res = await fetch(url.toString());  let data = await res.json();
  if (wrappedByKey) {    data = data[wrappedByKey];  }
  if (wrappedByList) {    data = data[0];  }
  return data as T;}
```

This function requires an object with the following properties:

1. `endpoint` - The endpoint you are fetching.
2. `query` - The query parameters to add to the end of URL
3. `wrappedByKey` - The `data` key in the object that wraps your `Response`.
4. `wrappedByList` - A parameter to “unwrap” the list returned by Strapi, and return only the first item.

### Optional: Creating the Article interface

[Section titled “Optional: Creating the Article interface”](#optional-creating-the-article-interface)

If you are using TypeScript, create the following Article interface to correspond to the Strapi content types at `src/interfaces/article.ts`:

 src/interfaces/article.ts

```
export default interface Article {  documentId: number;  title: string;  description: string;  content: string;  slug: string;  createdAt: string;  updatedAt: string;  publishedAt: string;}
```

- Directorysrc/
  - Directoryinterfaces/
    - **article.ts**
  - Directorylib/
    - strapi.ts
  - env.d.ts
- .env
- astro.config.mjs
- package.json

### Displaying a list of articles

[Section titled “Displaying a list of articles”](#displaying-a-list-of-articles)

1. Update your home page `src/pages/index.astro` to display a list of blog posts, each with a description and a link to its own page.
2. Import the wrapper function and the interface. Add the following API call to fetch your articles and return a list:
   src/pages/index.astro
  ```
  ---import fetchApi from '../lib/strapi';import type Article from '../interfaces/article';
  const articles = await fetchApi<Article[]>({  endpoint: 'articles', // the content type to fetch  wrappedByKey: 'data', // the key to unwrap the response});---
  ```
  The API call requests data from `http://localhost:1337/api/articles` and returns `articles`: an array of json objects representing your data:
  ```
  [  {    documentId: 1,    title: "What's inside a Black Hole",    description: "Maybe the answer is in this article, or not...",    content: "Well, we don't know yet...",    slug: "what-s-inside-a-black-hole",    createdAt: "2023-05-28T13:19:46.421Z",    updatedAt: "2023-05-28T13:19:46.421Z",    publishedAt: "2023-05-28T13:19:45.826Z"  },  // ...]
  ```
3. Using data from the `articles` array returned by the API, display your Strapi blog posts in a list. These posts will link to their own individual pages, which you will create in the next step.
   src/pages/index.astro
  ```
  ---import fetchApi from '../lib/strapi';import type Article from '../interfaces/article';
  const articles = await fetchApi<Article[]>({  endpoint: 'articles?populate=image',  wrappedByKey: 'data',});---
  <!DOCTYPE html><html lang="en">  <head>    <title>Strapi & Astro</title>  </head>
    <body>    <main>      <ul>        {          articles.map((article) => (            <li>              <a href={`/blog/${article.slug}/`}>                {article.title}              </a>            </li>          ))        }      </ul>    </main>  </body></html>
  ```

### Generating article pages

[Section titled “Generating article pages”](#generating-article-pages)

Create the file `src/pages/blog/[slug].astro` to [dynamically generate a page](https://docs.astro.build/en/guides/routing/#dynamic-routes) for each article.

- Directorysrc/
  - Directoryinterfaces/
    - article.ts
  - Directorylib/
    - strapi.ts
  - Directorypages/
    - index.astro
    - Directoryblog/
      - **[slug].astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json

#### Static site generation

[Section titled “Static site generation”](#static-site-generation)

In Astro’s default static mode (SSG), use [getStaticPaths()](https://docs.astro.build/en/reference/routing-reference/#getstaticpaths) to fetch your list of articles from Strapi.

 src/pages/blog/[slug].astro

```
---import fetchApi from '../../lib/strapi';import type Article from '../../interfaces/article';
export async function getStaticPaths() {  const articles = await fetchApi<Article[]>({    endpoint: 'articles',    wrappedByKey: 'data',  });
  return articles.map((article) => ({    params: { slug: article.slug },    props: article,  }));}type Props = Article;
const article = Astro.props;---
```

Create the template for each page using the properties of each post object.

 src/pages/blog/[slug].astro

```
---import fetchApi from '../../lib/strapi';import type Article from '../../interfaces/article';
export async function getStaticPaths() {  const articles = await fetchApi<Article[]>({    endpoint: 'articles',    wrappedByKey: 'data',  });
  return articles.map((article) => ({    params: { slug: article.slug },    props: article,  }));}type Props = Article;
const article = Astro.props;---
<!DOCTYPE html><html lang="en">  <head>    <title>{article.title}</title>  </head>
  <body>    <main>      <img src={import.meta.env.STRAPI_URL + article.image.data.url} />
      <h1>{article.title}</h1>
            <p>{article.content}</p>            <MyMarkdownComponent>        {article.content}      </MyMarkdownComponent>            <Fragment set:html={article.content} />    </main>  </body></html>
```

#### On-demand rendering

[Section titled “On-demand rendering”](#on-demand-rendering)

If you’ve [opted into on-demand rendering with an adapter](https://docs.astro.build/en/guides/on-demand-rendering/), [generate your dynamic routes](https://docs.astro.build/en/guides/routing/#on-demand-dynamic-routes) using the following code:

Create the `src/pages/blog/[slug].astro` file:

 src/pages/blog/[slug].astro

```
---import fetchApi from '../../../lib/strapi';import type Article from '../../../interfaces/article';
const { slug } = Astro.params;
let article: Article;
try {  article = await fetchApi<Article>({    endpoint: 'articles',    wrappedByKey: 'data',    wrappedByList: true,    query: {      'filters[slug][$eq]': slug || '',    },  });} catch (error) {  return Astro.redirect('/404');}---
<!DOCTYPE html><html lang="en">  <head>    <title>{article.title}</title>  </head>
  <body>    <main>      <img src={import.meta.env.STRAPI_URL + article.image.data.url} />
      <h1>{article.title}</h1>
            <p>{article.content}</p>            <MyMarkdownComponent>        {article.content}      </MyMarkdownComponent>            <Fragment set:html={article.content} />    </main>  </body></html>
```

This file will fetch and render the page data from Strapi that matches the dynamic `slug` parameter.

Since you are using a redirect to `/404`, create a 404 page in `src/pages`:

 src/pages/404.astro

```
<html lang="en">  <head>    <title>Not found</title>  </head>  <body>    <p>Sorry, this page does not exist.</p>    <img src="https://http.cat/404" />  </body></html>
```

If the article is not found, the user will be redirected to this 404 page and be greeted by a lovely cat.

### Publishing your site

[Section titled “Publishing your site”](#publishing-your-site)

To deploy your website, visit our [deployment guides](https://docs.astro.build/en/guides/deploy/) and follow the instructions for your preferred hosting provider.

#### Rebuild on changes

[Section titled “Rebuild on changes”](#rebuild-on-changes)

If your project is using Astro’s default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Strapi.

##### Netlify

[Section titled “Netlify”](#netlify)

To set up a webhook in Netlify:

1. Go to your site dashboard and click on **Build & deploy**.
2. Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.
3. Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.

##### Vercel

[Section titled “Vercel”](#vercel)

To set up a webhook in Vercel:

1. Go to your project dashboard and click on **Settings**.
2. Under the **Git** tab, find the **Deploy Hooks** section.
3. Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.

##### Adding a webhook to Strapi

[Section titled “Adding a webhook to Strapi”](#adding-a-webhook-to-strapi)

Follow [the Strapi webhooks guide](https://strapi.io/blog/webhooks) to create a webhook in your Strapi admin panel.

## Official Resources

[Section titled “Official Resources”](#official-resources)

- [Strapi Blog Guide For React](https://strapi.io/blog/build-a-blog-with-next-react-js-strapi) by Strapi

## More CMS guides

- ![](https://docs.astro.build/logos/apostrophecms.svg)
  ### ApostropheCMS
- ![](https://docs.astro.build/logos/builderio.svg)
  ### Builder.io
- ![](https://docs.astro.build/logos/buttercms.svg)
  ### ButterCMS
- ![](https://docs.astro.build/logos/caisy.svg)
  ### Caisy
- ![](https://docs.astro.build/logos/cloudcannon.svg)
  ### CloudCannon
- ![](https://docs.astro.build/logos/contentful.svg)
  ### Contentful
- ![](https://docs.astro.build/logos/cosmic.svg)
  ### Cosmic
- ![](https://docs.astro.build/logos/craft-cms.svg)
  ### Craft CMS
- ![](https://docs.astro.build/logos/craft-cross-cms.svg)
  ### Craft Cross CMS
- ![](https://docs.astro.build/logos/crystallize.svg)
  ### Crystallize
- ![](https://docs.astro.build/logos/datocms.svg)
  ### DatoCMS
- ![](https://docs.astro.build/logos/decap-cms.svg)
  ### Decap CMS
- ![](https://docs.astro.build/logos/directus.svg)
  ### Directus
- ![](https://docs.astro.build/logos/drupal.svg)
  ### Drupal
- ![](https://docs.astro.build/logos/flotiq.svg)
  ### Flotiq
- ![](https://docs.astro.build/logos/frontmatter-cms.svg)
  ### Front Matter CMS
- ![](https://docs.astro.build/logos/ghost.png)
  ### Ghost
- ![](https://docs.astro.build/logos/gitcms.svg)
  ### GitCMS
- ![](https://docs.astro.build/logos/hashnode.png)
  ### Hashnode
- ![](https://docs.astro.build/logos/hygraph.svg)
  ### Hygraph
- ![](https://docs.astro.build/logos/jekyllpad.svg)
  ### JekyllPad
- ![](https://docs.astro.build/logos/keystatic.svg)
  ### Keystatic
- ![](https://docs.astro.build/logos/keystonejs.svg)
  ### KeystoneJS
- ![](https://docs.astro.build/logos/kontent-ai.svg)
  ### Kontent.ai
- ![](https://docs.astro.build/logos/microcms.svg)
  ### microCMS
- ![](https://docs.astro.build/logos/optimizely.svg)
  ### Optimizely CMS
- ![](https://docs.astro.build/logos/payload.svg)
  ### Payload CMS
- ![](https://docs.astro.build/logos/preprcms.svg)
  ### Prepr CMS
- ![](https://docs.astro.build/logos/prismic.svg)
  ### Prismic
- ![](https://docs.astro.build/logos/sanity.svg)
  ### Sanity
- ![](https://docs.astro.build/logos/sitecore.svg)
  ### Sitecore XM
- ![](https://docs.astro.build/logos/sitepins.svg)
  ### Sitepins
- ![](https://docs.astro.build/logos/spinal.svg)
  ### Spinal
- ![](https://docs.astro.build/logos/statamic.svg)
  ### Statamic
- ![](https://docs.astro.build/logos/storyblok.svg)
  ### Storyblok
- ![](https://docs.astro.build/logos/strapi.svg)
  ### Strapi
- ![](https://docs.astro.build/logos/studiocms.svg)
  ### StudioCMS
- ![](https://docs.astro.build/logos/tina-cms.svg)
  ### Tina CMS
- ![](https://docs.astro.build/logos/umbraco.svg)
  ### Umbraco
- ![](https://docs.astro.build/logos/wordpress.svg)
  ### Wordpress

   Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# StudioCMS & Astro

> Build and manage content for your Astro project using StudioCMS, a headless CMS designed specifically for Astro.

# StudioCMS & Astro

[StudioCMS](https://studiocms.dev/) is a headless CMS for Astro, built with Astro, that provides a user-friendly and configurable dashboard for content management as well as a custom rendering system to display your Astro components.

## Official resources

[Section titled “Official resources”](#official-resources)

- [StudioCMS documentation](https://docs.studiocms.dev/)
- [StudioCMS GitHub repository](https://github.com/withstudiocms/studiocms)
- [StudioCMS Discord community](https://chat.studiocms.dev)

## More CMS guides

- ![](https://docs.astro.build/logos/apostrophecms.svg)
  ### ApostropheCMS
- ![](https://docs.astro.build/logos/builderio.svg)
  ### Builder.io
- ![](https://docs.astro.build/logos/buttercms.svg)
  ### ButterCMS
- ![](https://docs.astro.build/logos/caisy.svg)
  ### Caisy
- ![](https://docs.astro.build/logos/cloudcannon.svg)
  ### CloudCannon
- ![](https://docs.astro.build/logos/contentful.svg)
  ### Contentful
- ![](https://docs.astro.build/logos/cosmic.svg)
  ### Cosmic
- ![](https://docs.astro.build/logos/craft-cms.svg)
  ### Craft CMS
- ![](https://docs.astro.build/logos/craft-cross-cms.svg)
  ### Craft Cross CMS
- ![](https://docs.astro.build/logos/crystallize.svg)
  ### Crystallize
- ![](https://docs.astro.build/logos/datocms.svg)
  ### DatoCMS
- ![](https://docs.astro.build/logos/decap-cms.svg)
  ### Decap CMS
- ![](https://docs.astro.build/logos/directus.svg)
  ### Directus
- ![](https://docs.astro.build/logos/drupal.svg)
  ### Drupal
- ![](https://docs.astro.build/logos/flotiq.svg)
  ### Flotiq
- ![](https://docs.astro.build/logos/frontmatter-cms.svg)
  ### Front Matter CMS
- ![](https://docs.astro.build/logos/ghost.png)
  ### Ghost
- ![](https://docs.astro.build/logos/gitcms.svg)
  ### GitCMS
- ![](https://docs.astro.build/logos/hashnode.png)
  ### Hashnode
- ![](https://docs.astro.build/logos/hygraph.svg)
  ### Hygraph
- ![](https://docs.astro.build/logos/jekyllpad.svg)
  ### JekyllPad
- ![](https://docs.astro.build/logos/keystatic.svg)
  ### Keystatic
- ![](https://docs.astro.build/logos/keystonejs.svg)
  ### KeystoneJS
- ![](https://docs.astro.build/logos/kontent-ai.svg)
  ### Kontent.ai
- ![](https://docs.astro.build/logos/microcms.svg)
  ### microCMS
- ![](https://docs.astro.build/logos/optimizely.svg)
  ### Optimizely CMS
- ![](https://docs.astro.build/logos/payload.svg)
  ### Payload CMS
- ![](https://docs.astro.build/logos/preprcms.svg)
  ### Prepr CMS
- ![](https://docs.astro.build/logos/prismic.svg)
  ### Prismic
- ![](https://docs.astro.build/logos/sanity.svg)
  ### Sanity
- ![](https://docs.astro.build/logos/sitecore.svg)
  ### Sitecore XM
- ![](https://docs.astro.build/logos/sitepins.svg)
  ### Sitepins
- ![](https://docs.astro.build/logos/spinal.svg)
  ### Spinal
- ![](https://docs.astro.build/logos/statamic.svg)
  ### Statamic
- ![](https://docs.astro.build/logos/storyblok.svg)
  ### Storyblok
- ![](https://docs.astro.build/logos/strapi.svg)
  ### Strapi
- ![](https://docs.astro.build/logos/studiocms.svg)
  ### StudioCMS
- ![](https://docs.astro.build/logos/tina-cms.svg)
  ### Tina CMS
- ![](https://docs.astro.build/logos/umbraco.svg)
  ### Umbraco
- ![](https://docs.astro.build/logos/wordpress.svg)
  ### Wordpress

   Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Tina CMS & Astro

> Add content to your Astro project using Tina as a CMS

# Tina CMS & Astro

[Tina CMS](https://tina.io/) is a Git-backed headless content management system.

## Integrating with Astro

[Section titled “Integrating with Astro”](#integrating-with-astro)

To get started, you’ll need an existing Astro project.

1. Run the following command to install Tina into your Astro project.
  - [npm](#tab-panel-2801)
  - [pnpm](#tab-panel-2802)
  - [Yarn](#tab-panel-2803)
     Terminal window
  ```
  npx @tinacms/cli@latest init
  ```
     Terminal window
  ```
  pnpm dlx @tinacms/cli@latest init
  ```
     Terminal window
  ```
  yarn dlx @tinacms/cli@latest init
  ```
  - When prompted for a Cloud ID, press Enter to skip. You’ll generate one later if you want to use Tina Cloud.
  - When prompted “What framework are you using”, choose **Other**.
  - When asked where public assets are stored, press Enter.
  After this has finished, you should now have a `.tina` folder in the root of your project and a generated `hello-world.md` file at `content/posts`.
2. Change  the `dev` script in `package.json`:
  - [npm](#tab-panel-2804)
  - [pnpm](#tab-panel-2805)
  - [Yarn](#tab-panel-2806)
     package.json
  ```
  {    "scripts": {        "dev": "astro dev",        "dev": "tinacms dev -c \"astro dev\""    }}
  ```
     package.json
  ```
  {    "scripts": {        "dev": "astro dev",        "dev": "tinacms dev -c \"astro dev\""    }}
  ```
     package.json
  ```
  {    "scripts": {        "dev": "astro dev",        "dev": "tinacms dev -c \"astro dev\""    }}
  ```
3. TinaCMS is now set up in local mode. Test this by running the `dev` script, then navigating to `/admin/index.html#/collections/post`.
  Editing the “Hello, World!” post will update the `content/posts/hello-world.md` file in your project directory.
4. Set up your Tina collections by editing the `schema.collections` property in `.tina/config.ts`.
  For example, you can add a required “date posted” frontmatter property to our posts:
   .tina/config.ts
  ```
  import { defineConfig } from "tinacms";
  // Your hosting provider likely exposes this as an environment variableconst branch = process.env.HEAD || process.env.VERCEL_GIT_COMMIT_REF || "main";
  export default defineConfig({  branch,  clientId: null, // Get this from tina.io  token: null, // Get this from tina.io  build: {    outputFolder: "admin",    publicFolder: "public",  },  media: {    tina: {      mediaRoot: "images",      publicFolder: "public",    },  },  schema: {    collections: [      {        name: "posts",        label: "Posts",        path: "src/content/posts",        format: 'mdx',        fields: [          {            type: "string",            name: "title",            label: "Title",            isTitle: true,            required: true,          },          {            type: "datetime",            name: "posted",            label: "Date Posted",            required: true,          },          {            type: "rich-text",            name: "body",            label: "Body",            isBody: true,          },        ],      },    ],  },});
  ```
  Learn more about Tina collections [in the Tina docs](https://tina.io/docs/reference/collections/).
5. In production, TinaCMS can commit changes directly to your GitHub repository. To set up TinaCMS for production, you can choose to use [Tina Cloud](https://tina.io/docs/tina-cloud/) or self-host the [Tina Data Layer](https://tina.io/docs/self-hosted/overview/). You can [read more about registering for Tina Cloud](https://app.tina.io/register) in the Tina Docs.

## Official Resources

[Section titled “Official Resources”](#official-resources)

- [TinaCMS Astro integration guide](https://tina.io/docs/frameworks/astro/).

## Community Resources

[Section titled “Community Resources”](#community-resources)

- [Astro Tina Starter with visual editing](https://github.com/dawaltconley/tina-astro) by Jeff See + Dylan Awalt-Conley
- [Astro Tina Starter with basic editing](https://github.com/tombennet/astro-tina-starter/tree/main) by Tom Bennet
- [Using Astro’s Image Optimization with Tina](https://joschua.io/posts/2023/08/16/how-to-use-astro-assets-with-tina-cms/)

## Themes

[Section titled “Themes”](#themes)

- [Resume01](https://astro.build/themes/details/resume01/)
- [Qurno Blog](https://astro.build/themes/details/qurno-astro/)

## More CMS guides

- ![](https://docs.astro.build/logos/apostrophecms.svg)
  ### ApostropheCMS
- ![](https://docs.astro.build/logos/builderio.svg)
  ### Builder.io
- ![](https://docs.astro.build/logos/buttercms.svg)
  ### ButterCMS
- ![](https://docs.astro.build/logos/caisy.svg)
  ### Caisy
- ![](https://docs.astro.build/logos/cloudcannon.svg)
  ### CloudCannon
- ![](https://docs.astro.build/logos/contentful.svg)
  ### Contentful
- ![](https://docs.astro.build/logos/cosmic.svg)
  ### Cosmic
- ![](https://docs.astro.build/logos/craft-cms.svg)
  ### Craft CMS
- ![](https://docs.astro.build/logos/craft-cross-cms.svg)
  ### Craft Cross CMS
- ![](https://docs.astro.build/logos/crystallize.svg)
  ### Crystallize
- ![](https://docs.astro.build/logos/datocms.svg)
  ### DatoCMS
- ![](https://docs.astro.build/logos/decap-cms.svg)
  ### Decap CMS
- ![](https://docs.astro.build/logos/directus.svg)
  ### Directus
- ![](https://docs.astro.build/logos/drupal.svg)
  ### Drupal
- ![](https://docs.astro.build/logos/flotiq.svg)
  ### Flotiq
- ![](https://docs.astro.build/logos/frontmatter-cms.svg)
  ### Front Matter CMS
- ![](https://docs.astro.build/logos/ghost.png)
  ### Ghost
- ![](https://docs.astro.build/logos/gitcms.svg)
  ### GitCMS
- ![](https://docs.astro.build/logos/hashnode.png)
  ### Hashnode
- ![](https://docs.astro.build/logos/hygraph.svg)
  ### Hygraph
- ![](https://docs.astro.build/logos/jekyllpad.svg)
  ### JekyllPad
- ![](https://docs.astro.build/logos/keystatic.svg)
  ### Keystatic
- ![](https://docs.astro.build/logos/keystonejs.svg)
  ### KeystoneJS
- ![](https://docs.astro.build/logos/kontent-ai.svg)
  ### Kontent.ai
- ![](https://docs.astro.build/logos/microcms.svg)
  ### microCMS
- ![](https://docs.astro.build/logos/optimizely.svg)
  ### Optimizely CMS
- ![](https://docs.astro.build/logos/payload.svg)
  ### Payload CMS
- ![](https://docs.astro.build/logos/preprcms.svg)
  ### Prepr CMS
- ![](https://docs.astro.build/logos/prismic.svg)
  ### Prismic
- ![](https://docs.astro.build/logos/sanity.svg)
  ### Sanity
- ![](https://docs.astro.build/logos/sitecore.svg)
  ### Sitecore XM
- ![](https://docs.astro.build/logos/sitepins.svg)
  ### Sitepins
- ![](https://docs.astro.build/logos/spinal.svg)
  ### Spinal
- ![](https://docs.astro.build/logos/statamic.svg)
  ### Statamic
- ![](https://docs.astro.build/logos/storyblok.svg)
  ### Storyblok
- ![](https://docs.astro.build/logos/strapi.svg)
  ### Strapi
- ![](https://docs.astro.build/logos/studiocms.svg)
  ### StudioCMS
- ![](https://docs.astro.build/logos/tina-cms.svg)
  ### Tina CMS
- ![](https://docs.astro.build/logos/umbraco.svg)
  ### Umbraco
- ![](https://docs.astro.build/logos/wordpress.svg)
  ### Wordpress

   Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
