# TypeScript and more

# TypeScript

> Learn how to use Astro's built-in TypeScript support.

# TypeScript

Astro ships with built-in support for [TypeScript](https://www.typescriptlang.org/). You can import `.ts` and `.tsx` files in your Astro project, write TypeScript code directly inside your [Astro component](https://docs.astro.build/en/basics/astro-components/#the-component-script), and even use an [astro.config.ts](https://docs.astro.build/en/guides/configuring-astro/#the-astro-config-file) file for your Astro configuration if you like.

Using TypeScript, you can prevent errors at runtime by defining the shapes of objects and components in your code. For example, if you use TypeScript to [type your component‚Äôs props](#component-props), you‚Äôll get an error in your editor if you set a prop that your component doesn‚Äôt accept.

You don‚Äôt need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the [Astro VS Code Extension](https://docs.astro.build/en/editor-setup/) will infer as much as it can to provide autocompletion, hints, and errors in your editor.

The Astro dev server won‚Äôt perform any type checking, but you can use a [separate script](#type-checking) to check for type errors from the command line.

## Setup

[Section titled ‚ÄúSetup‚Äù](#setup)

Astro starter projects include a `tsconfig.json` file in your project. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a `tsconfig.json` file. If you install Astro manually, be sure to create this file yourself.

### TSConfig templates

[Section titled ‚ÄúTSConfig templates‚Äù](#tsconfig-templates)

Three extensible `tsconfig.json` templates are included in Astro: `base`, `strict`, and `strictest`. The `base` template enables support for modern JavaScript features and is also used as a basis for the other templates. We recommend using `strict` or `strictest` if you plan to write TypeScript in your project. You can view and compare the three template configurations at [astro/tsconfigs/](https://github.com/withastro/astro/blob/main/packages/astro/tsconfigs/).

To inherit from one of the templates, use [theextendssetting](https://www.typescriptlang.org/tsconfig#extends):

 tsconfig.json

```
{  "extends": "astro/tsconfigs/base"}
```

Additionally, we recommend setting `include` and `exclude` as follows to benefit from Astro types and avoid checking built files:

 tsconfig.json

```
{  "extends": "astro/tsconfigs/base",  "include": [".astro/types.d.ts", "**/*"],  "exclude": ["dist"]}
```

### TypeScript editor plugin

[Section titled ‚ÄúTypeScript editor plugin‚Äù](#typescript-editor-plugin)

The [Astro TypeScript plugin](https://www.npmjs.com/package/@astrojs/ts-plugin) can be installed separately when you are not using the [official Astro VS Code extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode). This plugin is automatically installed and configured by the VS Code extension, and you do not need to install both.

This plugin runs only in the editor. When running `tsc` in the terminal, `.astro` files are ignored entirely. Instead, you can use [theastro checkCLI command](https://docs.astro.build/en/reference/cli-reference/#astro-check) to check both `.astro` and `.ts` files.

This plugin also supports importing `.astro` files from `.ts` files (which can be useful for re-exporting).

- [npm](#tab-panel-1860)
- [pnpm](#tab-panel-1861)
- [Yarn](#tab-panel-1862)

   Terminal window

```
npm install @astrojs/ts-plugin
```

   Terminal window

```
pnpm add @astrojs/ts-plugin
```

   Terminal window

```
yarn add @astrojs/ts-plugin
```

Then, add the following to your `tsconfig.json`:

 tsconfig.json

```
{  "compilerOptions": {    "plugins": [      {        "name": "@astrojs/ts-plugin"      },    ],  }}
```

To check that the plugin is working, create a `.ts` file and import an Astro component into it. You should have no warning messages from your editor.

### UI Frameworks

[Section titled ‚ÄúUI Frameworks‚Äù](#ui-frameworks)

If your project uses a [UI framework](https://docs.astro.build/en/guides/framework-components/), additional settings depending on the framework might be needed. Please see your framework‚Äôs TypeScript documentation for more information. ([Vue](https://vuejs.org/guide/typescript/overview.html#using-vue-with-typescript), [React](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup), [Preact](https://preactjs.com/guide/v10/typescript), [Solid](https://www.solidjs.com/guides/typescript), [Svelte](https://svelte.dev/docs/svelte/typescript))

## Type Imports

[Section titled ‚ÄúType Imports‚Äù](#type-imports)

Use explicit type imports and exports whenever possible.

```
import { SomeType } from "./script";import type { SomeType } from "./script";
```

This way, you avoid edge cases where Astro‚Äôs bundler may try to incorrectly bundle your imported types as if they were JavaScript.

You can configure TypeScript to enforce type imports in your `tsconfig.json` file. Set [verbatimModuleSyntax](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax) to `true`. TypeScript will check your imports and tell you when `import type` should be used. This setting is enabled by default in all our presets.

 tsconfig.json

```
{  "compilerOptions": {    "verbatimModuleSyntax": true  }}
```

## Import Aliases

[Section titled ‚ÄúImport Aliases‚Äù](#import-aliases)

Astro supports import aliases that you define in your `tsconfig.json` `paths` configuration. [Read our imports guide](https://docs.astro.build/en/guides/imports/#aliases) to learn more.

 src/pages/about/nate.astro

```
---import HelloWorld from "@components/HelloWorld.astro";import Layout from "@layouts/Layout.astro";---
```

 tsconfig.json

```
{  "compilerOptions": {    "paths": {      "@components/*": ["./src/components/*"],      "@layouts/*": ["./src/layouts/*"]    }  }}
```

## Extending global types

[Section titled ‚ÄúExtending global types‚Äù](#extending-global-types)

You can create `src/env.d.ts` as a convention for adding custom types declarations, or to benefit from Astro types if you don‚Äôt have a `tsconfig.json`:

 src/env.d.ts

```
// Custom types declarationsdeclare var myString: string;
// Astro types, not necessary if you already have a `tsconfig.json`/// <reference path="../.astro/types.d.ts" />
```

### windowandglobalThis

[Section titled ‚Äúwindow and globalThis‚Äù](#window-and-globalthis)

You may want to add a property to the global object. You can do this by adding top-level declarations using the `declare` keyword to your `env.d.ts` file:

 src/env.d.ts

```
declare var myString: string;declare function myFunction(): boolean;
```

This will provide typing to `globalThis.myString` and `globalThis.myFunction`, as well as `window.myString` and `window.myFunction`.

Note that `window` is only available in client-side code. `globalThis` is available both server-side and client-side, but its server-side value won‚Äôt be shared with the client.

If you only want to type a property on the `window` object, provide a `Window` interface instead:

 src/env.d.ts

```
interface Window {  myFunction(): boolean;}
```

### Add non-standard attributes

[Section titled ‚ÄúAdd non-standard attributes‚Äù](#add-non-standard-attributes)

You may want to define a type for custom attributes or CSS properties. You can extend the default JSX definitions to add non-standard attributes by redeclaring the `astroHTML.JSX` namespace in a `.d.ts` file.

 src/env.d.ts

```
declare namespace astroHTML.JSX {  interface HTMLAttributes {    "data-count"?: number;    "data-label"?: string;  }
  // Add a CSS custom property to the style object  interface CSSProperties {    "--theme-color"?: "black" | "white";  }}
```

### Using imports

[Section titled ‚ÄúUsing imports‚Äù](#using-imports)

You may want to extend global types by reusing types declared elsewhere in your project or from an external library. To do this, use [dynamic imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import):

 src/env.d.ts

```
type Product = {  id: string;  name: string;  price: number;};
declare namespace App {  interface Locals {    orders: Map<string, Product[]>    session: import("./lib/server/session").Session | null;    user: import("my-external-library").User;  }}
```

A `.d.ts` file is an [ambient module](https://www.typescriptlang.org/docs/handbook/modules/reference.html#ambient-modules) declaration. While its syntax is similar to ES modules, these files do not allow top-level imports/exports. If Typescript encounters one, the file will be considered a [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) and this will break your global types.

## Component Props

[Section titled ‚ÄúComponent Props‚Äù](#component-props)

Astro supports typing your component props via TypeScript. To enable, add a TypeScript `Props` interface to your component frontmatter. An `export` statement may be used, but is not necessary. The [Astro VS Code Extension](https://docs.astro.build/en/editor-setup/) will automatically look for the `Props` interface and give you proper TS support when you use that component inside another template.

 src/components/HelloProps.astro

```
---interface Props {  name: string;  greeting?: string;}
const { greeting = "Hello", name } = Astro.props;---<h2>{greeting}, {name}!</h2>
```

### Common prop type patterns

[Section titled ‚ÄúCommon prop type patterns‚Äù](#common-prop-type-patterns)

- If your component takes no props or slotted content, you can use `type Props = Record<string, never>`.
- If your component must be passed children to its default slot, you can enforce this by using `type Props = { children: any; };`.

## Type Utilities

[Section titled ‚ÄúType Utilities‚Äù](#type-utilities)

**Added in:** `astro@1.6.0`

Astro comes with some built-in utility types for common prop type patterns. These are available under the `astro/types` entrypoint.

### Built-in HTML attributes

[Section titled ‚ÄúBuilt-in HTML attributes‚Äù](#built-in-html-attributes)

Astro provides the `HTMLAttributes` type to check that your markup is using valid HTML attributes. You can use these types to help build component props.

For example, if you were building a `<Link>` component, you could do the following to mirror the default HTML attributes for `<a>` tags in your component‚Äôs prop types.

 src/components/Link.astro

```
---import type { HTMLAttributes } from "astro/types";
// use a `type`type Props = HTMLAttributes<"a">;
// or extend with an `interface`interface Props extends HTMLAttributes<"a"> {  myProp?: boolean;}
const { href, ...attrs } = Astro.props;---<a href={href} {...attrs}>  <slot /></a>
```

### ComponentPropstype

[Section titled ‚ÄúComponentProps type‚Äù](#componentprops-type)

**Added in:** `astro@4.3.0`

This type export allows you to reference the `Props` accepted by another component, even if that component doesn‚Äôt export that `Props` type directly.

The following example shows using the `ComponentProps` utility from `astro/types` to reference a `<Button />` component‚Äôs `Props` types:

 src/pages/index.astro

```
---import type { ComponentProps } from "astro/types";import Button from "./Button.astro";
type ButtonProps = ComponentProps<typeof Button>;---
```

### Polymorphic type

[Section titled ‚ÄúPolymorphic type‚Äù](#polymorphic-type)

**Added in:** `astro@2.5.0`

Astro includes a helper to make it easier to build components that can render as different HTML elements with full type safety. This is useful for components like `<Link>` that can render as either `<a>` or `<button>` depending on the props passed to it.

The example below implements a fully-typed, polymorphic component that can render as any HTML element. The [HTMLTag](#built-in-html-attributes) type is used to ensure that the `as` prop is a valid HTML element.

```
---import type { HTMLTag, Polymorphic } from "astro/types";
type Props<Tag extends HTMLTag> = Polymorphic<{ as: Tag }>;
const { as: Tag, ...props } = Astro.props;---<Tag {...props} />
```

### InfergetStaticPaths()types

[Section titled ‚ÄúInfer getStaticPaths() types‚Äù](#infer-getstaticpaths-types)

**Added in:** `astro@2.1.0`

Astro includes helpers for working with the types returned by your [getStaticPaths()](https://docs.astro.build/en/reference/routing-reference/#getstaticpaths) function for dynamic routes.

You can get the type of [Astro.params](https://docs.astro.build/en/reference/api-reference/#params) with `InferGetStaticParamsType` and the type of [Astro.props](https://docs.astro.build/en/reference/api-reference/#props) with `InferGetStaticPropsType` or you can use `GetStaticPaths` to infer both at once:

 src/pages/posts/[...id].astro

```
---import type {  InferGetStaticParamsType,  InferGetStaticPropsType,  GetStaticPaths,} from "astro";
export const getStaticPaths = (async () => {  const posts = await getCollection("blog");  return posts.map((post) => {    return {      params: { id: post.id },      props: { draft: post.data.draft, title: post.data.title },    };  });}) satisfies GetStaticPaths;
type Params = InferGetStaticParamsType<typeof getStaticPaths>;type Props = InferGetStaticPropsType<typeof getStaticPaths>;
const { id } = Astro.params as Params;//                   ^? { id: string; }
const { title } = Astro.props;//                      ^? { draft: boolean; title: string; }---
```

## Type checking

[Section titled ‚ÄúType checking‚Äù](#type-checking)

To see type errors in your editor, please make sure that you have the [Astro VS Code extension](https://docs.astro.build/en/editor-setup/) installed. Please note that the `astro start` and `astro build` commands will transpile the code with esbuild, but will not run any type checking. To prevent your code from building if it contains TypeScript errors, change your ‚Äúbuild‚Äù script in `package.json` to the following:

 package.json

```
{  "scripts": {    "build": "astro build",    "build": "astro check && astro build",  },}
```

    Read more about [.tsfile imports](https://docs.astro.build/en/guides/imports/#typescript) in Astro.    Read more about [TypeScript Configuration](https://www.typescriptlang.org/tsconfig/).

## Troubleshooting

[Section titled ‚ÄúTroubleshooting‚Äù](#troubleshooting)

### Errors typing multiple JSX frameworks at the same time

[Section titled ‚ÄúErrors typing multiple JSX frameworks at the same time‚Äù](#errors-typing-multiple-jsx-frameworks-at-the-same-time)

An issue may arise when using multiple JSX frameworks in the same project, as each framework requires different, sometimes conflicting, settings inside `tsconfig.json`.

**Solution**: Set the [jsxImportSourcesetting](https://www.typescriptlang.org/tsconfig#jsxImportSource) to `react` (default), `preact` or `solid-js` depending on your most-used framework. Then, use a [pragma comment](https://www.typescriptlang.org/docs/handbook/jsx.html#configuring-jsx) inside any conflicting file from a different framework.

For the default setting of `jsxImportSource: react`, you would use:

```
// For Preact/** @jsxImportSource preact */
// For Solid/** @jsxImportSource solid-js */
```

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Legacy v0.x Upgrade Guide

> Archived guide documenting changes between pre-v1 versions of Astro

# Legacy v0.x Upgrade Guide

This guide will help you upgrade through breaking changes in pre-v1 versions of Astro.

You can update your project‚Äôs version of Astro to the latest version using your package manager. If you‚Äôre using Astro integrations, you‚Äôll also want to update those to the latest version.

- [npm](#tab-panel-3076)
- [pnpm](#tab-panel-3077)
- [Yarn](#tab-panel-3078)

   Terminal window

```
# updates the astro dependency:npm upgrade astro# or, to update all dependencies:npm upgrade
```

   Terminal window

```
# updates the astro dependency:pnpm upgrade astro# or, to update all dependencies:pnpm upgrade
```

   Terminal window

```
# updates the astro dependency:yarn upgrade astro# or, to update all dependencies:yarn upgrade
```

Read the guide below for major highlights and instructions on how to handle breaking changes.

## Astro 1.0

[Section titled ‚ÄúAstro 1.0‚Äù](#astro-10)

Astro v1.0 introduces some changes that you should be aware of when migrating from v0.x and v1.0-beta releases. See below for more details.

### Updated: Vite 3

[Section titled ‚ÄúUpdated: Vite 3‚Äù](#updated-vite-3)

Astro v1.0 has upgraded from Vite 2 to [Vite 3](https://vite.dev/). We‚Äôve handled most of the upgrade for you inside of Astro; however, some subtle Vite behaviors may still change between versions. Refer to the official [Vite Migration Guide](https://vite.dev/guide/migration.html#general-changes) if you run into trouble.

### Deprecated:Astro.canonicalURL

[Section titled ‚ÄúDeprecated: Astro.canonicalURL‚Äù](#deprecated-astrocanonicalurl)

You can now use the new [Astro.url](https://docs.astro.build/en/reference/api-reference/#url) helper to construct your own canonical URL from the current page/request URL.

```
// Before:const canonicalURL = Astro.canonicalURL;// After:const canonicalURL = new URL(Astro.url.pathname, Astro.site);
```

### Changed: Scoped CSS specificity

[Section titled ‚ÄúChanged: Scoped CSS specificity‚Äù](#changed-scoped-css-specificity)

[Specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity) will now be preserved in scoped CSS styles. This change will cause most scoped styles to *happen* to take precedence over global styles. But, this behavior is no longer explicitly guaranteed.

Technically, this is accomplished using [the:where()pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:where) instead of using classes directly in Astro‚Äôs CSS output.

Let‚Äôs use the following style block in an Astro component as an example:

```
<style>  div { color: red; } /* 0-0-1 specificity */</style>
```

Previously, Astro would transform this into the following CSS, which has a specificity of `0-1-1` ‚Äî a higher specificity than the source CSS:

```
div.astro-XXXXXX { color: red; } /* 0-1-1 specificity */
```

Now, Astro wraps the class selector with `:where()`, maintaining the authored specificity:

```
div:where(.astro-XXXXXX) { color: red; } /* 0-0-1 specificity */
```

The previous specificity increase made it hard to combine scoped styles in Astro with other CSS files or styling libraries (e.g. Tailwind, CSS Modules, Styled Components, Stitches). This change will allow Astro‚Äôs scoped styles to work consistently alongside them while still preserving the exclusive boundaries that prevent styles from applying outside the component.

### Deprecated: Components and JSX in Markdown

[Section titled ‚ÄúDeprecated: Components and JSX in Markdown‚Äù](#deprecated-components-and-jsx-in-markdown)

Astro no longer supports components or JSX expressions in Markdown pages by default. For long-term support you should migrate to the [@astrojs/mdx](https://docs.astro.build/en/guides/integrations-guide/mdx/) integration.

To make migrating easier, a new `legacy.astroFlavoredMarkdown` flag (removed in v2.0) can be used to re-enable previous Markdown features.

### Converting existing.mdfiles to.mdx

[Section titled ‚ÄúConverting existing .md files to .mdx‚Äù](#converting-existing-md-files-to-mdx)

If you‚Äôre not familiar with MDX, here are some steps you can follow to quickly convert an existing ‚ÄúAstro Flavored Markdown‚Äù file to MDX. As you learn more about MDX, feel free to explore other ways of writing your pages!

1. Install the [@astrojs/mdx](https://docs.astro.build/en/guides/integrations-guide/mdx/) integration.
2. Change your existing `.md` file extensions to `.mdx`
3. Remove any `setup:` properties from your frontmatter, and write any import statements below the frontmatter instead.
   src/pages/posts/my-post.mdx
  ```
  ---layout: '../../layouts/BaseLayout.astro'setup: |  import ReactCounter from '../../components/ReactCounter.jsx'title: 'Migrating to MDX'date: 2022-07-26tags: ["markdown", "mdx", "astro"]---import ReactCounter from '../../components/ReactCounter.jsx'
  # {frontmatter.title}
  Here is my counter component, working in MDX:
  <ReactCounter client:load />
  ```
4. Update any `Astro.glob()` statements that currently return `.md` files so that they will now return your `.mdx` files.
5. Update any use of the `<Content />` component to use the default export when importing MDX:
   src/pages/index.astro
  ```
  ---// Multiple imports with Astro.globconst mdxPosts = await Astro.glob('./posts/*.mdx');---
  {mdxPosts.map(Post => <Post.default />)}
  ```
   src/pages/index.astro
  ```
  ---// Import a single pageimport { default as About } from './about.mdx';---
  <About />
  ```

### <Markdown />Component Removed

[Section titled ‚Äú<Markdown /> Component Removed‚Äù](#markdown--component-removed)

Astro‚Äôs built-in `<Markdown />` component has been moved to a separate package. To continue using this component, you will now need to install `@astrojs/markdown-component` and update your imports accordingly. For more details, see [the@astrojs/markdownREADME](https://github.com/withastro/astro/tree/main/packages/markdown/component).

## Migrate to v1.0.0-beta

[Section titled ‚ÄúMigrate to v1.0.0-beta‚Äù](#migrate-to-v100-beta)

On April 4, 2022 we released the Astro 1.0 Beta! üéâ

If you are coming from v0.25 or earlier, make sure you have read and followed the [v0.26 Migration Guide](#migrate-to-v026) below, which contained several major breaking changes.

The `v1.0.0-beta.0` release of Astro contained no breaking changes. Below are small changes that were introduced during the beta period.

### Changed: RSS Feeds

[Section titled ‚ÄúChanged: RSS Feeds‚Äù](#changed-rss-feeds)

RSS feeds should now be generated using the `@astrojs/rss` package, as described in our [RSS guide](https://docs.astro.build/en/recipes/rss/).

## Migrate to v0.26

[Section titled ‚ÄúMigrate to v0.26‚Äù](#migrate-to-v026)

### New Configuration API

[Section titled ‚ÄúNew Configuration API‚Äù](#new-configuration-api)

Our Configuration API has been redesigned to solve a few glaring points of confusion that had built up over the last year. Most of the configuration options have just been moved or renamed, which will hopefully be a quick update for most users. A few options have been refactored more heavily, and may require a few additional changes:

- `.buildOptions.site` has been replaced with `.site` (your deployed domain) and a new `.base` (your deployed subpath) option.
- `.markdownOptions` has been replaced with `.markdown`, a mostly similar config object with some small changes to simplify Markdown configuration.
- `.sitemap` has been moved into the [@astrojs/sitemap](https://www.npmjs.com/package/@astrojs/sitemap) integration.

If you run Astro with legacy configuration, you will see a warning with instructions on how to update. See our updated [Configuration Reference](https://docs.astro.build/en/reference/configuration-reference/) for more information on upgrading.

Read [RFC0019](https://github.com/withastro/rfcs/blob/main/proposals/0019-config-finalization.md) for more background on these changes.

### New Markdown API

[Section titled ‚ÄúNew Markdown API‚Äù](#new-markdown-api)

Astro v0.26 releases a brand new Markdown API for your content. This included three major user-facing changes:

- You can now `import`/`import()` markdown content directly using an ESM import.
- A new `Astro.glob()` API, for easier glob imports (especially for Markdown).
- **BREAKING CHANGE:** `Astro.fetchContent()` has been removed and replaced by `Astro.glob()`
- **BREAKING CHANGE:** Markdown objects have an updated interface.

```
// v0.25let allPosts = Astro.fetchContent('./posts/*.md');// v0.26+let allPosts = await Astro.glob('./posts/*.md');
```

When migrating, be careful about the new Markdown object interface. Frontmatter, for example, has been moved to the `.frontmatter` property, so references like `post.title` should change to `post.frontmatter.title`.

This should solve many issues for Markdown users, including some nice performance boosts for larger sites.

Read [RFC0017](https://github.com/withastro/rfcs/blob/main/proposals/0017-markdown-content-redesign.md) for more background on these changes.

### New Default Script Behavior

[Section titled ‚ÄúNew Default Script Behavior‚Äù](#new-default-script-behavior)

`<script>` tags in Astro components are now built, bundled and optimized by default. This completes a long-term move to make our Astro component syntax more consistent, matching the default-optimized behavior our `<style>` tags have today.

This includes a few changes to be aware of:

- **BREAKING:** `<script hoist>` is the new default `<script>` behavior. The `hoist` attribute has been removed. To use the new default behaviour, make sure there are no other attributes on the `<script>` tag. For example, remove `type="module"` if you were using it before.
- New `<script is:inline>` directive, to revert a `<script>` tag to previous default behavior (unbuilt, unbundled, untouched by Astro).
- New `<style is:inline>` directive, to leave a style tag inline in the page template (similar to previous `<script>` behavior).
- New `<style is:global>` directive to replace `<style global>` in a future release.

```
// v0.25<script hoist type="module">// v0.26+<script>
```

See how to use [client-side scripts](https://docs.astro.build/en/guides/client-side-scripts/) in Astro for full details.

Read [RFC0016](https://github.com/withastro/rfcs/blob/main/proposals/0016-style-script-defaults.md) for more background on these changes.

### UpdatedAstro.requestAPI

[Section titled ‚ÄúUpdated Astro.request API‚Äù](#updated-astrorequest-api)

`Astro.request` has been changed from our custom object to a standard `Request` object. This is part of a project to use more web standard APIs, especially where SSR is concerned.

This includes a few changes to be aware of:

- Change `Astro.request` to become a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object.
- Move `Astro.request.params` to `Astro.params`.
- Move `Astro.request.canonicalURL` to `Astro.canonicalURL`.

Read [RFC0018](https://github.com/withastro/rfcs/blob/main/proposals/0018-astro-request.md) for more background on these changes.

### Other Changes

[Section titled ‚ÄúOther Changes‚Äù](#other-changes)

- Improve `Astro.slots` API to support passing arguments to function-based slots. This allows for more ergonomic utility components that accept a callback function as a child.
- Update CLI output formatting, especially around error reporting.
- Update `@astrojs/compiler`, fixing some bugs related to RegExp usage in frontmatter

## Migrate to v0.25

[Section titled ‚ÄúMigrate to v0.25‚Äù](#migrate-to-v025)

### Astro Integrations

[Section titled ‚ÄúAstro Integrations‚Äù](#astro-integrations)

The `renderers` config has been replaced by a new, official integration system! This unlocks some really exciting new features for Astro. You can read our [Using Integrations](https://docs.astro.build/en/guides/integrations-guide/) guide for more details on how to use this new system.

Integrations replace our original `renderers` concept, and come with a few breaking changes and new defaults for existing users. These changes are covered below.

#### Removed: Built-in Framework Support

[Section titled ‚ÄúRemoved: Built-in Framework Support‚Äù](#removed-built-in-framework-support)

Previously, React, Preact, Svelte, and Vue were all included with Astro by default. Starting in v0.25.0, Astro no longer comes with any built-in renderers. If you did not have a `renderers` configuration entry already defined for your project, you will now need to install those frameworks yourself.

Read our [step-by-step walkthrough](https://docs.astro.build/en/guides/integrations-guide/) to learn how to add a new Astro integration for the framework(s) that you currently use.

#### Deprecated: Renderers

[Section titled ‚ÄúDeprecated: Renderers‚Äù](#deprecated-renderers)

The new integration system replaces the previous `renderers` system, including the published `@astrojs/renderer-*` packages on npm. Going forward, `@astrojs/renderer-react` becomes `@astrojs/react`, `@astrojs/renderer-vue` becomes `@astrojs/vue`, and so on.

**To migrate:** update Astro to `v0.25.0` and then run `astro dev` or `astro build` with your old configuration file containing the outdated `"renderers"` config. You will immediately see a notice telling you the exact changes you need to make to your `astro.config.mjs` file, based on your current config. You can also update your packages yourself, using the table below.

For a deeper walkthrough, read our [step-by-step guide](https://docs.astro.build/en/guides/integrations-guide/) to learn how to replace existing renderers with a new Astro framework integration.

 Terminal window

```
# Install your new integrations and frameworks:# (Read the full walkthrough: https://docs.astro.build/en/guides/integrations-guide)npm install @astrojs/lit litnpm install @astrojs/react react react-dom
```

```
// Then, update your `astro.config.mjs` file:// (Read the full walkthrough: https://docs.astro.build/en/guides/integrations-guide)import lit from '@astrojs/lit';import react from '@astrojs/react';
export default {  renderers: ['@astrojs/renderer-lit', '@astrojs/renderer-react'],  integrations: [lit(), react()],}
```

| Deprecated Renderers on npm | v0.25+ Integrations on npm |
| --- | --- |
| @astrojs/renderer-react | @astrojs/react |
| @astrojs/renderer-preact | @astrojs/preact |
| @astrojs/renderer-solid | @astrojs/solid-js |
| @astrojs/renderer-vue | @astrojs/vue |
| @astrojs/renderer-svelte | @astrojs/svelte |

#### Handling Peer Dependencies

[Section titled ‚ÄúHandling Peer Dependencies‚Äù](#handling-peer-dependencies)

Unlike the old renderers, integrations no longer mark the frameworks themselves (‚Äúreact‚Äù, ‚Äúsvelte‚Äù, ‚Äúvue‚Äù, etc.) as direct dependencies of the integration. Instead, you should now install your framework packages *in addition to* your integrations.

 Terminal window

```
# Example: Install integrations and frameworks togethernpm install @astrojs/react react react-dom
```

If you see a `"Cannot find package 'react'"` (or similar) warning when you start up Astro,¬†that means that you need to install that package into your project. See our [note on peer dependencies](https://docs.astro.build/en/guides/troubleshooting/#cannot-find-package-x) in the troubleshooting guide for more information.

If you are using `npm` & Node v16+, then this may be automatically handled for you by `npm`, since the latest version of `npm` (v7+) installs peer dependencies like this for you automatically. In that case, installing a framework like ‚Äúreact‚Äù into your project is an optional but still recommended step.

### Updated: Syntax Highlighting

[Section titled ‚ÄúUpdated: Syntax Highlighting‚Äù](#updated-syntax-highlighting)

We love to find sensible defaults that ‚Äújust work‚Äù out-of-the-box. As part of this, we decided to make [Shiki](https://github.com/shikijs/shiki) our new default syntax highlighter. This comes pre-configured with the `github-dark` theme, providing zero-config highlighting in your code blocks without extraneous CSS classes, stylesheets, or client-side JS.

Check our new syntax highlighting docs for full details. **If you prefer to keep Prism as your syntax highlighter,** set the `syntaxHighlight` option to `'prism'` in your project‚Äôs markdown configuration.

#### The<Prism />component has a new home

[Section titled ‚ÄúThe <Prism /> component has a new home‚Äù](#the-prism--component-has-a-new-home)

As part of our mission to keep Astro core as lean as possible, we‚Äôve moved the built-in `Prism` component out of `astro/components` and into the `@astrojs/prism` package. You can now import this component from `@astrojs/prism` like so:

```
---import { Prism } from '@astrojs/prism';---
```

Since the `@astrojs/prism` package is still bundled with `astro` core, you won‚Äôt need to install anything new, nor add Prism as an integration! However, note that we *do* plan to extract `@astrojs/prism` (and Prism syntax highlighting in general) to a separate, installable package in the future. See the `<Prism />` component API reference for more details.

### CSS Parser Upgrade

[Section titled ‚ÄúCSS Parser Upgrade‚Äù](#css-parser-upgrade)

Our internal CSS parser has been updated, and comes with better support for advanced CSS syntax, like container queries. This should be a mostly invisible change for most users, but hopefully advanced users will enjoy the new CSS feature support.

## Migrate to v0.24

[Section titled ‚ÄúMigrate to v0.24‚Äù](#migrate-to-v024)

0.24 introduced a new *static build* strategy that changes the behavior of a few features. In previous versions of Astro this was available behavior with an opt-in flag: `--experimental-static-build`.

To migrate for the transition, be aware of the following changes that will be required to move to this new build engine. You can make these changes to your codebase at any time so that you are ready ahead of schedule.

### Deprecated:Astro.resolve()

[Section titled ‚ÄúDeprecated: Astro.resolve()‚Äù](#deprecated-astroresolve)

`Astro.resolve()` allows you to get resolved URLs to assets that you might want to reference in the browser. This was most commonly used inside of  `<link>` and `<img>` tags to load CSS files and images as needed. Unfortunately, this will no longer work due to Astro now building assets at *build time* rather than at *render time*. You‚Äôll want to upgrade your asset references to one of the following future-proof options available going forward:

#### How to Resolve CSS Files

[Section titled ‚ÄúHow to Resolve CSS Files‚Äù](#how-to-resolve-css-files)

**1. ESM Import (Recommended)**

**Example:** `import './style.css';` **When to use this:** If your CSS file lives inside of the `src/` directory, and you want automatic CSS build and optimization features.

Use an ESM import to add some CSS¬†onto the page. Astro detects these CSS imports and then builds, optimizes, and adds the CSS to the page automatically. This is the easiest way to migrate from `Astro.resolve()` while keeping the automatic building/bundling that Astro provides.

```
---// Example: Astro will include and optimize this CSS for you automaticallyimport './style.css';---<html></html>
```

Importing CSS files should work anywhere that ESM imports are supported, including:

- JavaScript files
- TypeScript files
- Astro component frontmatter
- non-Astro components like React, Svelte, and others

When a CSS file is imported using this method, any `@import` statements are also resolved and inlined into the imported CSS file. All `url()` references are also resolved relative to the source file, and any `url()` referenced assets will be included in the final build.

**2. Absolute URL Path**

**Example:** `<link href="/style.css">` **When to use this:** If your CSS file lives inside of `public/`, and you prefer to create your HTML `link` element yourself.

You can reference any file inside of the `public/` directory by absolute URL path in your component template. This is a good option if you want to control the `<link>` tag¬†on the page yourself. However, this approach also skips the CSS processing, bundling and optimizations that are provided by Astro when you use the `import` method described above.

We recommend using the `import` approach over the absolute URL approach since it provides the best possible CSS performance and features by default.

#### How to Resolve JavaScript Files

[Section titled ‚ÄúHow to Resolve JavaScript Files‚Äù](#how-to-resolve-javascript-files)

**1. Absolute URL Path**

**Example:** `<script src="/some-external-script.js" />` **When to use this:** If your JavaScript file lives inside of `public/`.

You can reference any file inside of the `public/` directory by absolute URL path in your Astro component templates. This is a good default option for external scripts because it lets you control the `<script>` tag¬†on the page yourself.

Note that this approach skips the JavaScript processing, bundling and optimizations that are provided by Astro when you use the `import` method described below. However, this may be preferred for any external scripts that have already been published and minified separately from Astro. If your script was downloaded from an external source, then this method is probably preferred.

**2. ESM Import via<script hoist>**

**Example:** `<script hoist>import './some-external-script.js';</script>` **When to use this:** If your external script lives inside of `src/` *and* it supports the ESM module type.

Use an ESM import inside of a `<script hoist>` element in your Astro template, and Astro will include the JavaScript file in your final build. Astro detects these JavaScript client-side imports and then builds, optimizes, and adds the JavaScript to the page automatically. This is the easiest way to migrate from `Astro.resolve()` while keeping the automatic building/bundling that Astro provides.

```
<script hoist>  import './some-external-script.js';</script>
```

Note that Astro will bundle this external script with the rest of your client-side JavaScript, and load it in the `type="module"` script context. Some older JavaScript files may not be written for the `module` context, in which case they may need to be updated to use this method.

#### How to Resolve Images & Other Assets

[Section titled ‚ÄúHow to Resolve Images & Other Assets‚Äù](#how-to-resolve-images--other-assets)

**1. Absolute URL Path (Recommended)**

**Example:** `<img src="/penguin.png">` **When to use this:** If your asset lives inside of `public/`.

If you place your images inside of `public/` you can safely reference them by absolute URL path directly in your component templates. This is the simplest way to reference an asset that you can use today, and it is recommended for most users who are getting started with Astro.

**2. ESM Import**

**Example:** `import imgUrl from './penguin.png'` **When to use this:** If your asset lives inside of the `src/` directory, and you want automatic optimization features like filename hashing.

This works inside of any JavaScript or Astro component, and returns a resolved URL to the final image. Once you have the resolved URL, you can use it anywhere inside of the component template.

```
---// Example: Astro will include this image file in your final buildimport imgUrl from './penguin.png';---<img src={imgUrl} />
```

Similar to how Astro handles CSS, the ESM import allows Astro to perform some simple build optimizations for you automatically. For example, any asset inside of `src/` that is imported using an ESM import (ex: `import imgUrl from './penguin.png'`) will have its filename hashed automatically. This can let you cache the file more aggressively on the server, improving user performance. In the future, Astro may add more optimizations like this.

**Tip:** If you dislike static ESM imports, Astro also supports dynamic ESM imports. We only recommend this option if you prefer this syntax: `<img src={(await import('./penguin.png')).default} />`.

### Deprecated:<script>Default Processing

[Section titled ‚ÄúDeprecated: <script> Default Processing‚Äù](#deprecated-script-default-processing)

Previously, all `<script>` elements were read from the final HTML output and processed + bundled automatically. This behavior is no longer the default. Starting in 0.24, you must opt-in to `<script>` element processing via the `hoist` attribute. The `type="module"` is also required for hoisted modules.

```
<script>  // Will be rendered into the HTML exactly as written!  // ESM imports will not be resolved relative to the file.</script><script type="module" hoist>  // Processed! Bundled! ESM imports work, even to npm packages.</script>
```

## Migrate to v0.23

[Section titled ‚ÄúMigrate to v0.23‚Äù](#migrate-to-v023)

### Missing Sass Error

[Section titled ‚ÄúMissing Sass Error‚Äù](#missing-sass-error)

```
Preprocessor dependency "sass" not found. Did you install it?
```

In our quest to reduce npm install size, we‚Äôve moved [Sass](https://sass-lang.com/) out to an optional dependency. If you use Sass in your project, you‚Äôll want to make sure that you run `npm install sass --save-dev` to save it as a dependency.

### Deprecated: Unescaped HTML

[Section titled ‚ÄúDeprecated: Unescaped HTML‚Äù](#deprecated-unescaped-html)

In Astro v0.23+, unescaped HTML content in expressions is now deprecated.
In future releases, content within expressions will have strings escaped to protect against unintended HTML injection.

```
<h1>{title}</h1> <h1>{title}</h1> 
```

To continue injecting unescaped HTML, you can now use `set:html`.

```
<h1>{title}</h1><h1 set:html={title} />
```

To avoid a wrapper element, `set:html` can work alongside `<Fragment>`.

```
<h1>{title}!</h1><h1><Fragment set:html={title}>!</h1>
```

You can also protect against unintended HTML injection with `set:text`.

```
<h1 set:text={title} /> 
```

## Migrate to v0.21

[Section titled ‚ÄúMigrate to v0.21‚Äù](#migrate-to-v021)

### Vite

[Section titled ‚ÄúVite‚Äù](#vite)

Starting in v0.21, Astro is built with [Vite](https://vite.dev).
As a result, configurations written in `snowpack.config.mjs` should be moved into `astro.config.mjs`.

```
// @ts-check
/** @type {import('astro').AstroUserConfig} */export default {  renderers: [],  vite: {    plugins: [],  },};
```

To learn more about configuring Vite, please visit their [configuration guide](https://vite.dev/config/).

#### Vite Plugins

[Section titled ‚ÄúVite Plugins‚Äù](#vite-plugins)

In Astro v0.21+, Vite plugins may be configured within `astro.config.mjs`.

```
import { imagetools } from 'vite-imagetools';
export default {  vite: {    plugins: [imagetools()],  },};
```

To learn more about Vite plugins, please visit their [plugin guide](https://vite.dev/guide/using-plugins.html).

#### Vite Changes to Renderers

[Section titled ‚ÄúVite Changes to Renderers‚Äù](#vite-changes-to-renderers)

In Astro v0.21+, plugins should now use `viteConfig()`.

 renderer-svelte/index.js

```
import { svelte } from '@sveltejs/vite-plugin-svelte';
export default {  name: '@astrojs/renderer-svelte',  client: './client.js',  server: './server.js',  snowpackPlugin: '@snowpack/plugin-svelte',  snowpackPluginOptions: { compilerOptions: { hydratable: true } },  viteConfig() {    return {      optimizeDeps: {        include: ['@astrojs/renderer-svelte/client.js', 'svelte', 'svelte/internal'],        exclude: ['@astrojs/renderer-svelte/server.js'],      },      plugins: [        svelte({          emitCss: true,          compilerOptions: { hydratable: true },        }),      ],    };  },}
```

To learn more about Vite plugins, please visit their [plugin guide](https://vite.dev/guide/using-plugins.html).

### Aliasing

[Section titled ‚ÄúAliasing‚Äù](#aliasing)

In Astro v0.21+, import aliases can be added in `tsconfig.json`.

```
{  "compilerOptions": {    "baseUrl": ".",    "paths": {      "@/components/*": ["src/components/*"]    }  }}
```

### File Extensions in Imports

[Section titled ‚ÄúFile Extensions in Imports‚Äù](#file-extensions-in-imports)

In Astro v0.21+, files need to be referenced by their actual extension, exactly as it is on disk. In this example, `Div.tsx` would need to be referenced as `Div.tsx`, not `Div.jsx`.

```
import Div from './Div.jsx' // Astro v0.20import Div from './Div.tsx' // Astro v0.21
```

This same change applies to a compile-to-css file like `Div.scss`:

```
<link rel="stylesheet" href={Astro.resolve('./Div.css')}><link rel="stylesheet" href={Astro.resolve('./Div.scss')}>
```

### Removed: Components in Frontmatter

[Section titled ‚ÄúRemoved: Components in Frontmatter‚Äù](#removed-components-in-frontmatter)

Previously, you could create mini Astro Components inside of the Astro Frontmatter, using JSX syntax instead of Astro‚Äôs component syntax. This was always a bit of a hack, but in the new compiler it became impossible to support. We hope to re-introduce this feature in a future release of Astro using a different, non-JSX API.

To migrate to v0.21+, please convert all JSX Astro components (that is, any Astro components created inside of another component‚Äôs frontmatter) to standalone components.

### Styling Changes

[Section titled ‚ÄúStyling Changes‚Äù](#styling-changes)

#### Autoprefixer

[Section titled ‚ÄúAutoprefixer‚Äù](#autoprefixer)

Autoprefixer is no longer run by default. To enable:

1. Install the latest version (`npm install autoprefixer`)
2. Create a `postcss.config.cjs` file at the root of your project with:
  ```
  module.exports = {  plugins: {    autoprefixer: {},  },};
  ```

#### Tailwind CSS

[Section titled ‚ÄúTailwind CSS‚Äù](#tailwind-css)

Ensure you have PostCSS installed. This was optional in previous releases, but is required now:

1. Install the latest version of postcss (`npm install -D postcss`)
2. Create a `postcss.config.cjs` file at the root of your project with:
  ```
  module.exports = {  plugins: {    tailwindcss: {},  },};
  ```
  For more information, read the [Tailwind CSS documentation](https://tailwindcss.com/docs/installation#add-tailwind-as-a-post-css-plugin)

### Known Issues

[Section titled ‚ÄúKnown Issues‚Äù](#known-issues)

#### Imports on top

[Section titled ‚ÄúImports on top‚Äù](#imports-on-top)

In Astro v0.21+, a bug has been introduced that requires imports inside components to be at the top of your frontmatter.

```
---import Component from '../components/Component.astro'const whereShouldIPutMyImports = "on top!"---
```

 Upgrade Guides     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
