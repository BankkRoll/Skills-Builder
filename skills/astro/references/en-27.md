# Internationalization (i18n) Routing and more

# Internationalization (i18n) Routing

> Learn how to use Astro’s i18n routing features to localize your site’s pages.

# Internationalization (i18n) Routing

Astro’s internationalization (i18n) features allow you to adapt your project for an international audience. This routing API helps you generate, use, and verify the URLs that your multi-language site produces.

Astro’s i18n routing allows you to bring your multilingual content with support for configuring a default language, computing relative page URLs, and accepting preferred languages provided by your visitor’s browser. You can also specify fallback languages on a per-language basis so that your visitors can always be directed to existing content on your site.

## Routing Logic

[Section titled “Routing Logic”](#routing-logic)

Astro uses a [middleware](https://docs.astro.build/en/guides/middleware/) to implement its routing logic. This middleware function is placed in the [first position](https://docs.astro.build/en/guides/middleware/#chaining-middleware) where it awaits every `Response` coming from any additional middleware and each page route before finally executing its own logic.

This means that operations (e.g. redirects) from your own middleware and your page logic are run first, your routes are rendered, and then the i18n middleware performs its own actions such as verifying that a localized URL corresponds to a valid route.

You can also choose to [add your own i18n logic in addition to or instead of Astro’s i18n middleware](#manual), giving you even more control over your routes while still having access to the `astro:i18n` helper functions.

## Configure i18n routing

[Section titled “Configure i18n routing”](#configure-i18n-routing)

Both a list of all supported languages ([locales](https://docs.astro.build/en/reference/configuration-reference/#i18nlocales)) and a default language ([defaultLocale](https://docs.astro.build/en/reference/configuration-reference/#i18ndefaultlocale)), which must be one of the languages listed in `locales`, need to be specified in an `i18n` configuration object. Additionally, you can configure more specific routing and fallback behavior to match your desired URLs.

 astro.config.mjs

```
import { defineConfig } from "astro/config"export default defineConfig({  i18n: {    locales: ["es", "en", "pt-br"],    defaultLocale: "en",  }})
```

### Create localized folders

[Section titled “Create localized folders”](#create-localized-folders)

Organize your content folders with localized content by language. Create individual `/[locale]/` folders anywhere within `src/pages/` and Astro’s [file-based routing](https://docs.astro.build/en/guides/routing/) will create your pages at corresponding URL paths.

Your folder names must match the items in `locales` exactly. Include a localized folder for your `defaultLocale` only if you configure `prefixDefaultLocale: true` to show a localized URL path for your default language (e.g. `/en/about/`).

- Directorysrc
  - Directorypages
    - about.astro
    - index.astro
    - Directoryes
      - about.astro
      - index.astro
    - Directorypt-br
      - about.astro
      - index.astro

### Create links

[Section titled “Create links”](#create-links)

With i18n routing configured, you can now compute links to pages within your site using the helper functions such as [getRelativeLocaleUrl()](https://docs.astro.build/en/reference/modules/astro-i18n/#getrelativelocaleurl) available from the [astro:i18nmodule](https://docs.astro.build/en/reference/modules/astro-i18n/). These generated links will always provide the correct, localized route and can help you correctly use, or check, URLs on your site.

You can also still write the links manually.

 src/pages/es/index.astro

```
---import { getRelativeLocaleUrl } from 'astro:i18n';
// defaultLocale is "es"const aboutURL = getRelativeLocaleUrl("es", "about");---
<a href="/get-started/">¡Vamos!</a><a href={getRelativeLocaleUrl('es', 'blog')}>Blog</a><a href={aboutURL}>Acerca</a>
```

## routing

[Section titled “routing”](#routing)

Astro’s built-in file-based routing automatically creates URL routes for you based on your file structure within `src/pages/`.

When you configure i18n routing, information about this file structure (and the corresponding URL paths generated) is available to the i18n helper functions so they can generate, use, and verify the routes in your project. Many of these options can be used together for even more customization and per-language flexibility.

You can even choose to [implement your own routing logic manually](#manual) for even greater control.

### prefixDefaultLocale

[Section titled “prefixDefaultLocale”](#prefixdefaultlocale)

**Added in:** `astro@3.5.0`

This routing option defines whether or not your default language’s URLs should use a language prefix (e.g. `/en/about/`).

All non-default supported languages **will** use a localized prefix (e.g. `/fr/` or `/french/`) and content files must be located in appropriate folders. This configuration option allows you to specify whether your default language should also follow a localized URL structure.

This setting also determines where the page files for your default language must exist (e.g. `src/pages/about/` or `src/pages/en/about`) as the file structure and URL structure must match for all languages.

- `"prefixDefaultLocale: false"` (default): URLs in your default language will **not** have a `/[locale]/` prefix. All other locales will.
- `"prefixDefaultLocale: true"`: All URLs, including your default language, will have a `/[locale]/` prefix.

#### prefixDefaultLocale: false

[Section titled “prefixDefaultLocale: false”](#prefixdefaultlocale-false) astro.config.mjs

```
import { defineConfig } from "astro/config"export default defineConfig({  i18n: {    locales: ["es", "en", "fr"],    defaultLocale: "en",    routing: {        prefixDefaultLocale: false    }  }})
```

This is the **default** value. Set this option when URLs in your default language will **not** have a `/[locale]/` prefix and files in your default language exist at the root of `src/pages/`:

- Directorysrc
  - Directorypages
    - about.astro
    - index.astro
    - Directoryes
      - about.astro
      - index.astro
    - Directoryfr
      - about.astro
      - index.astro

- `src/pages/about.astro` will produce the route `example.com/about/`
- `src/pages/fr/about.astro` will produce the route `example.com/fr/about/`

#### prefixDefaultLocale: true

[Section titled “prefixDefaultLocale: true”](#prefixdefaultlocale-true) astro.config.mjs

```
import { defineConfig } from "astro/config"export default defineConfig({  i18n: {    locales: ["es", "en", "fr"],    defaultLocale: "en",    routing: {        prefixDefaultLocale: true    }  }})
```

Set this option when all routes will have their `/locale/` prefix in their URL and when all page content files, including those for your `defaultLocale`, exist in a localized folder:

- Directorysrc
  - Directorypages
    - **index.astro**  // Note: this file is always required
    - Directoryen
      - index.astro
      - about.astro
    - Directoryes
      - about.astro
      - index.astro
    - Directorypt-br
      - about.astro
      - index.astro

- URLs without a locale prefix, (e.g. `example.com/about/`) will return a 404 (not found) status code unless you specify a [fallback strategy](#fallback).

### redirectToDefaultLocale

[Section titled “redirectToDefaultLocale”](#redirecttodefaultlocale)

**Added in:** `astro@4.2.0`

Configures whether or not the home URL (`/`) generated by `src/pages/index.astro` will redirect to `/<defaultLocale>`.

Setting `prefixDefaultLocale: true` will also automatically set `redirectToDefaultLocale: true` in your `routing` config object. By default, the required `src/pages/index.astro` file will automatically redirect to the index page of your default locale.

You can opt out of this behavior by [settingredirectToDefaultLocale: false](https://docs.astro.build/en/reference/configuration-reference/#i18nroutingredirecttodefaultlocale). This allows you to have a site home page that exists outside of your configured locale folder structure.

### manual

[Section titled “manual”](#manual)

**Added in:** `astro@4.6.0`

When this option is enabled, Astro will **disable** its i18n middleware so that you can implement your own custom logic. No other `routing` options (e.g. `prefixDefaultLocale`) may be configured with `routing: "manual"`.

You will be responsible for writing your own routing logic, or [executing Astro’s i18n middleware manually](#middleware-function) alongside your own.

 astro.config.mjs

```
import { defineConfig } from "astro/config"export default defineConfig({  i18n: {    locales: ["es", "en", "fr"],    defaultLocale: "en",    routing: "manual"  }})
```

Astro provides helper functions for your middleware so you can control your own default routing, exceptions, fallback behavior, error catching, etc: [redirectToDefaultLocale()](https://docs.astro.build/en/reference/modules/astro-i18n/#redirecttodefaultlocale), [notFound()](https://docs.astro.build/en/reference/modules/astro-i18n/#notfound), and [redirectToFallback()](https://docs.astro.build/en/reference/modules/astro-i18n/#redirecttofallback):

 src/middleware.js

```
import { defineMiddleware } from "astro:middleware";import { redirectToDefaultLocale } from "astro:i18n"; // function available with `manual` routingexport const onRequest = defineMiddleware(async (ctx, next) => {  if (ctx.url.startsWith("/about")) {    return next();  } else {    return redirectToDefaultLocale(302);  }})
```

#### middleware function

[Section titled “middleware function”](#middleware-function)

The [middleware](#middleware-function) function manually creates Astro’s i18n middleware. This allows you to extend Astro’s i18n routing instead of completely replacing it.

You can run `middleware` with [routing options](#routing) in combination with your own middleware, using the [sequence](https://docs.astro.build/en/reference/modules/astro-middleware/#sequence) utility to determine the order:

 src/middleware.js

```
import {defineMiddleware, sequence} from "astro:middleware";import { middleware } from "astro:i18n"; // Astro's own i18n routing config
export const userMiddleware = defineMiddleware(async (ctx, next) => {  // this response might come from Astro's i18n middleware, and it might return a 404  const response = await next();  // the /about page is an exception and we want to render it  if (ctx.url.startsWith("/about")) {    return new Response("About page", {      status: 200    });  } else {    return response;  }});

export const onRequest = sequence(  userMiddleware,  middleware({    redirectToDefaultLocale: false,    prefixDefaultLocale: true  }))
```

## domains

[Section titled “domains”](#domains)

**Added in:** `astro@4.9.0`

This routing option allows you to customize your domains on a per-language basis for `server` rendered projects using the [@astrojs/node](https://docs.astro.build/en/guides/integrations-guide/node/) or [@astrojs/vercel](https://docs.astro.build/en/guides/integrations-guide/vercel/) adapter with a `site` configured.

Add `i18n.domains` to map any of your supported `locales` to custom URLs:

 astro.config.mjs

```
import { defineConfig } from "astro/config"export default defineConfig({  site: "https://example.com",  output: "server", // required, with no prerendered pages  adapter: node({    mode: 'standalone',  }),  i18n: {    locales: ["es", "en", "fr", "ja"],    defaultLocale: "en",    routing: {      prefixDefaultLocale: false    },    domains: {      fr: "https://fr.example.com",      es: "https://example.es"    }  }})
```

All non-mapped `locales` will follow your `prefixDefaultLocales` configuration.

With the above configuration:

- The file `/fr/about.astro` will create the URL `https://fr.example.com/about`.
- The file `/es/about.astro` will create the URL `https://example.es/about`.
- The file `/ja/about.astro` will create the URL `https://example.com/ja/about`.
- The file `/about.astro` will create the URL `https://example.com/about`.

The above URLs will also be returned by the `getAbsoluteLocaleUrl()` and `getAbsoluteLocaleUrlList()` functions.

## Fallback

[Section titled “Fallback”](#fallback)

When a page in one language doesn’t exist (e.g. a page that is not yet translated), instead of displaying a 404 page, you can choose to display fallback content from another `locale` on a per-language basis. This is useful when you do not yet have a page for every route, but you want to still provide some content to your visitors.

Your fallback strategy consists of two parts: choosing which languages should fallback to which other languages ([i18n.fallback](https://docs.astro.build/en/reference/configuration-reference/#i18nfallback)) and choosing whether to perform a [redirect](https://docs.astro.build/en/guides/routing/#redirects) or a [rewrite](https://docs.astro.build/en/guides/routing/#rewrites) to show the fallback content ([i18n.routing.fallbackType](https://docs.astro.build/en/reference/configuration-reference/#i18nroutingfallbacktype) added in Astro v4.15.0).

For example, when you configure `i18n.fallback: { fr: "es" }`, Astro will ensure that a page is built in `src/pages/fr/` for every page that exists in `src/pages/es/`.

If any page does not already exist, then a page will be created depending on your `fallbackType`:

- With a redirect to the corresponding `es` route (default behavior).
- With the content of the `/es/` page (`i18n.routing.fallbackType: "rewrite"`).

For example, the configuration below sets `es` as the fallback locale for any missing `fr` routes. This means that a user visiting `example.com/fr/my-page/` will be shown the content for `example.com/es/my-page/` (without being redirected) instead of being taken to a 404 page when `src/pages/fr/my-page.astro` does not exist.

 astro.config.mjs

```
import { defineConfig } from "astro/config"export default defineConfig({  i18n: {    locales: ["es", "en", "fr"],    defaultLocale: "en",    fallback: {      fr: "es"    },    routing: {      fallbackType: "rewrite"    }  }})
```

## Custom locale paths

[Section titled “Custom locale paths”](#custom-locale-paths)

In addition to defining your site’s supported `locales` as strings (e.g. “en”, “pt-br”), Astro also allows you to map an arbitrary number of [browser-recognized languagecodes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language#syntax) to a custom URL `path`. While locales can be strings of any format as long as they correspond to your project folder structure, `codes` must follow the browser’s accepted syntax.

Pass an object to the `locales` array with a `path` key to define a custom URL prefix, and `codes` to indicate the languages mapped to this URL. In this case, your `/[locale]/` folder name must match exactly the value of the `path` and your URLs will be generated using the `path` value.

This is useful if you support multiple variations of a language (e.g. `"fr"`, `"fr-BR"`, and `"fr-CA"`) and you want to have all these variations mapped under the same URL `/fr/`, or even customize it entirely (e.g. `/french/`):

 astro.config.mjs

```
import { defineConfig } from "astro/config"export default defineConfig({  i18n: {    locales: ["es", "en", "fr"],    locales: ["es", "en", {      path: "french", // no slashes included      codes: ["fr", "fr-BR", "fr-CA"]    }],    defaultLocale: "en",    routing: {        prefixDefaultLocale: true    }  }})
```

When using functions from the [astro:i18nvirtual module](https://docs.astro.build/en/reference/modules/astro-i18n/) to compute valid URL paths based on your configuration (e.g. `getRelativeLocaleUrl()`), [use thepathas the value forlocale](https://docs.astro.build/en/reference/modules/astro-i18n/#getlocalebypath).

#### Limitations

[Section titled “Limitations”](#limitations)

This feature has some restrictions:

- The `site` option is mandatory.
- The `output` option must be set to `"server"`.
- There cannot be any individual prerendered pages.

Astro relies on the following headers in order to support the feature:

- [X-Forwarded-Host](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) and [Host](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host). Astro will use the former, and if not present, will try the latter.
- [X-Forwarded-Proto](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto) and [URL#protocol](https://developer.mozilla.org/en-US/docs/Web/API/URL/protocol) of the server request.

Make sure that your server proxy/hosting platform is able to provide this information. Failing to retrieve these headers will result in a 404 (status code) page.

## Browser language detection

[Section titled “Browser language detection”](#browser-language-detection)

Astro’s i18n routing allows you to access two properties for browser language detection in pages rendered on demand: `Astro.preferredLocale` and `Astro.preferredLocaleList`. All pages, including static prerendered pages, have access to `Astro.currentLocale`.

These combine the browser’s `Accept-Language` header, and your `locales` (strings or `codes`) to automatically respect your visitor’s preferred languages.

- [Astro.preferredLocale](https://docs.astro.build/en/reference/api-reference/#preferredlocale):  Astro can compute a **preferred locale** for your visitor if their browser’s preferred locale is included in your `locales` array. This value is undefined if no such match exists.
- [Astro.preferredLocaleList](https://docs.astro.build/en/reference/api-reference/#preferredlocalelist): An array of all locales that are both requested by the browser and supported by your website. This produces a list of all compatible languages between your site and your visitor. The value is `[]` if none of the browser’s requested languages are found in your `locales` array. If the browser does not specify any preferred languages, then this value will be [i18n.locales](https://docs.astro.build/en/reference/configuration-reference/#i18nlocales).
- [Astro.currentLocale](https://docs.astro.build/en/reference/api-reference/#currentlocale): The locale computed from the current URL, using the syntax specified in your `locales` configuration. If the URL does not contain a `/[locale]/` prefix, then the value will default to [i18n.defaultLocale](https://docs.astro.build/en/reference/configuration-reference/#i18ndefaultlocale).

In order to successfully match your visitors’ preferences, provide your `codes` using the same pattern [used by the browser](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language#syntax).

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Markdown in Astro

> Learn about Astro's built-in support for Markdown.

# Markdown in Astro

[Markdown](https://daringfireball.net/projects/markdown/) is commonly used to author text-heavy content like blog posts and documentation. Astro includes built-in support for Markdown files that can also include [frontmatter YAML](https://dev.to/paulasantamaria/introduction-to-yaml-125f) (or [TOML](https://toml.io)) to define custom properties such as a title, description, and tags.

In Astro, you can author content in [GitHub Flavored Markdown](https://github.github.com/gfm/), then render it in `.astro` components. This combines a familiar writing format designed for content with the flexibility of Astro’s component syntax and architecture.

## Organizing Markdown files

[Section titled “Organizing Markdown files”](#organizing-markdown-files)

Your local Markdown files can be kept anywhere within your `src/` directory. Markdown files located within `src/pages/` will automatically generate [Markdown pages on your site](#individual-markdown-pages).

Your Markdown content and frontmatter properties are available to use in components through [local file imports](#importing-markdown) or when [queried and rendered from data fetched by a content collections helper function](#markdown-from-content-collections-queries).

### File imports vs content collections queries

[Section titled “File imports vs content collections queries”](#file-imports-vs-content-collections-queries)

Local Markdown can be imported into `.astro` components using an `import` statement for a single file and [Vite’simport.meta.glob()](https://docs.astro.build/en/guides/imports/#importmetaglob) to query multiple files at once. The [exported data from these Markdown files](#importing-markdown) can then be used in the `.astro` component.

If you have groups of related Markdown files, consider [defining them as collections](https://docs.astro.build/en/guides/content-collections/). This gives you several advantages, including the ability to store Markdown files anywhere on your filesystem or remotely.

Collections use content-specific, optimized APIs for [querying and rendering your Markdown content](#markdown-from-content-collections-queries) instead of file imports. Collections are intended for sets of data that share the same structure, such as blog posts or product items. When you define that shape in a schema, you additionally get validation, type safety, and Intellisense in your editor.

   See more about [when to use content collections](https://docs.astro.build/en/guides/content-collections/#when-to-create-a-collection) instead of file imports.

## Dynamic JSX-like expressions

[Section titled “Dynamic JSX-like expressions”](#dynamic-jsx-like-expressions)

After importing or querying Markdown files, you can write dynamic HTML templates in your `.astro` components that include frontmatter data and body content.

 src/pages/posts/great-post.md

```
---title: 'The greatest post of all time'author: 'Ben'---
Here is my _great_ post!
```

 src/pages/my-posts.astro

```
---import * as greatPost from './posts/great-post.md';const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));---
<p>{greatPost.frontmatter.title}</p><p>Written by: {greatPost.frontmatter.author}</p>
{greatPost.compiledContent()}
<p>Post Archive:</p><ul>  {posts.map(post => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}</ul>
```

### Available Properties

[Section titled “Available Properties”](#available-properties)

#### Markdown from content collections queries

[Section titled “Markdown from content collections queries”](#markdown-from-content-collections-queries)

When fetching data from your collections with the helper functions `getCollection()` or `getEntry()`, your Markdown’s frontmatter properties are available on a `data` object (e.g. `post.data.title`). Additionally, `body` contains the raw, uncompiled body content as a string.

The [render()](https://docs.astro.build/en/reference/modules/astro-content/#render) function returns your Markdown body content, a generated list of headings, as well as a modified frontmatter object after any remark or rehype plugins have been applied.

   Read more about [using content returned by a collections query](https://docs.astro.build/en/guides/content-collections/#using-content-in-astro-templates).

#### Importing Markdown

[Section titled “Importing Markdown”](#importing-markdown)

The following exported properties are available in your `.astro` component when importing Markdown using `import` or `import.meta.glob()`:

- **file** - The absolute file path (e.g. `/home/user/projects/.../file.md`).
- **url** - The URL of the page (e.g. `/en/guides/markdown-content`).
- **frontmatter** - Contains any data specified in the file’s YAML (or TOML) frontmatter.
- **<Content />** - A component that returns the full, rendered contents of the file.
- **rawContent()** - A function that returns the raw Markdown document as a string.
- **compiledContent()** - An async function that returns the Markdown document compiled to an HTML string.
- **getHeadings()** - An async function that returns an array of all headings (`<h1>` to `<h6>`) in the file with the type: `{ depth: number; slug: string; text: string }[]`. Each heading’s `slug` corresponds to the generated ID for a given heading and can be used for anchor links.

An example Markdown blog post may pass the following `Astro.props` object:

```
Astro.props = {  file: "/home/user/projects/.../file.md",  url: "/en/guides/markdown-content/",  frontmatter: {    /** Frontmatter from a blog post */    title: "Astro 0.18 Release",    date: "Tuesday, July 27 2021",    author: "Matthew Phillips",    description: "Astro 0.18 is our biggest release since Astro launch.",  },  getHeadings: () => [    {"depth": 1, "text": "Astro 0.18 Release", "slug": "astro-018-release"},    {"depth": 2, "text": "Responsive partial hydration", "slug": "responsive-partial-hydration"}    /* ... */  ],  rawContent: () => "# Astro 0.18 Release\nA little over a month ago, the first public beta [...]",  compiledContent: () => "<h1>Astro 0.18 Release</h1>\n<p>A little over a month ago, the first public beta [...]</p>",}
```

## The<Content />Component

[Section titled “The <Content /> Component”](#the-content--component)

The `<Content />` component is available by importing `Content` from a Markdown file. This component returns the file’s full body content, rendered to HTML. You can optionally rename `Content` to any component name you prefer.

You can similarly [render the HTML content of a Markdown collection entry](https://docs.astro.build/en/guides/content-collections/#rendering-body-content) by rendering a `<Content />` component.

 src/pages/content.astro

```
---// Import statementimport {Content as PromoBanner} from '../components/promoBanner.md';
// Collections queryimport { getEntry, render } from 'astro:content';
const product = await getEntry('products', 'shirt');const { Content } = await render(product);---<h2>Today's promo</h2><PromoBanner />
<p>Sale Ends: {product.data.saleEndDate.toDateString()}</p><Content />
```

## Heading IDs

[Section titled “Heading IDs”](#heading-ids)

Writing headings in Markdown will automatically give you anchor links so you can link directly to certain sections of your page.

 src/pages/page-1.md

```
---title: My page of content---## Introduction
I can link internally to [my conclusion](#conclusion) on the same page when writing Markdown.
## Conclusion
I can visit `https://example.com/page-1/#introduction` in a browser to navigate directly to my Introduction.
```

Astro generates heading `id`s based on `github-slugger`. You can find more examples in [the github-slugger documentation](https://github.com/Flet/github-slugger#usage).

### Heading IDs and plugins

[Section titled “Heading IDs and plugins”](#heading-ids-and-plugins)

Astro injects an `id` attribute into all heading elements (`<h1>` to `<h6>`) in Markdown and MDX files. You can retrieve this data from the `getHeadings()` utility available as a [Markdown exported property](#available-properties) from an imported file, or from the `render()` function when [using Markdown returned from a content collections query](#markdown-from-content-collections-queries).

You can customize these heading IDs by adding a rehype plugin that injects `id` attributes (e.g. `rehype-slug`). Your custom IDs, instead of Astro’s defaults, will be reflected in the HTML output and the items returned by `getHeadings()`.

By default, Astro injects `id` attributes after your rehype plugins have run. If one of your custom rehype plugins needs to access the IDs injected by Astro, you can import and use Astro’s `rehypeHeadingIds` plugin directly. Be sure to add `rehypeHeadingIds` before any plugins that rely on it:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';import { rehypeHeadingIds } from '@astrojs/markdown-remark';import { otherPluginThatReliesOnHeadingIDs } from 'some/plugin/source';
export default defineConfig({  markdown: {    rehypePlugins: [      rehypeHeadingIds,      otherPluginThatReliesOnHeadingIDs,    ],  },});
```

## Markdown Plugins

[Section titled “Markdown Plugins”](#markdown-plugins)

Markdown support in Astro is powered by [remark](https://remark.js.org/), a powerful parsing and processing tool with an active ecosystem. Other Markdown parsers like Pandoc and markdown-it are not currently supported.

Astro applies the [GitHub-flavored Markdown](https://github.com/remarkjs/remark-gfm) and [SmartyPants](https://github.com/silvenon/remark-smartypants) plugins by default. This brings some niceties like generating clickable links from text, and formatting for [quotations and em-dashes](https://daringfireball.net/projects/smartypants/).

You can customize how remark parses your Markdown in `astro.config.mjs`. See the full list of [Markdown configuration options](https://docs.astro.build/en/reference/configuration-reference/#markdown-options).

### Adding remark and rehype plugins

[Section titled “Adding remark and rehype plugins”](#adding-remark-and-rehype-plugins)

Astro supports adding third-party [remark](https://github.com/remarkjs/remark) and [rehype](https://github.com/rehypejs/rehype) plugins for Markdown. These plugins allow you to extend your Markdown with new capabilities, like [auto-generating a table of contents](https://github.com/remarkjs/remark-toc), [applying accessible emoji labels](https://github.com/florianeckerstorfer/remark-a11y-emoji), and [styling your Markdown](https://docs.astro.build/en/guides/styling/#markdown-styling).

We encourage you to browse [awesome-remark](https://github.com/remarkjs/awesome-remark) and [awesome-rehype](https://github.com/rehypejs/awesome-rehype) for popular plugins! See each plugin’s own README for specific installation instructions.

This example applies [remark-toc](https://github.com/remarkjs/remark-toc) and [rehype-accessible-emojis](https://www.npmjs.com/package/rehype-accessible-emojis) to Markdown files:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';import remarkToc from 'remark-toc';import { rehypeAccessibleEmojis } from 'rehype-accessible-emojis';
export default defineConfig({  markdown: {    remarkPlugins: [ [remarkToc, { heading: 'toc', maxDepth: 3 } ] ],    rehypePlugins: [rehypeAccessibleEmojis],  },});
```

### Customizing a plugin

[Section titled “Customizing a plugin”](#customizing-a-plugin)

In order to customize a plugin, provide an options object after it in a nested array.

The example below adds the [heading option to theremarkTocplugin](https://github.com/remarkjs/remark-toc#options) to change where the table of contents is placed, and the [behavioroption to therehype-autolink-headingsplugin](https://github.com/rehypejs/rehype-autolink-headings#options) in order to add the anchor tag after the headline text.

 astro.config.mjs

```
import remarkToc from 'remark-toc';import rehypeSlug from 'rehype-slug';import rehypeAutolinkHeadings from 'rehype-autolink-headings';
export default {  markdown: {    remarkPlugins: [ [remarkToc, { heading: "contents"} ] ],    rehypePlugins: [rehypeSlug, [rehypeAutolinkHeadings, { behavior: 'append' }]],  },}
```

### Modifying frontmatter programmatically

[Section titled “Modifying frontmatter programmatically”](#modifying-frontmatter-programmatically)

You can add frontmatter properties to all of your Markdown and MDX files by using a [remark or rehype plugin](#markdown-plugins).

1. Append a `customProperty` to the `data.astro.frontmatter` property from your plugin’s `file` argument:
   example-remark-plugin.mjs
  ```
  export function exampleRemarkPlugin() {  // All remark and rehype plugins return a separate function  return function (tree, file) {    file.data.astro.frontmatter.customProperty = 'Generated property';  }}
  ```
2. Apply this plugin to your `markdown`  or `mdx` integration config:
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';import { exampleRemarkPlugin } from './example-remark-plugin.mjs';
  export default defineConfig({  markdown: {    remarkPlugins: [exampleRemarkPlugin]  },});
  ```
  or
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';import { exampleRemarkPlugin } from './example-remark-plugin.mjs';
  export default defineConfig({  integrations: [    mdx({      remarkPlugins: [exampleRemarkPlugin],    }),  ],});
  ```

Now, every Markdown or MDX file will have `customProperty` in its frontmatter, making it available when [importing your markdown](#importing-markdown) and from [theAstro.props.frontmatterproperty in your layouts](#frontmatter-layout-property).

   ![](https://docs.astro.build/houston_chef.webp) **Related recipe:** [Add reading time](https://docs.astro.build/en/recipes/reading-time/)

### Extending Markdown config from MDX

[Section titled “Extending Markdown config from MDX”](#extending-markdown-config-from-mdx)

Astro’s MDX integration will extend [your project’s existing Markdown configuration](https://docs.astro.build/en/reference/configuration-reference/#markdown-options) by default. To override individual options, you can specify their equivalent in your MDX configuration.

The following example disables GitHub-Flavored Markdown and applies a different set of remark plugins for MDX files:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';import mdx from '@astrojs/mdx';
export default defineConfig({  markdown: {    syntaxHighlight: 'prism',    remarkPlugins: [remarkPlugin1],    gfm: true,  },  integrations: [    mdx({      // `syntaxHighlight` inherited from Markdown
      // Markdown `remarkPlugins` ignored,      // only `remarkPlugin2` applied.      remarkPlugins: [remarkPlugin2],      // `gfm` overridden to `false`      gfm: false,    })  ]});
```

To avoid extending your Markdown config from MDX, set [theextendMarkdownConfigoption](https://docs.astro.build/en/guides/integrations-guide/mdx/#extendmarkdownconfig) (enabled by default) to `false`:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';import mdx from '@astrojs/mdx';
export default defineConfig({  markdown: {    remarkPlugins: [remarkPlugin],  },  integrations: [    mdx({      // Markdown config now ignored      extendMarkdownConfig: false,      // No `remarkPlugins` applied    })  ]});
```

## Individual Markdown pages

[Section titled “Individual Markdown pages”](#individual-markdown-pages)

Astro treats [any supported file inside of the/src/pages/directory](https://docs.astro.build/en/basics/astro-pages/#supported-page-files) as a page, including `.md` and other Markdown file types.

Placing a file in this directory, or any sub-directory, will automatically build a page route using the pathname of the file and display the Markdown content rendered to HTML. Astro will automatically add a `<meta charset="utf-8">` tag to your page to allow easier authoring of non-ASCII content.

 src/pages/page-1.md

```
---title: Hello, World---
# Hi there!
This Markdown file creates a page at `your-domain.com/page-1/`
It probably isn't styled much, but Markdown does support:- **bold** and _italics._- lists- [links](https://astro.build)- <p>HTML elements</p>- and more!
```

### Frontmatterlayoutproperty

[Section titled “Frontmatter layout property”](#frontmatter-layout-property)

To help with the limited functionality of individual Markdown pages, Astro provides a special frontmatter `layout` property which is a relative path to an Astro [Markdown layout component](https://docs.astro.build/en/basics/layouts/#markdown-layouts). `layout` is not a special property when using [content collections](https://docs.astro.build/en/guides/content-collections/) to query and render your Markdown content, and is not guaranteed to be supported outside of its intended use case.

If your Markdown file is located within `src/pages/`, create a layout component and add it in this layout property to provide a page shell around your Markdown content.

 src/pages/posts/post-1.md

```
---layout: ../../layouts/BlogPostLayout.astrotitle: Astro in briefauthor: Himanshudescription: Find out what makes Astro awesome!---This is a post written in Markdown.
```

This layout component is a regular Astro component with [specific properties automatically available](https://docs.astro.build/en/basics/layouts/#markdown-layout-props) through `Astro.props` for your Astro template. For example, you can access your Markdown file’s frontmatter properties through `Astro.props.frontmatter`:

 src/layouts/BlogPostLayout.astro

```
---const {frontmatter} = Astro.props;---<html>  <head>        <meta charset="utf-8"> // no longer added by default  </head>    <h1>{frontmatter.title}</h1>  <h2>Post author: {frontmatter.author}</h2>  <p>{frontmatter.description}</p>  <slot />   </html>
```

When using the frontmatter `layout` property, you must include the `<meta charset="utf-8">` tag in your layout as Astro will no longer add it automatically. You can now also [style your Markdown](https://docs.astro.build/en/guides/styling/#markdown-styling) in your layout component.

   Learn more about [Markdown Layouts](https://docs.astro.build/en/basics/layouts/#markdown-layouts).

## Fetching Remote Markdown

[Section titled “Fetching Remote Markdown”](#fetching-remote-markdown)

Astro’s internal Markdown processor is not available for processing remote Markdown.

To fetch remote Markdown for use in [content collections](https://docs.astro.build/en/guides/content-collections/), you can [build a custom loader](https://docs.astro.build/en/guides/content-collections/#building-a-custom-loader) with access to a [renderMarkdown()function](https://docs.astro.build/en/reference/content-loader-reference/#rendermarkdown).

To fetch remote Markdown directly and render it to HTML, you will need to install and configure your own Markdown parser from NPM. This will not inherit from any of Astro’s built-in Markdown settings that you have configured.

Be sure that you understand these limitations before implementing this in your project, and consider fetching your remote Markdown using a content collections loader instead.

 src/pages/remote-example.astro

```
---// Example: Fetch Markdown from a remote API// and render it to HTML, at runtime.// Using "marked" (https://github.com/markedjs/marked)import { marked } from 'marked';const response = await fetch('https://raw.githubusercontent.com/wiki/adam-p/markdown-here/Markdown-Cheatsheet.md');const markdown = await response.text();const content = marked.parse(markdown);---<article set:html={content} />
```

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Cloudinary & Astro

> Add images and videos to your Astro project using Cloudinary

# Cloudinary & Astro

[Cloudinary](https://cloudinary.com) is an image and video platform and headless Digital Asset Manager (DAM) that lets you host assets and deliver them from their content delivery network (CDN).

When delivering from Cloudinary, you additionally get access to their Transformation API, giving you the ability to edit your assets with tools like background removal, dynamic cropping and resizing, and generative AI.

## Using Cloudinary in Astro

[Section titled “Using Cloudinary in Astro”](#using-cloudinary-in-astro)

Cloudinary supports a wide variety of SDKs that can be used depending on your Astro environment.

The [Cloudinary Astro SDK](https://astro.cloudinary.dev/) provides native Astro components, including image, video, and upload components, as well as a content loader that can be used with Astro content collections.

Alternatively, both the Cloudinary [Node.js SDK](https://cloudinary.com/documentation/node_integration) and [JavaScript SDK](https://cloudinary.com/documentation/javascript_integration) can be used to generate URLs for your images. The Node.js SDK can additionally make requests to the Cloudinary API including uploading assets, requesting resources, and running content analysis.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

- An existing Astro project
- A Cloudinary account

## Installing Astro Cloudinary

[Section titled “Installing Astro Cloudinary”](#installing-astro-cloudinary)

Install the Cloudinary Astro SDK by running the appropriate command for your package manager:

- [npm](#tab-panel-3058)
- [pnpm](#tab-panel-3059)
- [Yarn](#tab-panel-3060)

   Terminal window

```
npm install astro-cloudinary
```

   Terminal window

```
pnpm add astro-cloudinary
```

   Terminal window

```
yarn add astro-cloudinary
```

## Configuring your account

[Section titled “Configuring your account”](#configuring-your-account)

Create a new `.env` file in the root of your project and add your Cloudinary credentials:

 .env

```
PUBLIC_CLOUDINARY_CLOUD_NAME="<Your Cloud Name>"
// Only needed if using CldUploadWidget or cldAssetsLoaderPUBLIC_CLOUDINARY_API_KEY="<Your API Key>"CLOUDINARY_API_SECRET="<Your API Secret>"
```

## Using Cloudinary images

[Section titled “Using Cloudinary images”](#using-cloudinary-images)

Add images in `.astro` components by passing image data (e.g. `src`, `width`, `alt`) to the `<CldImage>` component. This will automatically optimize your image and give you access to the Transformations API.

 Component.astro

```
---import { CldImage } from 'astro-cloudinary';---<CldImage  src="<Public ID>"  width="<Width>"  height="<Height>"  alt="<Description>"/>
```

See [Cloudinary’s<CldImage>documentation](https://astro.cloudinary.dev/cldimage/basic-usage) for more information.

## Using Cloudinary videos

[Section titled “Using Cloudinary videos”](#using-cloudinary-videos)

To add video to your `.astro` components,  add the `<CldVideoPlayer>`  and pass the appropriate properties. This component will automatically optimize and embed your video using the [Cloudinary Video Player](https://cloudinary.com/documentation/cloudinary_video_player).

 Component.astro

```
---import { CldVideoPlayer } from 'astro-cloudinary';---<CldVideoPlayer  src="<Public ID>"  width="<Width>"  height="<Height>"/>
```

See [Cloudinary’s<CldVideoPlayer>documentation](https://astro.cloudinary.dev/cldvideoplayer/basic-usage) for more information.

## Enabling Cloudinary uploads

[Section titled “Enabling Cloudinary uploads”](#enabling-cloudinary-uploads)

To enable file uploading in your website or app’s UI, add the `<CldUploadWidget>` which will embed the [Cloudinary Upload Widget](https://cloudinary.com/documentation/upload_widget).

The following example creates a widget to allow unsigned uploads by passing an unsigned [Upload Preset](https://cloudinary.com/documentation/upload_presets):

 Component.astro

```
---import { CldUploadWidget } from 'astro-cloudinary';---<CldUploadWidget uploadPreset="<Upload Preset>">  <button>Upload</button></CldUploadWidget>
```

For signed uploads, you can find [a guide and example](https://astro.cloudinary.dev/clduploadwidget/signed-uploads) on the Astro Cloudinary docs.

See [Cloudinary’s<CldUploadWidget>documentation](https://astro.cloudinary.dev/clduploadwidget/basic-usage) for more information.

## Cloudinary content loader

[Section titled “Cloudinary content loader”](#cloudinary-content-loader)

The Cloudinary Astro SDK provides the `cldAssetsLoader` content loader to load Cloudinary assets for content collections.

To load a collection of images or videos, set `loader: cldAssetsLoader ({})` with a `folder`, if required:

 config.ts

```
import { defineCollection } from 'astro:content';import { cldAssetsLoader } from 'astro-cloudinary/loaders';
export const collections = {  assets: defineCollection({    loader: cldAssetsLoader({      folder: '<Folder>' // Optional, without loads root directory    })  }),}
```

You can then use the [getCollection()orgetEntry()query functions](https://docs.astro.build/en/guides/content-collections/#querying-collections) to select one or many images or videos from your collection.

See [Cloudinary’scldAssetsLoaderdocumentation](https://astro.cloudinary.dev/cldassetsloader/basic-usage) for more information.

## Generating Cloudinary image URLs

[Section titled “Generating Cloudinary image URLs”](#generating-cloudinary-image-urls)

The Astro Cloudinary SDK provides a `getCldOgImageUrl()` helper for generating and using URLs for your images. Use this when you need a URL instead of a component to display your image.

One common use for a URL is for an Open Graph image in `<meta>` tags for social media cards. This helper, like the components, provides you access to Cloudinary transformations to create dynamic, unique social cards for any of your pages.

The following example shows the necessary `<meta>` tags for a social media card, using `getCldOgImageUrl()` to generate an Open Graph image:

 Layout.astro

```
---import { getCldOgImageUrl } from 'astro-cloudinary/helpers';const ogImageUrl = getCldOgImageUrl({ src: '<Public ID>' });---<meta property="og:image" content={ogImageUrl} /><meta property="og:image:secure_url" content={ogImageUrl} /><meta property="og:image:width" content="1200" /><meta property="og:image:height" content="630" /><meta property="twitter:title" content="<Twitter Title>" /><meta property="twitter:card" content="summary_large_image" /><meta property="twitter:image" content={ogImageUrl} />
```

Find [Cloudinary Social Media Card templates](https://astro.cloudinary.dev/templates/social-media-cards) on the Cloudinary docs.

See [Cloudinary’sgetCldOgImageUrl()documentation](https://astro.cloudinary.dev/getcldogimageurl/basic-usage) for more information.

## Using Cloudinary in Node.js

[Section titled “Using Cloudinary in Node.js”](#using-cloudinary-in-nodejs)

For more complex asset management, uploading, or analysis, you can use the Cloudinary Node.js SDK when working in an Astro Node.js environment.

Install the Cloudinary Node.js SDK by running the appropriate command for your package manager:

- [npm](#tab-panel-3061)
- [pnpm](#tab-panel-3062)
- [Yarn](#tab-panel-3063)

   Terminal window

```
npm install cloudinary
```

   Terminal window

```
pnpm add cloudinary
```

   Terminal window

```
yarn add cloudinary
```

Add the following environment variables in your `.env` file:

 .env

```
PUBLIC_CLOUDINARY_CLOUD_NAME="<Your Cloud Name>"PUBLIC_CLOUDINARY_API_KEY="<Your API Key>"CLOUDINARY_API_SECRET="<Your API Secret>"
```

Configure your account with a new Cloudinary instance by adding the following code between the fences of your Astro component:

 Component.astro

```
---import { v2 as cloudinary } from "cloudinary";
cloudinary.config({  cloud_name: import.meta.env.PUBLIC_CLOUDINARY_CLOUD_NAME,  api_key: import.meta.env.PUBLIC_CLOUDINARY_API_KEY,  api_secret: import.meta.env.CLOUDINARY_API_SECRET,});---
```

This will give you access to all of the Cloudinary APIs to allow you to interact with your images, videos, and other supported files.

 Component.astro

```
await cloudinary.uploader.upload('./path/to/file');
```

Learn how to [upload files using the Cloudinary Node.js SDK with Astro Forms](https://www.youtube.com/watch?v=DQUYMyT2MTM).

## Official Resources

[Section titled “Official Resources”](#official-resources)

- [Cloudinary Astro SDK](https://astro.cloudinary.dev/)
- [Cloudinary Node.js SDK](https://cloudinary.com/documentation/node_integration)
- [Using Cloudinary with Astro (YouTube)](https://www.youtube.com/playlist?list=PL8dVGjLA2oMqnpf2tShn1exf5GkSWuu5-)
- [Code Examples Using Cloudinary Astro SDK (GitHub)](https://github.com/cloudinary-community/cloudinary-examples/tree/main/examples/astro-cloudinary)

## More hosted media guides

- ![](https://docs.astro.build/logos/cloudinary.svg)
  ### Cloudinary
- ![](https://docs.astro.build/logos/mux.svg)
  ### Mux

   Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
