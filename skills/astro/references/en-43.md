# Add an RSS feed and more

# Add an RSS feed

> Add an RSS feed to your Astro site to let users subscribe to your content.

# Add an RSS feed

Astro supports fast, automatic RSS feed generation for blogs and other content websites. RSS feeds provide an easy way for users to subscribe to your content.

## Setting up@astrojs/rss

[Section titled ‚ÄúSetting up @astrojs/rss‚Äù](#setting-up-astrojsrss)

The package [@astrojs/rss](https://github.com/withastro/astro/tree/main/packages/astro-rss) provides helpers for generating RSS feeds using [API endpoints](https://docs.astro.build/en/guides/endpoints/#static-file-endpoints). This unlocks both static builds *and* on-demand generation when using an [SSR adapter](https://docs.astro.build/en/guides/on-demand-rendering/).

1. Install `@astrojs/rss` using your preferred package manager:
  - [npm](#tab-panel-1909)
  - [pnpm](#tab-panel-1910)
  - [Yarn](#tab-panel-1911)
     Terminal window
  ```
  npm install @astrojs/rss
  ```
     Terminal window
  ```
  pnpm add @astrojs/rss
  ```
     Terminal window
  ```
  yarn add @astrojs/rss
  ```
2. Create a file in `src/pages/` with a name of your choice and the extension `.xml.js` to be used as the output URL for your feed. Some common RSS feed URL names are `feed.xml` or `rss.xml`.
  The example file below `src/pages/rss.xml.js` will create an RSS feed at `site/rss.xml`.
3. Import the `rss()` helper from the `@astrojs/rss` package into your `.xml.js` file and export a function that returns it using the following parameters:
   src/pages/rss.xml.js
  ```
  import rss from '@astrojs/rss';
  export function GET(context) {  return rss({    // `<title>` field in output xml    title: 'Buzz‚Äôs Blog',    // `<description>` field in output xml    description: 'A humble Astronaut‚Äôs guide to the stars',    // Pull in your project "site" from the endpoint context    // https://docs.astro.build/en/reference/api-reference/#site    site: context.site,    // Array of `<item>`s in output xml    // See "Generating items" section for examples using content collections and glob imports    items: [],    // (optional) inject custom xml    customData: `<language>en-us</language>`,  });}
  ```

   See the [@astrojs/rssREADME](https://github.com/withastro/astro/tree/main/packages/astro-rss) for the full configuration reference.

## Generatingitems

[Section titled ‚ÄúGenerating items‚Äù](#generating-items)

The `items` field accepts a list of RSS feed objects, which can be generated from content collections entries using `getCollection()` or from your page files using `pagesGlobToRssItems()`.

The RSS feed standard format includes metadata for each published item, including values such as:

- `title`: The title of the entry. Optional only if a `description` is set. Otherwise, required.
- `description`: A short excerpt from or describing the entry. Optional only if a `title` is set. Otherwise, required.
- `link`: A URL to the original source of the entry. (optional)
- `pubDate`: The date of publication of the entry. (optional)
- `content`: The full content of your post. (optional)

   See the [itemsconfiguration reference](https://github.com/withastro/astro/tree/main/packages/astro-rss#items) for a complete list of options.

### Using content collections

[Section titled ‚ÄúUsing content collections‚Äù](#using-content-collections)

To create an RSS feed of pages managed in [content collections](https://docs.astro.build/en/guides/content-collections/), use the `getCollection()` function to retrieve the data required for your `items` array. You will need to specify the values for each desired property (e.g. `title`, `description`) from the returned data.

 src/pages/rss.xml.js

```
import rss from '@astrojs/rss';import { getCollection } from 'astro:content';
export async function GET(context) {  const blog = await getCollection('blog');  return rss({    title: 'Buzz‚Äôs Blog',    description: 'A humble Astronaut‚Äôs guide to the stars',    site: context.site,    items: blog.map((post) => ({      title: post.data.title,      pubDate: post.data.pubDate,      description: post.data.description,      // Compute RSS link from post `id`      // This example assumes all posts are rendered as `/blog/[id]` routes      link: `/blog/${post.id}/`,    })),  });}
```

Optional: replace your existing blog collection schema to enforce the expected RSS properties.

To ensure that every blog entry produces a valid RSS feed item, you can optionally import and apply `rssSchema` instead of defining each individual property of your schema.

 src/content.config.ts

```
import { defineCollection } from 'astro:content';import { rssSchema } from '@astrojs/rss';
const blog = defineCollection({  schema: rssSchema,});
export const collections = { blog };
```

### Using glob imports

[Section titled ‚ÄúUsing glob imports‚Äù](#using-glob-imports)

**Added in:** `@astrojs/rss@2.1.0`

To create an RSS feed from documents in `src/pages/`, use the `pagesGlobToRssItems()` helper. This accepts an [import.meta.glob](https://vite.dev/guide/features.html#glob-import) result and outputs an array of valid RSS feed items (see [more about writing glob patterns](https://docs.astro.build/en/guides/imports/#glob-patterns) for specifying which pages to include).

  src/pages/rss.xml.js

```
import rss, { pagesGlobToRssItems } from '@astrojs/rss';
export async function GET(context) {  return rss({    title: 'Buzz‚Äôs Blog',    description: 'A humble Astronaut‚Äôs guide to the stars',    site: context.site,    items: await pagesGlobToRssItems(      import.meta.glob('./blog/*.{md,mdx}'),    ),  });}
```

### Including full post content

[Section titled ‚ÄúIncluding full post content‚Äù](#including-full-post-content)

**Added in:** `astro@1.6.14`

Set the `content` key on `rss.items` to provide the full content of a post as HTML. This allows `@astrojs/rss` to make the full Markdown text of your post available to RSS feed readers. Images and links with full URL paths are also supported. However, images and internal links to other pages using relative paths are not.

When rendering full post content, you will have to consider images, relative links, styles, scripts, and other elements beyond standard Markdown text that you may have in your posts. You may need to include additional logic in your `src/pages/rss.xml.js` endpoint to account for these, or to remove elements that are unnecessary for an RSS feed (e.g. those that are used only for styling or interaction on your website).

You can see [one specific community implementation](https://github.com/delucis/astro-blog-full-text-rss/blob/latest/src/pages/rss.xml.ts) that addresses some of these concerns for an example of how to proceed.

When using content collections, render the post `body` using a standard Markdown parser like [markdown-it](https://github.com/markdown-it/markdown-it) and sanitize the result, including any extra tags (e.g. `<img>`) needed to render your content:

 src/pages/rss.xml.js

```
import rss from '@astrojs/rss';import { getCollection } from 'astro:content';import sanitizeHtml from 'sanitize-html';import MarkdownIt from 'markdown-it';const parser = new MarkdownIt();
export async function GET(context) {  const blog = await getCollection('blog');  return rss({    title: 'Buzz‚Äôs Blog',    description: 'A humble Astronaut‚Äôs guide to the stars',    site: context.site,    items: blog.map((post) => ({      link: `/blog/${post.id}/`,      // Note: this will not process components or JSX expressions in MDX files.      content: sanitizeHtml(parser.render(post.body), {        allowedTags: sanitizeHtml.defaults.allowedTags.concat(['img'])      }),      ...post.data,    })),  });}
```

When using glob imports with Markdown, you may use the `compiledContent()` helper to retrieve the rendered HTML for sanitization. Note: this feature is **not** supported for MDX files.

 src/pages/rss.xml.js

```
import rss from '@astrojs/rss';import sanitizeHtml from 'sanitize-html';
export async function GET(context) {  const postImportResult = import.meta.glob('../posts/**/*.md', { eager: true });  const posts = Object.values(postImportResult);  return rss({    title: 'Buzz‚Äôs Blog',    description: 'A humble Astronaut‚Äôs guide to the stars',    site: context.site,    items: await Promise.all(posts.map(async (post) => ({      link: post.url,      content: sanitizeHtml((await post.compiledContent())),      ...post.frontmatter,    }))),  });}
```

## Removing trailing slashes

[Section titled ‚ÄúRemoving trailing slashes‚Äù](#removing-trailing-slashes)

Astro‚Äôs RSS feed produces links with a trailing slash by default, no matter what value you have configured for `trailingSlash`. This means that your RSS links may not match your post URLs exactly.

If you have set `trailingSlash: "never"` on your `astro.config.mjs`, set `trailingSlash: false` in the `rss()` helper so that your feed matches your project configuration.

 src/pages/rss.xml.js

```
import rss from '@astrojs/rss';
export function GET(context) {  const posts = Object.values(postImportResult);  return rss({    title: 'Buzz‚Äôs Blog',    description: 'A humble Astronaut‚Äôs guide to the stars',    site: context.site,    trailingSlash: false,    items: posts.map((post) => ({      link: post.url,      ...post.frontmatter,    })),  });}
```

## Adding a stylesheet

[Section titled ‚ÄúAdding a stylesheet‚Äù](#adding-a-stylesheet)

Style your RSS feed for a more pleasant user experience when viewing the file in your browser.

Use the `rss` function‚Äôs `stylesheet` option to specify an absolute path to your stylesheet.

```
rss({  // ex. use your stylesheet from "public/rss/styles.xsl"  stylesheet: '/rss/styles.xsl',  // ...});
```

## Enabling RSS feed auto-discovery

[Section titled ‚ÄúEnabling RSS feed auto-discovery‚Äù](#enabling-rss-feed-auto-discovery)

[RSS autodiscovery](https://www.rssboard.org/rss-autodiscovery) allows browsers and other software to automatically find a site‚Äôs RSS feed from the main URL.

To enable, add a `<link>` tag with the following attributes to your site‚Äôs `head` element:

```
<link    rel="alternate"    type="application/rss+xml"    title="Your Site's Title"    href={new URL("rss.xml", Astro.site)}/>
```

With this tag, readers of your blog can enter your site‚Äôs base URL into their RSS reader to subscribe to your posts without needing the specific URL of your RSS feed.

## Next Steps

[Section titled ‚ÄúNext Steps‚Äù](#next-steps)

After visiting your feed in the browser at `your-domain.com/rss.xml` and confirming that you can see data for each of your posts, you can now [promote your feed on your website](https://medium.com/samsung-internet-dev/add-rss-feeds-to-your-website-to-keep-your-core-readers-engaged-3179dca9c91e#:~:text=com/~deno%2Drss-,Advertising%20your%20RSS%20feed,-Now%20you%20have). Adding the standard RSS icon to your site lets your readers know that they can subscribe to your posts in their own feed reader.

## Resources

[Section titled ‚ÄúResources‚Äù](#resources)

- [RSS Feeds](https://aboutfeeds.com/)

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Share state between islands

> Learn how to share state across framework components with Nano Stores.

# Share state between islands

When building an Astro website with [islands architecture / partial hydration](https://docs.astro.build/en/concepts/islands/), you may have run into this problem: **I want to share state between my components.**

UI frameworks like React or Vue may encourage [‚Äúcontext‚Äù providers](https://react.dev/learn/passing-data-deeply-with-context) for other components to consume. But when [partially hydrating components](https://docs.astro.build/en/guides/framework-components/#hydrating-interactive-components) within Astro or Markdown, you can‚Äôt use these context wrappers.

Astro recommends a different solution for shared client-side storage: [Nano Stores](https://github.com/nanostores/nanostores).

   ![](https://docs.astro.build/houston_chef.webp) **Related recipe:** [Share state between Astro components](https://docs.astro.build/en/recipes/sharing-state/)

## Why Nano Stores?

[Section titled ‚ÄúWhy Nano Stores?‚Äù](#why-nano-stores)

The [Nano Stores](https://github.com/nanostores/nanostores) library allows you to author stores that any component can interact with. We recommend Nano Stores because:

- **They‚Äôre lightweight.** Nano Stores ship the bare minimum JS you‚Äôll need (less than 1 KB) with zero dependencies.
- **They‚Äôre framework-agnostic.** This means sharing state between frameworks will be seamless! Astro is built on flexibility, so we love solutions that offer a similar developer experience no matter your preference.

Still, there are a number of alternatives you can explore. These include:

- [Svelte‚Äôs built-in stores](https://svelte.dev/tutorial/writable-stores)
- [Solid signals](https://www.solidjs.com/docs/latest) outside of a component context
- [Vue‚Äôs reactivity API](https://vuejs.org/guide/scaling-up/state-management.html#simple-state-management-with-reactivity-api)
- [Sending custom browser events](https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events) between components

## Installing Nano Stores

[Section titled ‚ÄúInstalling Nano Stores‚Äù](#installing-nano-stores)

To get started, install Nano Stores alongside their helper package for your favorite UI framework:

- [Preact](#tab-panel-1916)
- [React](#tab-panel-1917)
- [Solid](#tab-panel-1918)
- [Svelte](#tab-panel-1919)
- [Vue](#tab-panel-1920)

   Terminal window

```
npm install nanostores @nanostores/preact
```

  Terminal window

```
npm install nanostores @nanostores/react
```

  Terminal window

```
npm install nanostores @nanostores/solid
```

  Terminal window

```
npm install nanostores
```

  Terminal window

```
npm install nanostores @nanostores/vue
```

You can jump into the [Nano Stores usage guide](https://github.com/nanostores/nanostores#guide) from here, or follow along with our example below!

## Usage example - ecommerce cart flyout

[Section titled ‚ÄúUsage example - ecommerce cart flyout‚Äù](#usage-example---ecommerce-cart-flyout)

Let‚Äôs say we‚Äôre building a simple ecommerce interface with three interactive elements:

- An ‚Äúadd to cart‚Äù submission form
- A cart flyout to display those added items
- A cart flyout toggle

*Try the completed exampleon your machine or online via StackBlitz.*

Your base Astro file may look like this:

 src/pages/index.astro

```
---import CartFlyoutToggle from '../components/CartFlyoutToggle';import CartFlyout from '../components/CartFlyout';import AddToCartForm from '../components/AddToCartForm';---
<!DOCTYPE html><html lang="en"><head>...</head><body>  <header>    <nav>      <a href="/">Astro storefront</a>      <CartFlyoutToggle client:load />    </nav>  </header>  <main>    <AddToCartForm client:load>        </AddToCartForm>  </main>  <CartFlyout client:load /></body></html>
```

### Using ‚Äúatoms‚Äù

[Section titled ‚ÄúUsing ‚Äúatoms‚Äù‚Äù](#using-atoms)

Let‚Äôs start by opening our `CartFlyout` whenever `CartFlyoutToggle` is clicked.

First, create a new JS  or TS file to contain our store. We‚Äôll use an [‚Äúatom‚Äù](https://github.com/nanostores/nanostores#atoms) for this:

 src/cartStore.js

```
import { atom } from 'nanostores';
export const isCartOpen = atom(false);
```

Now, we can import this store into any file that needs to read or write. We‚Äôll start by wiring up our `CartFlyoutToggle`:

- [Preact](#tab-panel-1921)
- [React](#tab-panel-1922)
- [Solid](#tab-panel-1923)
- [Svelte](#tab-panel-1924)
- [Vue](#tab-panel-1925)

   src/components/CartFlyoutToggle.jsx

```
import { useStore } from '@nanostores/preact';import { isCartOpen } from '../cartStore';
export default function CartButton() {  // read the store value with the `useStore` hook  const $isCartOpen = useStore(isCartOpen);  // write to the imported store using `.set`  return (    <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button>  )}
```

  src/components/CartFlyoutToggle.jsx

```
import { useStore } from '@nanostores/react';import { isCartOpen } from '../cartStore';
export default function CartButton() {  // read the store value with the `useStore` hook  const $isCartOpen = useStore(isCartOpen);  // write to the imported store using `.set`  return (    <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button>  )}
```

  src/components/CartFlyoutToggle.jsx

```
import { useStore } from '@nanostores/solid';import { isCartOpen } from '../cartStore';
export default function CartButton() {  // read the store value with the `useStore` hook  const $isCartOpen = useStore(isCartOpen);  // write to the imported store using `.set`  return (    <button onClick={() => isCartOpen.set(!$isCartOpen())}>Cart</button>  )}
```

  src/components/CartFlyoutToggle.svelte

```
<script>  import { isCartOpen } from '../cartStore';</script>
<button on:click={() => isCartOpen.set(!$isCartOpen)}>Cart</button>
```

  src/components/CartFlyoutToggle.vue

```
<template>    <button @click="isCartOpen.set(!$isCartOpen)">Cart</button></template>
<script setup>  import { isCartOpen } from '../cartStore';  import { useStore } from '@nanostores/vue';
  // read the store value with the `useStore` hook  const $isCartOpen = useStore(isCartOpen);</script>
```

Then, we can read `isCartOpen` from our `CartFlyout` component:

- [Preact](#tab-panel-1926)
- [React](#tab-panel-1927)
- [Solid](#tab-panel-1928)
- [Svelte](#tab-panel-1929)
- [Vue](#tab-panel-1930)

   src/components/CartFlyout.jsx

```
import { useStore } from '@nanostores/preact';import { isCartOpen } from '../cartStore';
export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);
  return $isCartOpen ? <aside>...</aside> : null;}
```

  src/components/CartFlyout.jsx

```
import { useStore } from '@nanostores/react';import { isCartOpen } from '../cartStore';
export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);
  return $isCartOpen ? <aside>...</aside> : null;}
```

  src/components/CartFlyout.jsx

```
import { useStore } from '@nanostores/solid';import { isCartOpen } from '../cartStore';
export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);
  return $isCartOpen() ? <aside>...</aside> : null;}
```

  src/components/CartFlyout.svelte

```
<script>  import { isCartOpen } from '../cartStore';</script>
{#if $isCartOpen}<aside>...</aside>{/if}
```

  src/components/CartFlyout.vue

```
<template>  <aside v-if="$isCartOpen">...</aside></template>
<script setup>  import { isCartOpen } from '../cartStore';  import { useStore } from '@nanostores/vue';
  const $isCartOpen = useStore(isCartOpen);</script>
```

### Using ‚Äúmaps‚Äù

[Section titled ‚ÄúUsing ‚Äúmaps‚Äù‚Äù](#using-maps)

Now, let‚Äôs keep track of the items inside your cart. To avoid duplicates and keep track of ‚Äúquantity,‚Äù we can store your cart as an object with the item‚Äôs ID as a key. We‚Äôll use a [Map](https://github.com/nanostores/nanostores#maps) for this.

Let‚Äôs add a `cartItem` store to our `cartStore.js` from earlier. You can also switch to a TypeScript file to define the shape if you‚Äôre so inclined.

- [JavaScript](#tab-panel-1912)
- [TypeScript](#tab-panel-1913)

   src/cartStore.js

```
import { atom, map } from 'nanostores';
export const isCartOpen = atom(false);
/** * @typedef {Object} CartItem * @property {string} id * @property {string} name * @property {string} imageSrc * @property {number} quantity */
/** @type {import('nanostores').MapStore<Record<string, CartItem>>} */export const cartItems = map({});
```

   src/cartStore.ts

```
import { atom, map } from 'nanostores';
export const isCartOpen = atom(false);
export type CartItem = {  id: string;  name: string;  imageSrc: string;  quantity: number;}
export const cartItems = map<Record<string, CartItem>>({});
```

Now, let‚Äôs export an `addCartItem` helper for our components to use.

- **If that item doesn‚Äôt exist in your cart**, add the item with a starting quantity of 1.
- **If that itemdoesalready exist**, bump the quantity by 1.

- [JavaScript](#tab-panel-1914)
- [TypeScript](#tab-panel-1915)

   src/cartStore.js

```
...export function addCartItem({ id, name, imageSrc }) {  const existingEntry = cartItems.get()[id];  if (existingEntry) {    cartItems.setKey(id, {      ...existingEntry,      quantity: existingEntry.quantity + 1,    })  } else {    cartItems.setKey(      id,      { id, name, imageSrc, quantity: 1 }    );  }}
```

   src/cartStore.ts

```
...type ItemDisplayInfo = Pick<CartItem, 'id' | 'name' | 'imageSrc'>;export function addCartItem({ id, name, imageSrc }: ItemDisplayInfo) {  const existingEntry = cartItems.get()[id];  if (existingEntry) {    cartItems.setKey(id, {      ...existingEntry,      quantity: existingEntry.quantity + 1,    });  } else {    cartItems.setKey(      id,      { id, name, imageSrc, quantity: 1 }    );  }}
```

With our store in place, we can call this function inside our `AddToCartForm` whenever that form is submitted. We‚Äôll also open the cart flyout so you can see a full cart summary.

- [Preact](#tab-panel-1931)
- [React](#tab-panel-1932)
- [Solid](#tab-panel-1933)
- [Svelte](#tab-panel-1934)
- [Vue](#tab-panel-1935)

   src/components/AddToCartForm.jsx

```
import { addCartItem, isCartOpen } from '../cartStore';
export default function AddToCartForm({ children }) {  // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
  function addToCart(e) {    e.preventDefault();    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }
  return (    <form onSubmit={addToCart}>      {children}    </form>  )}
```

  src/components/AddToCartForm.jsx

```
import { addCartItem, isCartOpen } from '../cartStore';
export default function AddToCartForm({ children }) {  // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
  function addToCart(e) {    e.preventDefault();    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }
  return (    <form onSubmit={addToCart}>      {children}    </form>  )}
```

  src/components/AddToCartForm.jsx

```
import { addCartItem, isCartOpen } from '../cartStore';
export default function AddToCartForm({ children }) {  // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
  function addToCart(e) {    e.preventDefault();    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }
  return (    <form onSubmit={addToCart}>      {children}    </form>  )}
```

  src/components/AddToCartForm.svelte

```
<form on:submit|preventDefault={addToCart}>  <slot></slot></form>
<script>  import { addCartItem, isCartOpen } from '../cartStore';
  // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
  function addToCart() {    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }</script>
```

  src/components/AddToCartForm.vue

```
<template>  <form @submit="addToCart">    <slot></slot>  </form></template>
<script setup>  import { addCartItem, isCartOpen } from '../cartStore';
  // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
  function addToCart(e) {    e.preventDefault();    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }</script>
```

Finally, we‚Äôll render those cart items inside our `CartFlyout`:

- [Preact](#tab-panel-1936)
- [React](#tab-panel-1937)
- [Solid](#tab-panel-1938)
- [Svelte](#tab-panel-1939)
- [Vue](#tab-panel-1940)

   src/components/CartFlyout.jsx

```
import { useStore } from '@nanostores/preact';import { isCartOpen, cartItems } from '../cartStore';
export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);  const $cartItems = useStore(cartItems);
  return $isCartOpen ? (    <aside>      {Object.values($cartItems).length ? (        <ul>          {Object.values($cartItems).map(cartItem => (            <li>              <img src={cartItem.imageSrc} alt={cartItem.name} />              <h3>{cartItem.name}</h3>              <p>Quantity: {cartItem.quantity}</p>            </li>          ))}        </ul>      ) : <p>Your cart is empty!</p>}    </aside>  ) : null;}
```

  src/components/CartFlyout.jsx

```
import { useStore } from '@nanostores/react';import { isCartOpen, cartItems } from '../cartStore';
export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);  const $cartItems = useStore(cartItems);
  return $isCartOpen ? (    <aside>      {Object.values($cartItems).length ? (        <ul>          {Object.values($cartItems).map(cartItem => (            <li>              <img src={cartItem.imageSrc} alt={cartItem.name} />              <h3>{cartItem.name}</h3>              <p>Quantity: {cartItem.quantity}</p>            </li>          ))}        </ul>      ) : <p>Your cart is empty!</p>}    </aside>  ) : null;}
```

  src/components/CartFlyout.jsx

```
import { useStore } from '@nanostores/solid';import { isCartOpen, cartItems } from '../cartStore';
export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);  const $cartItems = useStore(cartItems);
  return $isCartOpen() ? (    <aside>      {Object.values($cartItems()).length ? (        <ul>          {Object.values($cartItems()).map(cartItem => (            <li>              <img src={cartItem.imageSrc} alt={cartItem.name} />              <h3>{cartItem.name}</h3>              <p>Quantity: {cartItem.quantity}</p>            </li>          ))}        </ul>      ) : <p>Your cart is empty!</p>}    </aside>  ) : null;}
```

  src/components/CartFlyout.svelte

```
<script>  import { isCartOpen, cartItems } from '../cartStore';</script>
{#if $isCartOpen}  {#if Object.values($cartItems).length}    <aside>      {#each Object.values($cartItems) as cartItem}      <li>        <img src={cartItem.imageSrc} alt={cartItem.name} />        <h3>{cartItem.name}</h3>        <p>Quantity: {cartItem.quantity}</p>      </li>      {/each}    </aside>  {:else}    <p>Your cart is empty!</p>  {/if}{/if}
```

  src/components/CartFlyout.vue

```
<template>  <aside v-if="$isCartOpen">    <ul v-if="Object.values($cartItems).length">      <li v-for="cartItem in Object.values($cartItems)" v-bind:key="cartItem.name">        <img :src=cartItem.imageSrc :alt=cartItem.name />        <h3>{{cartItem.name}}</h3>        <p>Quantity: {{cartItem.quantity}}</p>      </li>    </ul>    <p v-else>Your cart is empty!</p>  </aside></template>
<script setup>  import { cartItems, isCartOpen } from '../cartStore';  import { useStore } from '@nanostores/vue';
  const $isCartOpen = useStore(isCartOpen);  const $cartItems = useStore(cartItems);</script>
```

Now, you should have a fully interactive ecommerce example with the smallest JS bundle in the galaxy üöÄ

[Try the completed example](https://github.com/withastro/astro/tree/main/examples/with-nanostores) on your machine or online via StackBlitz!

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Share state between Astro components

> Learn how to share state across Astro components with Nano Stores.

# Share state between Astro components

When building an Astro website, you may need to share state across components. Astro recommends the use of [Nano Stores](https://github.com/nanostores/nanostores) for shared client storage.

## Recipe

[Section titled ‚ÄúRecipe‚Äù](#recipe)

1. Install Nano Stores:
  - [npm](#tab-panel-1941)
  - [pnpm](#tab-panel-1942)
  - [Yarn](#tab-panel-1943)
     Terminal window
  ```
  npm install nanostores
  ```
     Terminal window
  ```
  pnpm add nanostores
  ```
     Terminal window
  ```
  yarn add nanostores
  ```
2. Create a store. In this example, the store tracks whether a dialog is open or not:
   src/store.js
  ```
  import { atom } from 'nanostores';
  export const isOpen = atom(false);
  ```
3. Import and use the store in a `<script>` tag in the components that will share state.
  The following `Button` and `Dialog` components each use the shared `isOpen` state to control whether a particular `<div>` is hidden or displayed:
   src/components/Button.astro
  ```
  <button id="openDialog">Open</button>
  <script>  import { isOpen } from '../store.js';
    // Set the store to true when the button is clicked  function openDialog() {    isOpen.set(true);  }
    // Add an event listener to the button  document.getElementById('openDialog').addEventListener('click', openDialog);</script>
  ```
   src/components/Dialog.astro
  ```
  <div id="dialog" style="display: none">Hello world!</div>
  <script>  import { isOpen } from '../store.js';
    // Listen to changes in the store, and show/hide the dialog accordingly  isOpen.subscribe(open => {    if (open) {      document.getElementById('dialog').style.display = 'block';    } else {      document.getElementById('dialog').style.display = 'none';    }  })</script>
  ```

## Resources

[Section titled ‚ÄúResources‚Äù](#resources)

- [Nano Stores on NPM](https://www.npmjs.com/package/nanostores)
- [Nano Stores documentation for Vanilla JS](https://github.com/nanostores/nanostores#vanilla-js)

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Using streaming to improve page performance

> Learn how to use streaming to improve page performance.

# Using streaming to improve page performance

Astro‚Äôs SSR uses HTML streaming to send each component to the browser when available for faster page loading. To improve your page‚Äôs performance even further, you can build your components strategically to optimize their loading by avoiding blocking data fetches.

The following refactoring example demonstrates how to improve page performance by moving fetch calls to other components, moving them out of a component where they block page rendering.

The following page `await`s some data in its frontmatter. Astro will wait for all of the `fetch` calls to resolve before sending any HTML to the browser.

 src/pages/index.astro

```
---const personResponse = await fetch('https://randomuser.me/api/');const personData = await personResponse.json();const randomPerson = personData.results[0];const factResponse = await fetch('https://catfact.ninja/fact');const factData = await factResponse.json();---<html>  <head>    <title>A name and a fact</title>  </head>  <body>    <h2>A name</h2>    <p>{randomPerson.name.first}</p>    <h2>A fact</h2>    <p>{factData.fact}</p>  </body></html>
```

Moving the `await` calls into smaller components allows you to take advantage of Astro‚Äôs streaming. Using the following components to perform the data fetches, Astro can render some HTML first, such as the title, and then the paragraphs when the data is ready.

 src/components/RandomName.astro

```
---const personResponse = await fetch('https://randomuser.me/api/');const personData = await personResponse.json();const randomPerson = personData.results[0];---<p>{randomPerson.name.first}</p>
```

 src/components/RandomFact.astro

```
---const factResponse = await fetch('https://catfact.ninja/fact');const factData = await factResponse.json();---<p>{factData.fact}</p>
```

The Astro page below using these components can render parts of the page sooner. The `<head>`, `<body>`, and `<h2>` tags are no longer blocked by data fetches. The server will then fetch data for `RandomName` and `RandomFact` in parallel and stream the resulting HTML to the browser.

 src/pages/index.astro

```
---import RandomName from '../components/RandomName.astro';import RandomFact from '../components/RandomFact.astro';---<html>  <head>    <title>A name and a fact</title>  </head>  <body>    <h2>A name</h2>    <RandomName />    <h2>A fact</h2>    <RandomFact />  </body></html>
```

#### Including Promises directly

[Section titled ‚ÄúIncluding Promises directly‚Äù](#including-promises-directly)

You can also include promises directly in the template. Instead of blocking the entire component, it will resolve the promise in parallel and only block the markup that comes after it.

 src/pages/index.astro

```
---const personPromise = fetch('https://randomuser.me/api/')  .then(response => response.json())  .then(personData => personData.results[0].name.first);const factPromise = fetch('https://catfact.ninja/fact')  .then(response => response.json())  .then(factData => factData.fact);---<html>  <head>    <title>A name and a fact</title>  </head>  <body>    <h2>A name</h2>    <p>{personPromise}</p>    <h2>A fact</h2>    <p>{factPromise}</p>  </body></html>
```

In this example, `A name` will render while `personPromise` and `factPromise` are loading.
Once `personPromise` has resolved, `A fact` will appear and `factPromise` will render when it‚Äôs finished loading.

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Style rendered Markdown with Tailwind Typography

> Learn how to use @tailwind/typography to style your rendered Markdown.

# Style rendered Markdown with Tailwind Typography

You can use [Tailwind](https://tailwindcss.com)‚Äôs Typography plugin to style rendered Markdown from sources such as Astro‚Äôs [content collections](https://docs.astro.build/en/guides/content-collections/).

This recipe will teach you how to create a reusable Astro component to style your Markdown content using Tailwind‚Äôs utility classes.

## Prerequisites

[Section titled ‚ÄúPrerequisites‚Äù](#prerequisites)

An Astro project that:

- has [Tailwind‚Äôs Vite plugin](https://docs.astro.build/en/guides/styling/#tailwind) installed.
- uses Astro‚Äôs [content collections](https://docs.astro.build/en/guides/content-collections/).

## Setting Up@tailwindcss/typography

[Section titled ‚ÄúSetting Up @tailwindcss/typography‚Äù](#setting-up-tailwindcsstypography)

First, install `@tailwindcss/typography` using your preferred package manager.

- [npm](#tab-panel-1944)
- [pnpm](#tab-panel-1945)
- [Yarn](#tab-panel-1946)

   Terminal window

```
npm install -D @tailwindcss/typography
```

   Terminal window

```
pnpm add -D @tailwindcss/typography
```

   Terminal window

```
yarn add --dev @tailwindcss/typography
```

Then, add the package as a plugin in your Tailwind configuration file.

 src/styles/global.css

```
@import 'tailwindcss';@plugin '@tailwindcss/typography';
```

## Recipe

[Section titled ‚ÄúRecipe‚Äù](#recipe)

1. Create a `<Prose />` component to provide a wrapping `<div>` with a `<slot />` for your rendered Markdown. Add the style class `prose` alongside any desired [Tailwind element modifiers](https://tailwindcss.com/docs/typography-plugin#element-modifiers) in the parent element.
   src/components/Prose.astro
  ```
  ------<div  class="prose dark:prose-invert  prose-h1:font-bold prose-h1:text-xl  prose-a:text-blue-600 prose-p:text-justify prose-img:rounded-xl  prose-headings:underline">  <slot /></div>
  ```
2. Query your collection entry on the page you want to render your Markdown. Pass the `<Content />` component from `await render(entry)` to `<Prose />` as a child to wrap your Markdown content in Tailwind styles.
   src/pages/index.astro
  ```
  ---import Prose from '../components/Prose.astro';import Layout from '../layouts/Layout.astro';import { getEntry, render } from 'astro:content';
  const entry = await getEntry('collection', 'entry');const { Content } = await render(entry);---<Layout>  <Prose>    <Content />  </Prose></Layout>
  ```

## Resources

[Section titled ‚ÄúResources‚Äù](#resources)

- [Tailwind Typography Documentation](https://tailwindcss.com/docs/typography-plugin)

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Astro recipes

> Short, focused how-to guides.

# Astro recipes

See guided examples of adding features to your Astro project.

## Official Recipes

[Section titled ‚ÄúOfficial Recipes‚Äù](#official-recipes)

Astro‚Äôs official recipes are short, focused how-to guides that walk a reader through completing a working example of a specific task. Recipes are a great way to add new features or behavior to your Astro project by following step-by-step instructions!

- ### Installing a Vite or Rollup plugin
  Learn how you can import YAML data by adding a Rollup plugin to your project.
- ### Analyze bundle size
  Learn how to analyze the bundle generated by Astro using `rollup-plugin-visualizer`.
- ### Build a custom image component
  Learn how to build a custom image component that supports media queries using the getImage function.
- ### Build forms with API routes
  Learn how to use JavaScript to send form submissions to an API Route.
- ### Build HTML forms in Astro pages
  Learn how to build HTML forms and handle submissions in your frontmatter.
- ### Use Bun with Astro
  Learn how to use Bun with your Astro site.
- ### Call endpoints from the server
  Learn how to call endpoints from the server in Astro.
- ### Verify a Captcha
  Learn how to create an API route and fetch it from the client.
- ### Customize file names in the build output
  Learn how to change the default naming pattern for your built assets like JavaScript, CSS, and images in Astro using Vite's Rollup options.
- ### Build your Astro site with Docker
  Learn how to build your Astro site using Docker.
- ### Dynamically import images
  Learn how to dynamically import images using Vite's import.meta.glob function.
- ### Add icons to external links
  Learn how to install a rehype plugin to add icons to external links in your Markdown files.
- ### Add i18n features
  Use dynamic routing and content collections to add internationalization support to your Astro site.
- ### Create a dev toolbar app
  Learn how to create a dev toolbar app for your site.
- ### Add last modified time
  Build a remark plugin to add the last modified time to your Markdown and MDX.
- ### Add reading time
  Build a remark plugin to add reading time to your Markdown or MDX files.
- ### Add an RSS feed
  Add an RSS feed to your Astro site to let users subscribe to your content.
- ### Share state between islands
  Learn how to share state across framework components with Nano Stores.
- ### Share state between Astro components
  Learn how to share state across Astro components with Nano Stores.
- ### Style rendered Markdown with Tailwind Typography
  Learn how to use @tailwind/typography to style your rendered Markdown.
- ### Using streaming to improve page performance
  Learn how to use streaming to improve page performance.

## Community Resources

[Section titled ‚ÄúCommunity Resources‚Äù](#community-resources)   Find more recipes written and submitted by the community at [Astro Tips](https://astro-tips.dev).  Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
