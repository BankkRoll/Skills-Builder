# Install Astro and more

# Install Astro

> How to install Astro and start a new project.

# Install Astro

The [create astroCLI command](#install-from-the-cli-wizard) is the fastest way to start a new Astro project from scratch. It will walk you through every step of setting up your new Astro project and allow you to choose from a few different official starter templates.

You can also run the CLI command with the `template` flag to begin your project using any existing theme or starter template. Explore our [themes and starters showcase](https://astro.build/themes/) where you can browse themes for blogs, portfolios, documentation sites, landing pages, and more!

To install Astro manually instead, see our [step-by-step manual installation guide](#manual-setup).

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

- **Node.js** - `v18.20.8` or `v20.3.0`, `v22.0.0` or higher. (`v19` and `v21` are not supported.)
- **Text editor** - We recommend [VS Code](https://code.visualstudio.com/) with our [Official Astro extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode).
- **Terminal** - Astro is accessed through its command-line interface (CLI).

## Browser compatibility

[Section titled “Browser compatibility”](#browser-compatibility)

Astro is built with Vite which targets browsers with modern JavaScript support by default. For a complete reference, you can see the [list of currently supported browser versions in Vite](https://vite.dev/guide/build.html#browser-compatibility).

## Install from the CLI wizard

[Section titled “Install from the CLI wizard”](#install-from-the-cli-wizard)

You can run `create astro` anywhere on your machine, so there’s no need to create a new empty directory for your project before you begin. If you don’t have an empty directory yet for your new project, the wizard will help create one for you automatically.

1. Run the following command in your terminal to start the install wizard:
  - [npm](#tab-panel-1407)
  - [pnpm](#tab-panel-1408)
  - [Yarn](#tab-panel-1409)
     Terminal window
  ```
  # create a new project with npmnpm create astro@latest
  ```
     Terminal window
  ```
  # create a new project with pnpmpnpm create astro@latest
  ```
     Terminal window
  ```
  # create a new project with yarnyarn create astro
  ```
  If all goes well, you will see a success message followed by some recommended next steps.
2. Now that your project has been created, you can `cd` into your new project directory to begin using Astro.
3. If you skipped the “Install dependencies?” step during the CLI wizard, then be sure to install your dependencies before continuing.
  - [npm](#tab-panel-1410)
  - [pnpm](#tab-panel-1411)
  - [Yarn](#tab-panel-1412)
     Terminal window
  ```
  npm install
  ```
     Terminal window
  ```
  pnpm install
  ```
     Terminal window
  ```
  yarn install
  ```
4. You can now [start the Astro dev server](https://docs.astro.build/en/develop-and-build/#start-the-astro-dev-server) and see a live preview of your project while you build!

## CLI installation flags

[Section titled “CLI installation flags”](#cli-installation-flags)

You can run the `create astro` command with additional flags to customize the setup process (e.g. answering “yes” to all questions, skipping the Houston animation) or your new project (e.g. install git or not, add integrations).

   See [all the availablecreate astrocommand flags](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md).

### Add integrations

[Section titled “Add integrations”](#add-integrations)

You can start a new Astro project and install any [official integrations](https://docs.astro.build/en/guides/integrations-guide/) or community integrations that support the `astro add` command at the same time by passing the `--add` argument to the `create astro` command.

Run the following command in your terminal, substituting any integration that supports the `astro add` command:

- [npm](#tab-panel-1413)
- [pnpm](#tab-panel-1414)
- [Yarn](#tab-panel-1415)

   Terminal window

```
# create a new project with React and Partytownnpm create astro@latest -- --add react --add partytown
```

   Terminal window

```
# create a new project with React and Partytownpnpm create astro@latest --add react --add partytown
```

   Terminal window

```
# create a new project with React and Partytownyarn create astro --add react --add partytown
```

### Use a theme or starter template

[Section titled “Use a theme or starter template”](#use-a-theme-or-starter-template)

You can start a new Astro project based on an [official example](https://github.com/withastro/astro/tree/main/examples) or the `main` branch of any GitHub repository by passing a `--template` argument to the `create astro` command.

Run the following command in your terminal, substituting the official Astro starter template name, or the GitHub username and repository of the theme you want to use:

- [npm](#tab-panel-1416)
- [pnpm](#tab-panel-1417)
- [Yarn](#tab-panel-1418)

   Terminal window

```
# create a new project with an official examplenpm create astro@latest -- --template <example-name>
# create a new project based on a GitHub repository’s main branchnpm create astro@latest -- --template <github-username>/<github-repo>
```

   Terminal window

```
# create a new project with an official examplepnpm create astro@latest --template <example-name>
# create a new project based on a GitHub repository’s main branchpnpm create astro@latest --template <github-username>/<github-repo>
```

   Terminal window

```
# create a new project with an official exampleyarn create astro --template <example-name>
# create a new project based on a GitHub repository’s main branchyarn create astro --template <github-username>/<github-repo>
```

By default, this command will use the template repository’s `main` branch. To use a different branch name, pass it as part of the `--template` argument: `<github-username>/<github-repo>#<branch>`.

## Manual Setup

[Section titled “Manual Setup”](#manual-setup)

This guide will walk you through the steps to manually install and configure a new Astro project.

If you prefer not to use our automatic `create astro` CLI tool, you can set up your project yourself by following the guide below.

1. Create your directory
  Create an empty directory with the name of your project, and then navigate into it.
   Terminal window
  ```
  mkdir my-astro-projectcd my-astro-project
  ```
  Once you are in your new directory, create your project `package.json` file. This is how you will manage your project dependencies, including Astro. If you aren’t familiar with this file format, run the following command to create one.
  - [npm](#tab-panel-1419)
  - [pnpm](#tab-panel-1420)
  - [Yarn](#tab-panel-1421)
     Terminal window
  ```
  npm init --yes
  ```
     Terminal window
  ```
  pnpm init
  ```
     Terminal window
  ```
  yarn init --yes
  ```
2. Install Astro
  First, install the Astro project dependencies inside your project.
  - [npm](#tab-panel-1422)
  - [pnpm](#tab-panel-1423)
  - [Yarn](#tab-panel-1424)
     Terminal window
  ```
  npm install astro
  ```
     Terminal window
  ```
  pnpm add astro
  ```
     Terminal window
  ```
  yarn add astro
  ```
  Then, replace any placeholder “scripts” section of your `package.json` with the following:
   package.json
  ```
  {  "scripts": {    "test": "echo \"Error: no test specified\" && exit 1",    "dev": "astro dev",    "build": "astro build",    "preview": "astro preview"  },}
  ```
  You’ll use these scripts later in the guide to start Astro and run its different commands.
3. Create your first page
  In your text editor, create a new file in your directory at `src/pages/index.astro`. This will be your first Astro page in the project.
  For this guide, copy and paste the following code snippet (including `---` dashes) into your new file:
   src/pages/index.astro
  ```
  ---// Welcome to Astro! Everything between these triple-dash code fences// is your "component frontmatter". It never runs in the browser.console.log('This runs in your terminal, not the browser!');---<html>  <body>    <h1>Hello, World!</h1>  </body></html><style>  h1 {    color: orange;  }</style>
  ```
4. Create your first static asset
  You will also want to create a `public/` directory to store your static assets. Astro will always include these assets in your final build, so you can safely reference them from inside your component templates.
  In your text editor, create a new file in your directory at `public/robots.txt`. `robots.txt` is a simple file that most sites will include to tell search bots like Google how to treat your site.
  For this guide, copy and paste the following code snippet into your new file:
   public/robots.txt
  ```
  # Example: Allow all bots to scan and index your site.# Full syntax: https://developers.google.com/search/docs/advanced/robots/create-robots-txtUser-agent: *Allow: /
  ```
5. Create `astro.config.mjs`
  Astro is configured using `astro.config.mjs`. This file is optional if you do not need to configure Astro, but you may wish to create it now.
  Create `astro.config.mjs` at the root of your project, and copy the code below into it:
   astro.config.mjs
  ```
  import { defineConfig } from "astro/config";
  // https://astro.build/configexport default defineConfig({});
  ```
  If you want to include [UI framework components](https://docs.astro.build/en/guides/framework-components/) such as React, Svelte, etc. or use other tools such as MDX or Partytown in your project, here is where you will [manually import and configure integrations](https://docs.astro.build/en/guides/integrations-guide/).
     Read Astro’s [API configuration reference](https://docs.astro.build/en/reference/configuration-reference/) for more information.
6. Add TypeScript support
  TypeScript is configured using `tsconfig.json`. Even if you don’t write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren’t fully supported in the editor without a `tsconfig.json` file.
  If you do intend to write TypeScript code, using Astro’s `strict` or `strictest` template is recommended. You can view and compare the three template configurations at [astro/tsconfigs/](https://github.com/withastro/astro/blob/main/packages/astro/tsconfigs/).
  Create `tsconfig.json` at the root of your project, and copy the code below into it. (You can use `base`, `strict`, or `strictest` for your TypeScript template):
   tsconfig.json
  ```
  {  "extends": "astro/tsconfigs/base"}
  ```
     Read Astro’s [TypeScript setup guide](https://docs.astro.build/en/guides/typescript/#setup) for more information.
7. Next Steps
  If you have followed the steps above, your project directory should now look like this:
  - Directorynode_modules/
    - …
  - Directorypublic/
    - robots.txt
  - Directorysrc/
    - Directorypages/
      - index.astro
  - astro.config.mjs
  - package-lock.json or `yarn.lock`, `pnpm-lock.yaml`, etc.
  - package.json
  - tsconfig.json
8. You can now [start the Astro dev server](https://docs.astro.build/en/develop-and-build/#start-the-astro-dev-server) and see a live preview of your project while you build!

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Installing a Vite or Rollup plugin

> Learn how you can import YAML data by adding a Rollup plugin to your project.

# Installing a Vite or Rollup plugin

Astro builds on top of Vite, and supports both Vite and Rollup plugins. This recipe uses a Rollup plugin to add the ability to import a YAML (`.yml`) file in Astro.

## Recipe

[Section titled “Recipe”](#recipe)

1. Install `@rollup/plugin-yaml`:
  - [npm](#tab-panel-1863)
  - [pnpm](#tab-panel-1864)
  - [Yarn](#tab-panel-1865)
     Terminal window
  ```
  npm install @rollup/plugin-yaml --save-dev
  ```
     Terminal window
  ```
  pnpm add @rollup/plugin-yaml --save-dev
  ```
     Terminal window
  ```
  yarn add @rollup/plugin-yaml --dev
  ```
2. Import the plugin in your `astro.config.mjs` and add it to the Vite plugins array:
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';import yaml from '@rollup/plugin-yaml';
  export default defineConfig({  vite: {    plugins: [yaml()]  }});
  ```
3. Finally, you can import YAML data using an `import` statement:
  ```
  import yml from './data.yml';
  ```

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Analyze bundle size

> Learn how to analyze the bundle generated by Astro using `rollup-plugin-visualizer`.

# Analyze bundle size

Understanding what is a part of an Astro bundle is important for improving site performance. Visualizing the bundle can give clues as to where changes can be made in your project to reduce the bundle size.

## Recipe

[Section titled “Recipe”](#recipe)

The [rollup-plugin-visualizerlibrary](https://github.com/btd/rollup-plugin-visualizer) allows you to visualize and analyze your Rollup bundle to see which modules are taking up space.

1. Install `rollup-plugin-visualizer`:
  - [npm](#tab-panel-1866)
  - [pnpm](#tab-panel-1867)
  - [Yarn](#tab-panel-1868)
     Terminal window
  ```
  npm install rollup-plugin-visualizer --save-dev
  ```
     Terminal window
  ```
  pnpm add rollup-plugin-visualizer --save-dev
  ```
     Terminal window
  ```
  yarn add rollup-plugin-visualizer --save-dev
  ```
2. Add the plugin to the `astro.config.mjs` file:
  ```
  // @ts-checkimport { defineConfig } from 'astro/config';import { visualizer } from "rollup-plugin-visualizer";
  export default defineConfig({vite: {    plugins: [visualizer({        emitFile: true,        filename: "stats.html",    })]}});
  ```
3. Run the build command:
  - [npm](#tab-panel-1869)
  - [pnpm](#tab-panel-1870)
  - [Yarn](#tab-panel-1871)
     Terminal window
  ```
  npm run build
  ```
     Terminal window
  ```
  pnpm build
  ```
     Terminal window
  ```
  yarn build
  ```
4. Find the `stats.html` file(s) for your project.
  This will be at the root of your `dist/` directory for entirely static sites and will allow you to see what is included in the bundle.
  If your Astro project uses on-demand rendering, you will have two `stats.html` files. One will be for the client, and the other for the server, and each will be located at the root of the `dist/client` and `dist/server/` directories.
  See [the Rollup Plugin Visualizer documentation](https://github.com/btd/rollup-plugin-visualizer#how-to-use-generated-files) for guidance on how to interpret these files, or configure specific options.

  Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Build a custom image component

> Learn how to build a custom image component that supports media queries using the getImage function.

# Build a custom image component

Astro provides two built-in components that you can use to display and optimize your images.  The `<Picture>` component allows you to display responsive images and work with different formats and sizes. The `<Image>` component will optimize your images and allow you to pass in different formats and quality properties.

When you need options that the `<Picture>` and `<Image>` components do not currently support, you can use the `getImage()` function to create a custom component.

In this recipe, you will use the [getImage()function](https://docs.astro.build/en/guides/images/#generating-images-with-getimage) to create your own custom image component that displays different source images based on media queries.

## Recipe

[Section titled “Recipe”](#recipe)

1. Create a new Astro component and import the `getImage()` function
   src/components/MyCustomImageComponent.astro
  ```
  --- import { getImage } from "astro:assets";---
  ```
2. Create a new component for your custom image. `MyCustomComponent.astro` will receive three `props` from `Astro.props`. The `mobileImgUrl` and `desktopImgUrl` props are used for creating your image at different viewport sizes. The `alt` prop is used for the image’s alt text. These props will be passed wherever you render your custom image components. Add the following imports and define the props that you will use in your component. You can also use TypeScript to type the props.
   src/components/MyCustomImageComponent.astro
  ```
  ---import type { ImageMetadata } from "astro";import { getImage } from "astro:assets";
  interface Props {    mobileImgUrl: string | ImageMetadata;    desktopImgUrl: string | ImageMetadata;    alt: string;}
  const { mobileImgUrl, desktopImgUrl, alt } = Astro.props;---
  ```
3. Define each of your responsive images by calling the `getImage()` function with your desired properties.
   src/components/MyCustomImageComponent.astro
  ```
  ---import type { ImageMetadata } from "astro";import { getImage } from "astro:assets";
  interface Props {    mobileImgUrl: string | ImageMetadata;    desktopImgUrl: string | ImageMetadata;    alt: string;}
  const { mobileImgUrl, desktopImgUrl, alt } = Astro.props;
  const mobileImg = await getImage({    src: mobileImgUrl,    format: "webp",    width: 200,    height: 200,});
  const desktopImg = await getImage({    src: desktopImgUrl,    format: "webp",    width: 800,    height: 200,});---
  ```
4. Create a `<picture>` element that generates a `srcset` with your different images based on your desired media queries.
   src/components/MyCustomImageComponent.astro
  ```
  ---import type { ImageMetadata } from "astro";import { getImage } from "astro:assets";
  interface Props {    mobileImgUrl: string | ImageMetadata;    desktopImgUrl: string | ImageMetadata;    alt: string;}
  const { mobileImgUrl, desktopImgUrl, alt } = Astro.props;
  const mobileImg = await getImage({    src: mobileImgUrl,    format: "webp",    width: 200,    height: 200,});
  const desktopImg = await getImage({    src: desktopImgUrl,    format: "webp",    width: 800,    height: 200,});---
  <picture>    <source media="(max-width: 799px)" srcset={mobileImg.src} />    <source media="(min-width: 800px)" srcset={desktopImg.src} />    <img src={desktopImg.src} alt={alt} /></picture>
  ```
5. Import and use `<MyCustomImageComponent />` in any `.astro` file. Be sure to pass the necessary props for generating two different images at the different viewport sizes:
   src/pages/index.astro
  ```
  ---import MyCustomImageComponent from "../components/MyCustomImageComponent.astro";import mobileImage from "../images/mobile-profile-image.jpg";import desktopImage from "../images/desktop-profile-image.jpg";---
  <MyCustomImageComponent    mobileImgUrl={mobileImage}    desktopImgUrl={desktopImage}    alt="user profile picture"/>
  ```

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Build forms with API routes

> Learn how to use JavaScript to send form submissions to an API Route.

# Build forms with API routes

An HTML form causes the browser to refresh the page or navigate to a new one. To send form data to an API endpoint instead, you must intercept the form submission using JavaScript.

This recipe shows you how to send form data to an API endpoint and handle that data.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

- A project with [an adapter for on-demand rendering](https://docs.astro.build/en/guides/on-demand-rendering/)
- A [UI Framework integration](https://docs.astro.build/en/guides/framework-components/) installed

## Recipe

[Section titled “Recipe”](#recipe)

1. Create a `POST` API endpoint at `/api/feedback` that will receive the form data. Use `request.formData()` to process it. Be sure to validate the form values before you use them.
  This example sends a JSON object with a message back to the client.
   src/pages/api/feedback.ts
  ```
  export const prerender = false; // Not needed in 'server' modeimport type { APIRoute } from "astro";
  export const POST: APIRoute = async ({ request }) => {  const data = await request.formData();  const name = data.get("name");  const email = data.get("email");  const message = data.get("message");  // Validate the data - you'll probably want to do more than this  if (!name || !email || !message) {    return new Response(      JSON.stringify({        message: "Missing required fields",      }),      { status: 400 }    );  }  // Do something with the data, then return a success response  return new Response(    JSON.stringify({      message: "Success!"    }),    { status: 200 }  );};
  ```
2. Create a form component using your UI framework. Each input should have a `name` attribute that describes the value of that input.
  Be sure to include a `<button>` or `<input type="submit">` element to submit the form.
  - [Preact](#tab-panel-1872)
  - [React](#tab-panel-1873)
  - [Solid](#tab-panel-1874)
  - [Svelte](#tab-panel-1875)
  - [Vue](#tab-panel-1876)
     src/components/FeedbackForm.tsx
  ```
  export default function Form() {  return (    <form>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>    </form>  );}
  ```
    src/components/FeedbackForm.tsx
  ```
  export default function Form() {  return (    <form>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>    </form>  );}
  ```
    src/components/FeedbackForm.tsx
  ```
  export default function Form() {  return (    <form>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>    </form>  );}
  ```
    src/components/FeedbackForm.svelte
  ```
  <form>  <label>    Name    <input type="text" id="name" name="name" required />  </label>  <label>    Email    <input type="email" id="email" name="email" required />  </label>  <label>    Message    <textarea id="message" name="message" required />  </label>  <button>Send</button></form>
  ```
    src/components/FeedbackForm.vue
  ```
  <template>  <form>    <label>      Name      <input type="text" id="name" name="name" required />    </label>    <label>      Email      <input type="email" id="email" name="email" required />    </label>    <label>      Message      <textarea id="message" name="message" required />    </label>    <button>Send</button>  </form></template>
  ```
3. Create a function that accepts a submit event, then pass it as a `submit` handler to your form.
  In the function:
  - Call `preventDefault()` on the event to override the browser’s default submission process.
  - Create a `FormData` object and send it in a `POST` request to your endpoint using `fetch()`.
  - [Preact](#tab-panel-1877)
  - [React](#tab-panel-1878)
  - [Solid](#tab-panel-1879)
  - [Svelte](#tab-panel-1880)
  - [Vue](#tab-panel-1881)
     src/components/FeedbackForm.tsx
  ```
  import { useState } from "preact/hooks";
  export default function Form() {  const [responseMessage, setResponseMessage] = useState("");
    async function submit(e: SubmitEvent) {    e.preventDefault();    const formData = new FormData(e.target as HTMLFormElement);    const response = await fetch("/api/feedback", {      method: "POST",      body: formData,    });    const data = await response.json();    if (data.message) {      setResponseMessage(data.message);    }  }
    return (    <form onSubmit={submit}>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>      {responseMessage && <p>{responseMessage}</p>}    </form>  );}
  ```
    src/components/FeedbackForm.tsx
  ```
  import { useState } from "react";import type { FormEvent } from "react";
  export default function Form() {  const [responseMessage, setResponseMessage] = useState("");
    async function submit(e: FormEvent<HTMLFormElement>) {    e.preventDefault();    const formData = new FormData(e.target as HTMLFormElement);    const response = await fetch("/api/feedback", {      method: "POST",      body: formData,    });    const data = await response.json();    if (data.message) {      setResponseMessage(data.message);    }  }
    return (    <form onSubmit={submit}>      <label htmlFor="name">        Name        <input type="text" id="name" name="name" autoComplete="name" required />      </label>      <label htmlFor="email">        Email        <input type="email" id="email" name="email" autoComplete="email" required />      </label>      <label htmlFor="message">        Message        <textarea id="message" name="message" autoComplete="off" required />      </label>      <button>Send</button>      {responseMessage && <p>{responseMessage}</p>}    </form>  );}
  ```
    src/components/FeedbackForm.tsx
  ```
  import { createSignal, createResource, Suspense } from "solid-js";
  async function postFormData(formData: FormData) {  const response = await fetch("/api/feedback", {    method: "POST",    body: formData,  });  const data = await response.json();  return data;}
  export default function Form() {  const [formData, setFormData] = createSignal<FormData>();  const [response] = createResource(formData, postFormData);
    function submit(e: SubmitEvent) {    e.preventDefault();    setFormData(new FormData(e.target as HTMLFormElement));  }
    return (    <form onSubmit={submit}>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>      <Suspense>{response() && <p>{response().message}</p>}</Suspense>    </form>  );}
  ```
    src/components/FeedbackForm.svelte
  ```
  <script lang="ts">  let responseMessage: string;
    async function submit(e: SubmitEvent) {    e.preventDefault();    const formData = new FormData(e.currentTarget as HTMLFormElement);    const response = await fetch("/api/feedback", {      method: "POST",      body: formData,    });    const data = await response.json();    responseMessage = data.message;  }</script>
  <form on:submit={submit}>  <label>    Name    <input type="text" id="name" name="name" required />  </label>  <label>    Email    <input type="email" id="email" name="email" required />  </label>  <label>    Message    <textarea id="message" name="message" required />  </label>  <button>Send</button>  {#if responseMessage}    <p>{responseMessage}</p>  {/if}</form>
  ```
    src/components/FeedbackForm.vue
  ```
  <script setup lang="ts">import { ref } from "vue";
  const responseMessage = ref<string>();
  async function submit(e: Event) {  e.preventDefault();  const formData = new FormData(e.currentTarget as HTMLFormElement);  const response = await fetch("/api/feedback", {    method: "POST",    body: formData,  });  const data = await response.json();  responseMessage.value = data.message;}</script>
  <template>  <form @submit="submit">    <label>      Name      <input type="text" id="name" name="name" required />    </label>    <label>      Email      <input type="email" id="email" name="email" required />    </label>    <label>      Message      <textarea id="message" name="message" required />    </label>    <button>Send</button>    <p v-if="responseMessage">{{ responseMessage }}</p>  </form></template>
  ```
4. Import and include your `<FeedbackForm />` component on a page. Be sure to use a `client:*` directive to ensure that the form logic is hydrated when you want it to be.
  - [Preact](#tab-panel-1882)
  - [React](#tab-panel-1883)
  - [Solid](#tab-panel-1884)
  - [Svelte](#tab-panel-1885)
  - [Vue](#tab-panel-1886)
     src/pages/index.astro
  ```
  ---import FeedbackForm from "../components/FeedbackForm"---<FeedbackForm client:load />
  ```
    src/pages/index.astro
  ```
  ---import FeedbackForm from "../components/FeedbackForm"---<FeedbackForm client:load />
  ```
    src/pages/index.astro
  ```
  ---import FeedbackForm from "../components/FeedbackForm"---<FeedbackForm client:load />
  ```
    src/pages/index.astro
  ```
  ---import FeedbackForm from "../components/FeedbackForm.svelte"---<FeedbackForm client:load />
  ```
    src/pages/index.astro
  ```
  ---import FeedbackForm from "../components/FeedbackForm.vue"---<FeedbackForm client:load />
  ```

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Build HTML forms in Astro pages

> Learn how to build HTML forms and handle submissions in your frontmatter.

# Build HTML forms in Astro pages

Astro pages that are rendered on demand can both display and handle forms. In this recipe, you’ll use a standard HTML form to submit data to the server. Your frontmatter script will handle the data on the server, sending no JavaScript to the client.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

- An Astro project with a [server adapter](https://docs.astro.build/en/guides/on-demand-rendering/#server-adapters) installed.

## Recipe

[Section titled “Recipe”](#recipe)

1. Create or identify a `.astro` page which will contain your form and your handling code. For example, you could add a registration page:
   src/pages/register.astro
  ```
  ------<h1>Register</h1>
  ```
2. Add a `<form>` tag with some inputs to the page. Each input should have a `name` attribute that describes the value of that input.
  Be sure to include a `<button>` or `<input type="submit">` element to submit the form.
   src/pages/register.astro
  ```
  ------<h1>Register</h1><form>  <label>    Username:    <input type="text" name="username" />  </label>  <label>    Email:    <input type="email" name="email" />  </label>  <label>    Password:    <input type="password" name="password" />  </label>  <button>Submit</button></form>
  ```
3. Use [validation attributes](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#using_built-in_form_validation) to provide basic client-side validation that works even if JavaScript is disabled.
  In this example,
  - `required` prevents form submission until the field is filled.
  - `minlength` sets a minimum required length for the input text.
  - `type="email"` also introduces validation that will only accept a valid email format.
   src/pages/register.astro
  ```
  ------<h1>Register</h1><form>  <label>    Username:    <input type="text" name="username" required />  </label>  <label>    Email:    <input type="email" name="email" required />  </label>  <label>    Password:    <input type="password" name="password" required minlength="6" />  </label>  <button>Submit</button></form>
  ```
4. The form submission will cause the browser to request the page again. Change the form’s data transfer `method` to `POST` to send the form data as part of the `Request` body, rather than as URL parameters.
   src/pages/register.astro
  ```
  ------<h1>Register</h1><form method="POST">  <label>    Username:    <input type="text" name="username" required />  </label>  <label>    Email:    <input type="email" name="email" required />  </label>  <label>    Password:    <input type="password" name="password" required minlength="6" />  </label>  <button>Submit</button></form>
  ```
5. Check for the `POST` method in the frontmatter and access the form data using `Astro.request.formData()`. Wrap this in a `try ... catch` block to handle cases when the `POST` request wasn’t sent by a form and the `formData` is invalid.
   src/pages/register.astro
  ```
  ---export const prerender = false; // Not needed in 'server' mode
  if (Astro.request.method === "POST") {  try {    const data = await Astro.request.formData();    const name = data.get("username");    const email = data.get("email");    const password = data.get("password");    // Do something with the data  } catch (error) {    if (error instanceof Error) {      console.error(error.message);    }  }}---<h1>Register</h1><form method="POST">  <label>    Username:    <input type="text" name="username" required />  </label>  <label>    Email:    <input type="email" name="email" required />  </label>  <label>    Password:    <input type="password" name="password" required minlength="6" />  </label>  <button>Submit</button></form>
  ```
6. Validate the form data on the server. This should include the same validation done on the client to prevent malicious submissions to your endpoint and to support the rare legacy browser that doesn’t have form validation.
  It can also include validation that can’t be done on the client. For example, this example checks if the email is already in the database.
  Error messages can be sent back to the client by storing them in an `errors` object and accessing it in the template.
   src/pages/register.astro
  ```
  ---export const prerender = false; // Not needed in 'server' mode
  import { isRegistered, registerUser } from "../../data/users"import { isValidEmail } from "../../utils/isValidEmail";
  const errors = { username: "", email: "", password: "" };if (Astro.request.method === "POST") {  try {    const data = await Astro.request.formData();    const name = data.get("username");    const email = data.get("email");    const password = data.get("password");    if (typeof name !== "string" || name.length < 1) {      errors.username += "Please enter a username. ";    }    if (typeof email !== "string" || !isValidEmail(email)) {      errors.email += "Email is not valid. ";    } else if (await isRegistered(email)) {      errors.email += "Email is already registered. ";    }    if (typeof password !== "string" || password.length < 6) {      errors.password += "Password must be at least 6 characters. ";    }    const hasErrors = Object.values(errors).some(msg => msg)    if (!hasErrors) {      await registerUser({name, email, password});      return Astro.redirect("/login");    }  } catch (error) {    if (error instanceof Error) {      console.error(error.message);    }  }}---<h1>Register</h1><form method="POST">  <label>    Username:    <input type="text" name="username" />  </label>  {errors.username && <p>{errors.username}</p>}  <label>    Email:    <input type="email" name="email" required />  </label>  {errors.email && <p>{errors.email}</p>}  <label>    Password:    <input type="password" name="password" required minlength="6" />  </label>  {errors.password && <p>{errors.password}</p>}  <button>Register</button></form>
  ```

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Use Bun with Astro

> Learn how to use Bun with your Astro site.

# Use Bun with Astro

[Bun](https://bun.sh/) is an all-in-one JavaScript runtime & toolkit. See [Bun’s documentation](https://bun.sh/docs) for more information.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

- Bun installed locally on your machine. See the [installation instructions](https://bun.sh/docs/installation) in Bun’s official documentation.

## Create a new Astro project with Bun

[Section titled “Create a new Astro project with Bun”](#create-a-new-astro-project-with-bun)

Create a new Astro project with Bun using the following `create-astro` command:

 Terminal window

```
bun create astro my-astro-project-using-bun
```

## Install dependencies

[Section titled “Install dependencies”](#install-dependencies)

If you skipped the “Install dependencies?” step during the CLI wizard, then be sure to install your dependencies before continuing.

 Terminal window

```
bun install
```

## Add Types

[Section titled “Add Types”](#add-types)

Bun publishes the [@types/bun](https://www.npmjs.com/package/@types/bun) package, containing the runtime types for Bun.

Install `@types/bun` using the following command:

 Terminal window

```
bun add -d @types/bun
```

## CLI installation flags

[Section titled “CLI installation flags”](#cli-installation-flags)

### Using integrations

[Section titled “Using integrations”](#using-integrations)

You can also use any of the official Astro integrations with the `astro add` command:

 Terminal window

```
bun astro add react
```

### Use a theme or starter template

[Section titled “Use a theme or starter template”](#use-a-theme-or-starter-template)

You can start a new Astro project based on an [official example](https://github.com/withastro/astro/tree/main/examples) or the main branch of any GitHub repository by passing a `--template` argument to the `create astro` command.

Run the following command in your terminal, substituting the official Astro starter template name, or the GitHub username and repository of the theme you want to use:

 Terminal window

```
# create a new project with an official examplebun create astro@latest --template <example-name># create a new project based on a GitHub repository’s main branchbun create astro@latest --template <github-username>/<github-repo>
```

## Develop and build

[Section titled “Develop and build”](#develop-and-build)

To run the development server, use following command:

 Terminal window

```
bun run dev
```

### Build and preview your site

[Section titled “Build and preview your site”](#build-and-preview-your-site)

To build your site, use the following command:

 Terminal window

```
bun run build
```

When the build is finished, run the appropriate preview command (e.g. `bun run preview`) in your terminal and you can view the built version of your site locally in the same browser preview window.

## Testing

[Section titled “Testing”](#testing)

Bun ships with a fast, built-in, Jest-compatible test runner through the [bun testcommand](https://bun.sh/docs/cli/test). You can also use any other [testing tools for Astro](https://docs.astro.build/en/guides/testing/).

## Official Resources

[Section titled “Official Resources”](#official-resources)

- [Build an app with Astro and Bun](https://bun.sh/guides/ecosystem/astro)

## Community Resources

[Section titled “Community Resources”](#community-resources)

Using Bun with Astro? Add your blog post or video to this page!

- [Using Bun with Astro and Cloudflare Pages](https://handerson.hashnode.dev/using-bun-with-astro-and-cloudflare-pages) - blog post

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Call endpoints from the server

> Learn how to call endpoints from the server in Astro.

# Call endpoints from the server

Endpoints can be used to serve many kinds of data. This recipe calls a server endpoint from a page’s component script to display a greeting, without requiring an additional fetch request.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

- A project with [SSR](https://docs.astro.build/en/guides/on-demand-rendering/) (output: ‘server’) enabled

## Recipe

[Section titled “Recipe”](#recipe)

1. Create an endpoint in a new file `src/pages/api/hello.ts` that returns some data:
   src/pages/api/hello.ts
  ```
  import type { APIRoute } from 'astro'
  export const GET: APIRoute = () => {  return new Response(    JSON.stringify({      greeting: 'Hello',    }),  )}
  ```
2. On any Astro page, import the `GET()` method from the endpoint. Call it with the [Astroglobal](https://docs.astro.build/en/reference/api-reference/) to provide the request context, and use the response on the page:
   src/pages/index.astro
  ```
  ---import { GET } from './api/hello.ts'
  let response = await GET(Astro)const data = await response.json()---
  <h1>{data.greeting} world!</h1>
  ```

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Verify a Captcha

> Learn how to create an API route and fetch it from the client.

# Verify a Captcha

[Server endpoints](https://docs.astro.build/en/guides/endpoints/#server-endpoints-api-routes) can be used as REST API endpoints to run functions such as authentications, database access, and verifications without exposing sensitive data to the client.

In this recipe, an API route is used to verify Google reCAPTCHA v3 without exposing the secret to clients.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

- A project with [SSR](https://docs.astro.build/en/guides/on-demand-rendering/) (`output: 'server'`) enabled

## Recipe

[Section titled “Recipe”](#recipe)

1. Create a `POST` endpoint that accepts recaptcha data, then verifies it with reCAPTCHA’s API. Here, you can safely define secret values or read environment variables.
   src/pages/recaptcha.js
  ```
  export async function POST({ request }) {  const data = await request.json();
    const recaptchaURL = 'https://www.google.com/recaptcha/api/siteverify';  const requestHeaders = {    'Content-Type': 'application/x-www-form-urlencoded'  };  const requestBody = new URLSearchParams({    secret: "YOUR_SITE_SECRET_KEY",   // This can be an environment variable    response: data.recaptcha          // The token passed in from the client  });
    const response = await fetch(recaptchaURL, {    method: "POST",    headers: requestHeaders,    body: requestBody.toString()  });
    const responseData = await response.json();
    return new Response(JSON.stringify(responseData), { status: 200 });}
  ```
2. Access your endpoint using `fetch` from a client script:
   src/pages/index.astro
  ```
  <html>  <head>    <script is:inline src="https://www.google.com/recaptcha/api.js"></script>  </head>
    <body>    <button class="g-recaptcha"      data-sitekey="PUBLIC_SITE_KEY"      data-callback="onSubmit"      data-action="submit"> Click me to verify the captcha challenge! </button>
      <script is:inline>      function onSubmit(token) {        fetch("/recaptcha", {          method: "POST",          body: JSON.stringify({ recaptcha: token })        })        .then((response) => response.json())        .then((gResponse) => {          if (gResponse.success) {            // Captcha verification was a success          } else {            // Captcha verification failed          }        })      }    </script>  </body></html>
  ```

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Customize file names in the build output

> Learn how to change the default naming pattern for your built assets like JavaScript, CSS, and images in Astro using Vite's Rollup options.

# Customize file names in the build output

By default, the `astro build` command outputs your built assets from [your project source](https://docs.astro.build/en/basics/project-structure/#src), like JavaScript and CSS files located in the `src/` directory, into an `_astro` directory with hashed filenames (e.g. `_astro/index.DRf8L97S.js`) which are excellent for long-term caching.

Although it is normally not necessary, you can customise the output file names when needed. For example, this can be helpful if you have scripts with names that might trigger ad blockers (e.g. `ads.js`), or if you want to organize your assets with a particular naming convention. By customizing Rollup output options, you can gain more control over your project’s build structure, allowing you to meet specific organizational or deployment requirements.

## Recipe

[Section titled “Recipe”](#recipe)

This recipe configures `vite.build.rollupOptions` to output built assets with the following structure and naming pattern:

- JavaScript entry files (e.g. scripts directly associated with your pages or layouts): `dist/js/[name]-[hash].js`
- JavaScript code-split chunks (e.g. dynamically imported components or shared modules): `dist/js/chunks/[name]-[hash].js`
- Other assets (e.g. CSS, images, fonts): `dist/static/[name]-[hash][extname]` (e.g. `dist/static/styles-a1b2c3d4.css`, `dist/static/logo-e5f6g7h8.svg`)

1. Add Vite Rollup Output Options.
  Modify your `astro.config.mjs` to include the following `vite.build.rollupOptions.output` configuration. This is where you can define the custom naming patterns for your assets using Rollup’s [entryFileNames](https://rollupjs.org/configuration-options/#output-entryfilenames), [chunkFileNames](https://rollupjs.org/configuration-options/#output-chunkfilenames), and [assetFileNames](https://rollupjs.org/configuration-options/#output-assetfilenames):
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';
  export default defineConfig({  // ...  vite: {    build: {      rollupOptions: {        output: {          // path names relative to `outDir`          entryFileNames: 'js/[name]-[hash].js',          chunkFileNames: 'js/chunks/[name]-[hash].js',          assetFileNames: 'static/[name]-[hash][extname]',        },      },    },  },});
  ```
  This example uses the following file name placeholders:
  - `[name]`: The original name of the file (without the extension and path).
  - `[hash]`: A content-based hash generated for the file, crucial for cache busting. You can also specify a length, e.g. `[hash:8]`. This ensures that when you update an asset, the filename changes, forcing browsers to download the new version instead of serving a stale cached version.
  - `[extname]`: The original file extension, including the leading dot (e.g. `.js`, `.css`, `.svg`).
  For a full list of available placeholders and advanced patterns for these options, refer to the [Rollup configuration documentation](https://rollupjs.org/configuration-options/).
2. Build your project.
  Since these filename customizations apply to the production build output only, you will need to run your project’s build command:
  - [npm](#tab-panel-1887)
  - [pnpm](#tab-panel-1888)
  - [Yarn](#tab-panel-1889)
     Terminal window
  ```
  npm run build
  ```
     Terminal window
  ```
  pnpm build
  ```
     Terminal window
  ```
  yarn build
  ```
3. After the build completes, inspect your [output directory](https://docs.astro.build/en/reference/configuration-reference/#outdir) (`dist/` by default).
  Verify that the build assets from your project `src` are named and organized according to the new patterns. (Files from [yourpublic/directory](https://docs.astro.build/en/basics/project-structure/#public) are copied directly to the output directory and are not affected by these Rollup naming options.)
  Depending on your project’s specific contents, your build folder will now look something like this:
  - Directorydist/
    - Directoryjs/
      - index-a1b2c3d4.js
      - Directorychunks/
        - common-e5f6g7h8.js
    - Directoryimg/
      - logo-i9j0k1l2.png
    - Directoryfonts/
      - myfont-q2w3e4r5.woff2
    - Directorystatic_assets/
      - styles-m3n4o5p6.css
    - index.html
    - Directoryabout/
      - index.html
    - … (other HTML files and public assets)

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
