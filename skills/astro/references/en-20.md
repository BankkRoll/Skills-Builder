# Using environment variables and more

# Using environment variables

> Learn how to use environment variables in an Astro project.

# Using environment variables

Astro gives you access to [Vite’s built-in environment variables support](#vites-built-in-support) and includes some [default environment variables for your project](#default-environment-variables) that allow you to access configuration values for your current project (e.g. `site`, `base`), whether your project is running in development or production, and more.

Astro also provides a way to [use and organize your environment variables with type safety](#type-safe-environment-variables). It is available for use inside the Astro context (e.g. Astro components, routes and endpoints, UI framework components, middleware), and managed with [a schema in your Astro configuration](https://docs.astro.build/en/reference/configuration-reference/#env).

## Vite’s built-in support

[Section titled “Vite’s built-in support”](#vites-built-in-support)

Astro uses Vite’s built-in support for environment variables, which are statically replaced at build time, and lets you [use any of its methods](https://vite.dev/guide/env-and-mode.html) to work with them.

Note that while *all* environment variables are available in server-side code, only environment variables prefixed with `PUBLIC_` are available in client-side code for security purposes.

 .env

```
SECRET_PASSWORD=password123PUBLIC_ANYBODY=there
```

In this example, `PUBLIC_ANYBODY` (accessible via `import.meta.env.PUBLIC_ANYBODY`) will be available in server or client code, while `SECRET_PASSWORD` (accessible via `import.meta.env.SECRET_PASSWORD`) will be server-side only.

### IntelliSense for TypeScript

[Section titled “IntelliSense for TypeScript”](#intellisense-for-typescript)

By default, Astro provides a type definition for `import.meta.env` in `astro/client.d.ts`.

While you can define more custom env variables in `.env.[mode]` files, you may want to get TypeScript IntelliSense for user-defined env variables which are prefixed with `PUBLIC_`.

To achieve this, you can create an `env.d.ts` in `src/` to [extend the global types](https://docs.astro.build/en/guides/typescript/#extending-global-types) and configure `ImportMetaEnv` like this:

 src/env.d.ts

```
interface ImportMetaEnv {  readonly DB_PASSWORD: string;  readonly PUBLIC_POKEAPI: string;  // more env variables...}
interface ImportMeta {  readonly env: ImportMetaEnv;}
```

## Default environment variables

[Section titled “Default environment variables”](#default-environment-variables)

Astro includes a few environment variables out of the box:

- `import.meta.env.MODE`: The mode your site is running in. This is `development` when running `astro dev` and `production` when running `astro build`.
- `import.meta.env.PROD`: `true` if your site is running in production; `false` otherwise.
- `import.meta.env.DEV`: `true` if your site is running in development; `false` otherwise. Always the opposite of `import.meta.env.PROD`.
- `import.meta.env.BASE_URL`: The base URL your site is being served from. This is determined by the [baseconfig option](https://docs.astro.build/en/reference/configuration-reference/#base).
- `import.meta.env.SITE`: This is set to [thesiteoption](https://docs.astro.build/en/reference/configuration-reference/#site) specified in your project’s `astro.config`.
- `import.meta.env.ASSETS_PREFIX`: The prefix for Astro-generated asset links if the [build.assetsPrefixconfig option](https://docs.astro.build/en/reference/configuration-reference/#buildassetsprefix) is set. This can be used to create asset links not handled by Astro.

Use them like any other environment variable.

```
const isProd = import.meta.env.PROD;const isDev = import.meta.env.DEV;
```

## Setting environment variables

[Section titled “Setting environment variables”](#setting-environment-variables)

### .envfiles

[Section titled “.env files”](#env-files)

Environment variables can be loaded from `.env` files in your project directory.

Just create a `.env` file in the project directory and add some variables to it.

 .env

```
# This will only be available when run on the server!DB_PASSWORD="foobar"
# This will be available everywhere!PUBLIC_POKEAPI="https://pokeapi.co/api/v2"
```

You can also add `.production`, `.development` or a custom mode name to the filename itself (e.g `.env.testing`, `.env.staging`). This allows you to use different sets of environment variables at different times.

The `astro dev` and `astro build` commands default to `"development"` and `"production"` modes, respectively. You can run these commands with the [--modeflag](https://docs.astro.build/en/reference/cli-reference/#--mode-string) to pass a different value for `mode` and load the matching `.env` file.

This allows you to run the dev server or build your site connecting to different APIs:

- [npm](#tab-panel-1824)
- [pnpm](#tab-panel-1825)
- [Yarn](#tab-panel-1826)

   Terminal window

```
# Run the dev server connected to a "staging" APInpm run astro dev -- --mode staging
# Build a site that connects to a "production" API with additional debug informationnpm run astro build -- --devOutput
# Build a site that connects to a "testing" APInpm run astro build -- --mode testing
```

   Terminal window

```
# Run the dev server connected to a "staging" APIpnpm astro dev --mode staging
# Build a site that connects to a "production" API with additional debug informationpnpm astro build --devOutput
# Build a site that connects to a "testing" APIpnpm astro build --mode testing
```

   Terminal window

```
# Run the dev server connected to a "staging" APIyarn astro dev --mode staging
# Build a site that connects to a "production" API with additional debug informationyarn astro build --devOutput
# Build a site that connects to a "testing" APIyarn astro build --mode testing
```

For more on `.env` files, [see the Vite documentation](https://vite.dev/guide/env-and-mode.html#env-files).

### In the Astro config file

[Section titled “In the Astro config file”](#in-the-astro-config-file)

Astro evaluates configuration files before it loads your other files. This means that you cannot use `import.meta.env` in `astro.config.mjs` to access environment variables that were set in `.env` files.

You can use `process.env` in a configuration file to access other environment variables, like those [set by the CLI](#using-the-cli).

You can also use [Vite’sloadEnvhelper](https://main.vite.dev/config/#using-environment-variables-in-config) to manually load `.env` files.

 astro.config.mjs

```
import { loadEnv } from "vite";
const { SECRET_PASSWORD } = loadEnv(process.env.NODE_ENV, process.cwd(), "");
```

### Using the CLI

[Section titled “Using the CLI”](#using-the-cli)

You can also add environment variables as you run your project:

- [npm](#tab-panel-1827)
- [pnpm](#tab-panel-1828)
- [Yarn](#tab-panel-1829)

   Terminal window

```
PUBLIC_POKEAPI=https://pokeapi.co/api/v2 npm run dev
```

   Terminal window

```
PUBLIC_POKEAPI=https://pokeapi.co/api/v2 pnpm run dev
```

   Terminal window

```
PUBLIC_POKEAPI=https://pokeapi.co/api/v2 yarn run dev
```

## Getting environment variables

[Section titled “Getting environment variables”](#getting-environment-variables)

Environment variables in Astro are accessed with `import.meta.env`, using the [import.metafeature added in ES2020](https://tc39.es/ecma262/2020/#prod-ImportMeta), instead of `process.env`.

For example, use `import.meta.env.PUBLIC_POKEAPI` to get the `PUBLIC_POKEAPI` environment variable.

```
// When import.meta.env.SSR === trueconst data = await db(import.meta.env.DB_PASSWORD);
// When import.meta.env.SSR === falseconst data = fetch(`${import.meta.env.PUBLIC_POKEAPI}/pokemon/squirtle`);
```

When using SSR, environment variables can be accessed at runtime based on the SSR adapter being used. With most adapters you can access environment variables with `process.env`, but some adapters work differently. For the Deno adapter, you will use `Deno.env.get()`. See how to [access the Cloudflare runtime](https://docs.astro.build/en/guides/integrations-guide/cloudflare/#cloudflare-runtime) to handle environment variables when using the Cloudflare adapter. Astro will first check the server environment for variables, and if they don’t exist, Astro will look for them in `.env` files.

## Type safe environment variables

[Section titled “Type safe environment variables”](#type-safe-environment-variables)

The `astro:env` API lets you configure a type-safe schema for [environment variables you have set](#setting-environment-variables). This allows you to indicate whether they should be available on the server or the client, and define their data type and additional properties.

   Developing an adapter? See how to [make an adapter compatible withastro:env](https://docs.astro.build/en/reference/adapter-reference/#envgetsecret).

### Basic Usage

[Section titled “Basic Usage”](#basic-usage)

#### Define your schema

[Section titled “Define your schema”](#define-your-schema)

To configure a schema, add the `env.schema` option to your Astro config:

 astro.config.mjs

```
import { defineConfig } from "astro/config";
export default defineConfig({  env: {    schema: {      // ...    }  }})
```

You can then [register variables as a string, number, enum, or boolean](#data-types) using the `envField` helper. Define the [kind of environment variable](#variable-types) by providing a `context` (`"client"` or `"server"`) and `access` (`"secret"` or `"public"`) for each variable, and pass any additional properties such as `optional` or `default` in an object:

 astro.config.mjs

```
import { defineConfig, envField } from "astro/config";
export default defineConfig({  env: {    schema: {      API_URL: envField.string({ context: "client", access: "public", optional: true }),      PORT: envField.number({ context: "server", access: "public", default: 4321 }),      API_SECRET: envField.string({ context: "server", access: "secret" }),    }  }})
```

Types will be generated for you when running `astro dev` or `astro build`, but you can run `astro sync` to generate types only.

#### Use variables from your schema

[Section titled “Use variables from your schema”](#use-variables-from-your-schema)

Import and use your defined variables from the appropriate `/client` or `/server` module:

```
---import { API_URL } from "astro:env/client";import { API_SECRET_TOKEN } from "astro:env/server";
const data = await fetch(`${API_URL}/users`, {  method: "GET",  headers: {    "Content-Type": "application/json",    "Authorization": `Bearer ${API_SECRET_TOKEN}`  },})---
<script>  import { API_URL } from "astro:env/client";
  fetch(`${API_URL}/ping`)</script>
```

### Variable types

[Section titled “Variable types”](#variable-types)

There are three kinds of environment variables, determined by the combination of `context` (`"client"` or `"server"`) and `access` (`"secret"` or `"public"`) settings defined in your schema:

- **Public client variables**: These variables end up in both your final client and server bundles, and can be accessed from both client and server through the `astro:env/client` module:
  ```
  import { API_URL } from "astro:env/client";
  ```
- **Public server variables**: These variables end up in your final server bundle and can be accessed on the server through the `astro:env/server` module:
  ```
  import { PORT } from "astro:env/server";
  ```
- **Secret server variables**: These variables are not part of your final bundle and can be accessed on the server through the `astro:env/server` module:
  ```
  import { API_SECRET } from "astro:env/server";
  ```
  By default, all secrets are validated whenever anything is imported from the `astro:env/server` module. This means, secrets may be validated even when they are not imported. You may need to [pass dummy environment variables](#setting-environment-variables) to satisfy this validation during the build.
  You can also enable validating secrets on start by [configuringvalidateSecrets: true](https://docs.astro.build/en/reference/configuration-reference/#envvalidatesecrets).

### Data types

[Section titled “Data types”](#data-types)

There are currently four data types supported: strings, numbers, enums, and booleans:

```
import { envField } from "astro/config";
envField.string({   // context & access   optional: true,   default: "foo",})
envField.number({   // context & access   optional: true,   default: 15,})
envField.boolean({   // context & access   optional: true,   default: true,})
envField.enum({   // context & access   values: ["foo", "bar", "baz"],   optional: true,   default: "baz",})
```

   For a complete list of validation fields, see the [envFieldAPI reference](https://docs.astro.build/en/reference/configuration-reference/#envschema).

### Retrieving secrets dynamically

[Section titled “Retrieving secrets dynamically”](#retrieving-secrets-dynamically)

Despite defining your schema, you may want to retrieve the raw value of a given secret or to retrieve secrets not defined in your schema. In this case, you can use `getSecret()` exported from `astro:env/server`:

```
import {   FOO, // boolean   getSecret} from "astro:env/server";
getSecret("FOO"); // string | undefined
```

   Learn more in [the API reference](https://docs.astro.build/en/reference/modules/astro-env/#getsecret).

### Limitations

[Section titled “Limitations”](#limitations)

`astro:env` is a virtual module which means it can only be used inside the Astro context. For example, you can use it in:

- Middlewares
- Astro routes and endpoints
- Astro components
- Framework components
- Modules

You cannot use it in the following and will have to resort to `process.env`:

- `astro.config.mjs`
- Scripts

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Using custom fonts

> Looking to add some custom typefaces to an Astro website? Use Google Fonts with Fontsource or add a font of your choice.

# Using custom fonts

This guide will show you how to add web fonts to your project and use them in your components.

## Using a local font file

[Section titled “Using a local font file”](#using-a-local-font-file)

This example will demonstrate adding a custom font using the font file `DistantGalaxy.woff`.

1. Add your font file to `public/fonts/`.
2. Add the following `@font-face` statement to your CSS. This could be in a global `.css` file you import, a `<style is:global>` block, or a `<style>` block in a specific layout or component where you want to use this font.
  ```
  /* Register your custom font family and tell the browser where to find it. */@font-face {  font-family: 'DistantGalaxy';  src: url('/fonts/DistantGalaxy.woff') format('woff');  font-weight: normal;  font-style: normal;  font-display: swap;}
  ```
3. Use the `font-family` value from the `@font-face` statement to style elements in your component or layout. In this example, the `<h1>` heading will have the custom font applied, while the paragraph `<p>` will not.
   src/pages/example.astro
  ```
  ------
  <h1>In a galaxy far, far away...</h1>
  <p>Custom fonts make my headings much cooler!</p>
  <style>h1 {  font-family: 'DistantGalaxy', sans-serif;}</style>
  ```

## Using Fontsource

[Section titled “Using Fontsource”](#using-fontsource)

The [Fontsource](https://fontsource.org/) project simplifies using Google Fonts and other open-source fonts. It provides npm modules you can install for the fonts you want to use.

1. Find the font you want to use in [Fontsource’s catalog](https://fontsource.org/). This example will use [Twinkle Star](https://fontsource.org/fonts/twinkle-star).
2. Install the package for your chosen font.
  - [npm](#tab-panel-1830)
  - [pnpm](#tab-panel-1831)
  - [Yarn](#tab-panel-1832)
     Terminal window
  ```
  npm install @fontsource/twinkle-star
  ```
     Terminal window
  ```
  pnpm add @fontsource/twinkle-star
  ```
     Terminal window
  ```
  yarn add @fontsource/twinkle-star
  ```
3. Import the font package in the component where you want to use the font. Usually, you will want to do this in a common layout component to make sure the font is available across your site.
  The import will automatically add the necessary `@font-face` rules needed to set up the font.
   src/layouts/BaseLayout.astro
  ```
  ---import '@fontsource/twinkle-star';---
  ```
4. Use the font’s name as shown in the `body` example on its Fontsource page as the `font-family` value. This will work anywhere you can write CSS in your Astro project.
  ```
  h1 {  font-family: "Twinkle Star", cursive;}
  ```

To optimize your website’s rendering times, you may want to preload fonts that are essential for the initial page display.
See the [Fontsource guide to preloading fonts](https://fontsource.org/docs/getting-started/preload) for more information and usage.

## Register fonts in Tailwind

[Section titled “Register fonts in Tailwind”](#register-fonts-in-tailwind)

If you are using [Tailwind](https://docs.astro.build/en/guides/styling/#tailwind), you can use either of the previous methods on this page to install your font, with some modifications. You can either add an [@font-facestatement for a local font](#using-a-local-font-file) or use [Fontsource’simportstrategy](#using-fontsource) to install your font.

To register your font in Tailwind:

1. Follow either of the guides above, but skip the final step of adding `font-family` to your CSS.
2. Add the typeface name to `src/styles/global.css`.
  This example adds `Inter` to the sans-serif font stack.
   src/styles/global.css
  ```
  @import 'tailwindcss';
  @theme {  --font-sans: 'Inter', 'sans-serif';}
  ```
  Now, all sans-serif text (the default with Tailwind) in your project will use your chosen font and the `font-sans` class will also apply the Inter font.

See [Tailwind’s docs on adding custom font families](https://tailwindcss.com/docs/font-family#using-custom-values) for more information.

## More resources

[Section titled “More resources”](#more-resources)

- Learn how web fonts work in [MDN’s web fonts guide](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Web_fonts).
- Generate CSS for your font with [Font Squirrel’s Webfont Generator](https://www.fontsquirrel.com/tools/webfont-generator).

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Front

> Build your Astro website with React, Svelte, and more.

# Front-end frameworks

Build your Astro website without sacrificing your favorite component framework. Create Astro [islands](https://docs.astro.build/en/concepts/islands/) with the UI frameworks of your choice.

## Official front-end framework integrations

[Section titled “Official front-end framework integrations”](#official-front-end-framework-integrations)

Astro supports a variety of popular frameworks including [React](https://react.dev/), [Preact](https://preactjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [SolidJS](https://www.solidjs.com/), and [AlpineJS](https://alpinejs.dev/) with official integrations.

Find even more [community-maintained framework integrations](https://astro.build/integrations/?search=&categories%5B%5D=frameworks) (e.g. Angular, Qwik, Elm) in our integrations directory.

### Front-end frameworks

- ![](https://docs.astro.build/logos/alpine-js.svg)
  ### @astrojs/alpinejs
- ![](https://docs.astro.build/logos/preact.svg)
  ### @astrojs/preact
- ![](https://docs.astro.build/logos/react.svg)
  ### @astrojs/react
- ![](https://docs.astro.build/logos/solid.svg)
  ### @astrojs/solid⁠-⁠js
- ![](https://docs.astro.build/logos/svelte.svg)
  ### @astrojs/svelte
- ![](https://docs.astro.build/logos/vue.svg)
  ### @astrojs/vue

## Installing integrations

[Section titled “Installing integrations”](#installing-integrations)

One or several of these Astro integrations can be installed and configured in your project.

See the [Integrations Guide](https://docs.astro.build/en/guides/integrations-guide/) for more details on installing and configuring Astro integrations.

## Using framework components

[Section titled “Using framework components”](#using-framework-components)

Use your JavaScript framework components in your Astro pages, layouts and components just like Astro components! All your components can live together in `/src/components`, or can be organized in any way you like.

To use a framework component, import it from its relative path in your Astro component script. Then, use the component alongside other components, HTML elements and JSX-like expressions in the component template.

 src/pages/static-components.astro

```
---import MyReactComponent from '../components/MyReactComponent.jsx';---<html>  <body>    <h1>Use React components directly in Astro!</h1>    <MyReactComponent />  </body></html>
```

By default, your framework components will only render on the server, as static HTML. This is useful for templating components that are not interactive and avoids sending any unnecessary JavaScript to the client.

## Hydrating interactive components

[Section titled “Hydrating interactive components”](#hydrating-interactive-components)

A framework component can be made interactive (hydrated) using a [client:*directive](https://docs.astro.build/en/reference/directives-reference/#client-directives). These are component attributes that determine when your component’s JavaScript should be sent to the browser.

With all client directives except `client:only`, your component will first render on the server to generate static HTML. Component JavaScript will be sent to the browser according to the directive you chose. The component will then hydrate and become interactive.

 src/pages/interactive-components.astro

```
---// Example: hydrating framework components in the browser.import InteractiveButton from '../components/InteractiveButton.jsx';import InteractiveCounter from '../components/InteractiveCounter.jsx';import InteractiveModal from '../components/InteractiveModal.svelte';---<InteractiveButton client:load />
<InteractiveCounter client:visible />
<InteractiveModal client:only="svelte" />
```

The JavaScript framework (React, Svelte, etc.) needed to render the component will be sent to the browser along with the component’s own JavaScript. If two or more components on a page use the same framework, the framework will only be sent once.

### Available hydration directives

[Section titled “Available hydration directives”](#available-hydration-directives)

There are several hydration directives available for UI framework components: `client:load`, `client:idle`, `client:visible`, `client:media={QUERY}` and `client:only={FRAMEWORK}`.

   See our [directives reference](https://docs.astro.build/en/reference/directives-reference/#client-directives) page for a full description of these hydration directives, and their usage.

## Mixing frameworks

[Section titled “Mixing frameworks”](#mixing-frameworks)

You can import and render components from multiple frameworks in the same Astro component.

 src/pages/mixing-frameworks.astro

```
---// Example: Mixing multiple framework components on the same page.import MyReactComponent from '../components/MyReactComponent.jsx';import MySvelteComponent from '../components/MySvelteComponent.svelte';import MyVueComponent from '../components/MyVueComponent.vue';---<div>  <MySvelteComponent />  <MyReactComponent />  <MyVueComponent /></div>
```

Astro will recognize and render your component based on its file extension. To distinguish between frameworks that use the same file extension, [additional configuration when rendering multiple JSX frameworks](https://docs.astro.build/en/guides/integrations-guide/react/#combining-multiple-jsx-frameworks) (e.g. React and Preact) is required.

## Passing props to framework components

[Section titled “Passing props to framework components”](#passing-props-to-framework-components)

You can pass props from Astro components to framework components:

 src/pages/frameworks-props.astro

```
---import TodoList from '../components/TodoList.jsx';import Counter from '../components/Counter.svelte';---<div>  <TodoList initialTodos={["learn Astro", "review PRs"]} />  <Counter startingCount={1} /></div>
```

Props that are passed to interactive framework components [using aclient:*directive](https://docs.astro.build/en/reference/directives-reference/#client-directives) must be [serialized](https://developer.mozilla.org/en-US/docs/Glossary/Serialization): translated into a format suitable for transfer over a network, or storage. However, Astro does not serialize every type of data structure. Therefore, there are some limitations on what can be passed as props to hydrated components.

The following prop types are supported:
plain object, `number`, `string`, `Array`, `Map`, `Set`, `RegExp`, `Date`, `BigInt`, `URL`, `Uint8Array`, `Uint16Array`, `Uint32Array`, and `Infinity`

Non-supported data structures passed to components, such as functions, can only be used during the component’s server rendering and cannot be used to provide interactivity. For example, passing functions to hydrated components is not supported because Astro cannot pass functions from the server in a way that makes them executable on the client.

## Passing children to framework components

[Section titled “Passing children to framework components”](#passing-children-to-framework-components)

Inside of an Astro component, you **can** pass children to framework components. Each framework has its own patterns for how to reference these children: React, Preact, and Solid all use a special prop named `children`, while Svelte and Vue use the `<slot />` element.

 src/pages/component-children.astro

```
---import MyReactSidebar from '../components/MyReactSidebar.jsx';---<MyReactSidebar>  <p>Here is a sidebar with some text and a button.</p></MyReactSidebar>
```

Additionally, you can use [Named Slots](https://docs.astro.build/en/basics/astro-components/#named-slots) to group specific children together.

For React, Preact, and Solid, these slots will be converted to a top-level prop. Slot names using `kebab-case` will be converted to `camelCase`.

 src/pages/named-slots.astro

```
---import MySidebar from '../components/MySidebar.jsx';---<MySidebar>  <h2 slot="title">Menu</h2>  <p>Here is a sidebar with some text and a button.</p>  <ul slot="social-links">    <li><a href="https://twitter.com/astrodotbuild">Twitter</a></li>    <li><a href="https://github.com/withastro">GitHub</a></li>  </ul></MySidebar>
```

 src/components/MySidebar.jsx

```
export default function MySidebar(props) {  return (    <aside>      <header>{props.title}</header>      <main>{props.children}</main>      <footer>{props.socialLinks}</footer>    </aside>  )}
```

For Svelte and Vue these slots can be referenced using a `<slot>` element with the `name` attribute. Slot names using `kebab-case` will be preserved.

 src/components/MySidebar.svelte

```
<aside>  <header><slot name="title" /></header>  <main><slot /></main>  <footer><slot name="social-links" /></footer></aside>
```

## Nesting framework components

[Section titled “Nesting framework components”](#nesting-framework-components)

Inside of an Astro file, framework component children can also be hydrated components. This means that you can recursively nest components from any of these frameworks.

 src/pages/nested-components.astro

```
---import MyReactSidebar from '../components/MyReactSidebar.jsx';import MyReactButton from '../components/MyReactButton.jsx';import MySvelteButton from '../components/MySvelteButton.svelte';---<MyReactSidebar>  <p>Here is a sidebar with some text and a button.</p>  <div slot="actions">    <MyReactButton client:idle />    <MySvelteButton client:idle />  </div></MyReactSidebar>
```

This allows you to build entire “apps” in your preferred JavaScript framework and render them, via a parent component, to an Astro page.

## Can I use Astro components inside my framework components?

[Section titled “Can I use Astro components inside my framework components?”](#can-i-use-astro-components-inside-my-framework-components)

Any UI framework component becomes an “island” of that framework. These components must be written entirely as valid code for that framework, using only its own imports and packages. You cannot import `.astro` components in a UI framework component (e.g. `.jsx` or `.svelte`).

You can, however, use [the Astro<slot />pattern](https://docs.astro.build/en/basics/astro-components/#slots) to pass static content generated by Astro components as children to your framework components **inside an.astrocomponent**.

 src/pages/astro-children.astro

```
---import MyReactComponent from  '../components/MyReactComponent.jsx';import MyAstroComponent from '../components/MyAstroComponent.astro';---<MyReactComponent>  <MyAstroComponent slot="name" /></MyReactComponent>
```

## Can I hydrate Astro components?

[Section titled “Can I hydrate Astro components?”](#can-i-hydrate-astro-components)

If you try to hydrate an Astro component with a `client:` modifier, you will get an error.

[Astro components](https://docs.astro.build/en/basics/astro-components/) are HTML-only templating components with no client-side runtime. But, you can use a `<script>` tag in your Astro component template to send JavaScript to the browser that executes in the global scope.

   Learn more about [client-side<script>tags in Astro components](https://docs.astro.build/en/guides/client-side-scripts/)  Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
