# Zod API Reference and more

# Zod API Reference

# Zod API Reference

[Zod](https://github.com/colinhacks/zod) is a TypeScript-based schema declaration and validation library. This allows you to define schemas you can use to validate data and transform data, from a simple type (e.g. `string`, `number`) to complex data structures (e.g. nested objects).

The `astro/zod` module exposes a re-export of Zod that gives you access to all the features of Zod v3. By using this module, you do not need to install Zod yourself. This also ensures that your project uses the same API versions as Astro when using features such as [Content Collections](https://docs.astro.build/en/guides/content-collections/) or [Actions](https://docs.astro.build/en/guides/actions/).

   See [Zod v3 website](https://v3.zod.dev/) for complete documentation on how Zod works and what features are available.

## Imports fromastro/zod

[Section titled ‚ÄúImports from astro/zod‚Äù](#imports-from-astrozod)

```
import { z } from 'astro/zod';
```

### z

[Section titled ‚Äúz‚Äù](#z)

**Type:** `object`

The `z` utility gives you access to validators for a wide range of data types, methods and types for working with your data.

   Learn more about the `z` utility in [Zod documentation](https://v3.zod.dev/?id=basic-usage)

#### Common data type validators

[Section titled ‚ÄúCommon data type validators‚Äù](#common-data-type-validators)

With Zod, you can validate any type of data, such as [primitives](https://v3.zod.dev/?id=primitives), [objects](https://v3.zod.dev/?id=objects), [arrays](https://v3.zod.dev/?id=arrays) and more.

The following example shows a cheatsheet of many common Zod data types to create a `user` schema:

```
import { z } from 'astro/zod';
const user = z.object({  username: z.string(),  name: z.string().min(2),  email: z.string().email(),  role: z.enum(["admin", "editor"]),  language: z.enum(["en", "fr", "es"]).default("en"),  hobbies: z.array(z.string()),  age: z.number(),  isEmailConfirmed: z.boolean(),  inscriptionDate: z.date(),  website: z.string().url().optional(),});
```

#### Extracting a Typescript type

[Section titled ‚ÄúExtracting a Typescript type‚Äù](#extracting-a-typescript-type)

Zod allows you to create a Typescript type from any schema [using Zod type inference](https://v3.zod.dev/?id=type-inference). This can be useful for describing an expected data structure when [defining component props](https://docs.astro.build/en/guides/typescript/#component-props).

The following example create a `User` type based on the previous schema:

```
type User = z.infer<typeof user>;
/* The `User` type will be: * type User = { *   username: string; *   name: string; *   email: string; *   role: "admin" | "editor"; *   language: "en" | "fr" | "es"; *   hobbies: string[]; *   age: number; *   isEmailConfirmed: boolean; *   inscriptionDate: Date; *   website?: string | undefined; * } */
```

#### Using Zod methods

[Section titled ‚ÄúUsing Zod methods‚Äù](#using-zod-methods)

Zod provides various [schema methods](https://v3.zod.dev/?id=schema-methods) to customize error messages, transform data, or create custom validation logics.

```
// Customize the error messageconst nonEmptyStrings = z.string().array().nonempty({  message: "Can't be empty!",});
// Validate a data from a schemanonEmptyStrings.parse([]); // will throws our custom error
// Create an object from a URL for a decorative imgconst decorativeImg = z.string().transform((value) => {  return { src: value, alt: "" };});
// Create a custom validator and error message for a stringconst constrainedString = z  .string()  .refine((val) => val.length > 0 && val.length <= 255, {    message: "Must be between 1 and 255 characters.",  });
```

### Individual imports

[Section titled ‚ÄúIndividual imports‚Äù](#individual-imports)

Alternatively, you can import all the Zod validators, methods and types available in the [zutility](#z) directly from the module.

The following example imports `coerce` to create a `Date` object from a date string:

```
import { coerce } from 'astro/zod';
const publishedOn = coerce.date();const publicationDate = publishedOn.parse("2025-12-03");
```

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Programmatic Astro API (experimental)

# Programmatic Astro API (experimental)

If you need more control when running Astro, the `"astro"` package exports APIs to programmatically run the CLI commands.

These APIs are experimental and their API signature may change. Any updates will be mentioned in the [Astro changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) and the information below will always show the current, up-to-date information.

## AstroInlineConfig

[Section titled ‚ÄúAstroInlineConfig‚Äù](#astroinlineconfig)

The `AstroInlineConfig` type is used by all of the command APIs below. It extends from the user [Astro config](https://docs.astro.build/en/reference/configuration-reference/) type:

```
interface AstroInlineConfig extends AstroUserConfig {  configFile?: string | false;  mode?: string;  logLevel?: "debug" | "info" | "warn" | "error" | "silent";}
```

### configFile

[Section titled ‚ÄúconfigFile‚Äù](#configfile)

**Type:** `string | false`
 **Default:** `undefined`

A custom path to the Astro config file.

If this value is undefined (default) or unset, Astro will search for an `astro.config.(js,mjs,ts,mts)` file relative to the `root` and load the config file if found.

If a relative path is set, it will resolve based on the `root` option.

Set to `false` to disable loading any config files.

The inline config passed in this object will take highest priority when merging with the loaded user config.

### mode

[Section titled ‚Äúmode‚Äù](#mode)

**Type:** `string`
 **Default:** `"development"` when running `astro dev`, `"production"` when running `astro build`

 **Added in:** `astro@5.0.0`

The mode used when developing or building your site (e.g. `"production"`, `"testing"`).

This value is passed to Vite using [the--modeflag](https://docs.astro.build/en/reference/cli-reference/#--mode-string) when the `astro build` or `astro dev` commands are run to determine the value of `import.meta.env.MODE`. This also determines which `.env` files are loaded, and therefore the values of `astro:env`. See the [environment variables page](https://docs.astro.build/en/guides/environment-variables/) for more details.

To output a development-based build, you can run `astro build` with the [--devOutputflag](https://docs.astro.build/en/reference/cli-reference/#--devoutput).

### logLevel

[Section titled ‚ÄúlogLevel‚Äù](#loglevel)

**Type:** `"debug" | "info" | "warn" | "error" | "silent"`
 **Default:** `"info"`

The logging level to filter messages logged by Astro.

- `"debug"`: Log everything, including noisy debugging diagnostics.
- `"info"`: Log informational messages, warnings, and errors.
- `"warn"`: Log warnings and errors.
- `"error"`: Log errors only.
- `"silent"`: No logging.

## dev()

[Section titled ‚Äúdev()‚Äù](#dev)

**Type:** `(inlineConfig: AstroInlineConfig) => Promise<DevServer>`

Similar to [astro dev](https://docs.astro.build/en/reference/cli-reference/#astro-dev), it runs Astro‚Äôs development server.

```
import { dev } from "astro";
const devServer = await dev({  root: "./my-project",});
// Stop the server if neededawait devServer.stop();
```

### DevServer

[Section titled ‚ÄúDevServer‚Äù](#devserver)

```
export interface DevServer {  address: AddressInfo;  handle: (req: http.IncomingMessage, res: http.ServerResponse<http.IncomingMessage>) => void;  watcher: vite.FSWatcher;  stop(): Promise<void>;}
```

#### address

[Section titled ‚Äúaddress‚Äù](#address)

**Type:** `AddressInfo`

The address the dev server is listening on.

This property contains the value returned by Node‚Äôs [net.Server#address()method](https://nodejs.org/api/net.html#serveraddress).

#### handle()

[Section titled ‚Äúhandle()‚Äù](#handle)

**Type:** `(req: http.IncomingMessage, res: http.ServerResponse<http.IncomingMessage>) => void`

A handle for raw Node HTTP requests. You can call `handle()` with an [http.IncomingMessage](https://nodejs.org/api/http.html#class-httpincomingmessage) and an [http.ServerResponse](https://nodejs.org/api/http.html#class-httpserverresponse) instead of sending a request through the network.

#### watcher

[Section titled ‚Äúwatcher‚Äù](#watcher)

**Type:** `vite.FSWatcher`

The [Chokidar file watcher](https://github.com/paulmillr/chokidar#getting-started) as exposed by [Vite‚Äôs development server](https://vite.dev/guide/api-javascript#vitedevserver).

#### stop()

[Section titled ‚Äústop()‚Äù](#stop)

**Type:** `Promise<void>`

Stops the development server. This closes all idle connections and stops listening for new connections.

Returns a `Promise` that resolves once all pending requests have been fulfilled and all idle connections have been closed.

## build()

[Section titled ‚Äúbuild()‚Äù](#build)

**Type:** `(inlineConfig: AstroInlineConfig, options?: BuildOptions) => Promise<void>`

Similar to [astro build](https://docs.astro.build/en/reference/cli-reference/#astro-build), it builds your site for deployment.

```
import { build } from "astro";
await build({  root: "./my-project",});
```

### BuildOptions

[Section titled ‚ÄúBuildOptions‚Äù](#buildoptions)

```
export interface BuildOptions {  devOutput?: boolean;  teardownCompiler?: boolean;}
```

#### devOutput

[Section titled ‚ÄúdevOutput‚Äù](#devoutput)

**Type:** `boolean`
 **Default:** `false`

 **Added in:** `astro@5.4.0`

Output a development-based build similar to code transformed in `astro dev`. This can be useful to test build-only issues with additional debugging information included.

#### teardownCompiler

[Section titled ‚ÄúteardownCompiler‚Äù](#teardowncompiler)

**Type:** `boolean`
 **Default:** `true`

 **Added in:** `astro@5.4.0`

Teardown the compiler WASM instance after build. This can improve performance when building once but may cause a performance hit if building multiple times in a row.

When building multiple projects in the same execution (e.g. during tests), disabling this option can greatly increase performance and reduce peak memory usage at the cost of higher sustained memory usage.

## preview()

[Section titled ‚Äúpreview()‚Äù](#preview)

**Type:** `(inlineConfig: AstroInlineConfig) => Promise<PreviewServer>`

Similar to [astro preview](https://docs.astro.build/en/reference/cli-reference/#astro-preview), it starts a local server to serve your build output.

If no adapter is set in the configuration, the preview server will only serve the built static files.
If an adapter is set in the configuration, the preview server is provided by the adapter. Adapters are not required to provide a preview server, so this feature may not be available depending on your adapter of choice.

```
import { preview } from "astro";
const previewServer = await preview({  root: "./my-project",});
// Stop the server if neededawait previewServer.stop();
```

### PreviewServer

[Section titled ‚ÄúPreviewServer‚Äù](#previewserver)

```
export interface PreviewServer {  host?: string;  port: number;  closed(): Promise<void>;  stop(): Promise<void>;}
```

#### host

[Section titled ‚Äúhost‚Äù](#host)

**Type:** `string`

The host where the server is listening for connections.

Adapters are allowed to leave this field unset. The value of `host` is implementation-specific.

#### port

[Section titled ‚Äúport‚Äù](#port)

**Type:** `number`

The port where the server is listening for connections.

#### stop()

[Section titled ‚Äústop()‚Äù](#stop-1)

**Type:** `Promise<void>`

Asks the preview server to close, stop accepting requests, and drop idle connections.

The returned `Promise` resolves when the close request has been sent. This does not mean that the server has closed yet. Use the [closed()](#closed) method if you need to ensure the server has fully closed.

#### closed()

[Section titled ‚Äúclosed()‚Äù](#closed)

**Type:** `Promise<void>`

Returns a `Promise` that will resolve once the server is closed and reject if an error happens on the server.

## sync()

[Section titled ‚Äúsync()‚Äù](#sync)

**Type:** `(inlineConfig: AstroInlineConfig) => Promise<void>`

Similar to [astro sync](https://docs.astro.build/en/reference/cli-reference/#astro-sync), it generates TypeScript types for all Astro modules.

```
import { sync } from "astro";
await sync({  root: "./my-project",});
```

## mergeConfig()

[Section titled ‚ÄúmergeConfig()‚Äù](#mergeconfig)

**Type:** `<T extends AstroConfig | AstroInlineConfig>(config: T, overrides: DeepPartial<T>) => T`

 **Added in:** `astro@5.4.0`

Imported from `astro/config`, merges a partial Astro configuration on top of an existing, valid, Astro configuration.

`mergeConfig()` accepts an Astro config object and a partial config (any set of valid Astro config options), and returns a valid Astro config combining both values such that:

- Arrays are concatenated (including integrations and remark plugins).
- Objects are merged recursively.
- Vite options are merged using [Vite‚Äôs ownmergeConfigfunction](https://vite.dev/guide/api-javascript#mergeconfig) with the default `isRoot` flag.
- Options that can be provided as functions are wrapped into new functions that recursively merge the return values from both configurations with these same rules.
- All other options override the existing config.

```
import { mergeConfig } from "astro/config";
mergeConfig(  {    output: 'static',    site: 'https://example.com',    integrations: [partytown()],    server: ({command}) => ({      port: command === 'dev' ? 4321 : 1234,    }),    build: {      client: './custom-client',    },  },  {    output: 'server',    base: '/astro',    integrations: [mdx()],    server: ({command}) => ({      host: command === 'dev' ? 'localhost' : 'site.localhost',    }),    build: {      server: './custom-server',    },  });
// Result is equivalent to:{  output: 'server',  site: 'https://example.com',  base: '/astro',  integrations: [partytown(), mdx()],  server: ({command}) => ({    port: command === 'dev' ? 4321 : 1234,    host: command === 'dev' ? 'localhost' : 'site.localhost',  }),  build: {    client: './custom-client',    server: './custom-server',  },}
```

## validateConfig()

[Section titled ‚ÄúvalidateConfig()‚Äù](#validateconfig)

**Type:** `(userConfig: any, root: string, cmd: string): Promise<AstroConfig>`

 **Added in:** `astro@5.4.0`

Imported from `astro/config`, validates an object as if it was exported from `astro.config.mjs` and imported by Astro.

It takes the following arguments:

- The configuration to be validated.
- The root directory of the project.
- The Astro command that is being executed (`build`, `dev`, `sync`, etc.)

The returned promise resolves to the validated configuration, filled with all default values appropriate for the given Astro command.

```
import { validateConfig } from "astro/config";
const config = await validateConfig({  integrations: [partytown()],}, "./my-project", "build");
// defaults are appliedawait rm(config.outDir, { recursive: true, force: true });
```

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Publish to npm

> Learn how to publish Astro components to npm

# Publish to npm

Building a new Astro component? **Publish it tonpm!**

Publishing an Astro component is a great way to reuse your existing work across your projects, and to share with the wider Astro community at large. Astro components can be published directly to and installed from npm, just like any other JavaScript package.

Looking for inspiration? Check out some of our favorite [themes](https://astro.build/themes/) and [components](https://astro.build/integrations/) from the Astro community. You can also [search npm](https://www.npmjs.com/search?q=keywords:astro-component,withastro) to see the entire public catalog.

## Quick Start

[Section titled ‚ÄúQuick Start‚Äù](#quick-start)

To get started developing your component quickly, you can use a template already set up for you.

 Terminal window

```
# Initialize the Astro Component template in a new directorynpm create astro@latest my-new-component-directory -- --template component# yarnyarn create astro my-new-component-directory --template component# pnpmpnpm create astro@latest my-new-component-directory -- --template component
```

## Creating a package

[Section titled ‚ÄúCreating a package‚Äù](#creating-a-package)

To create a new package, configure your development environment to use **workspaces** within your project. This will allow you to develop your component alongside a working copy of Astro.

- Directorymy-new-component-directory/
  - Directorydemo/
    - ‚Ä¶ for testing and demonstration
  - package.json
  - Directorypackages/
    - Directorymy-component/
      - index.js
      - package.json
      - ‚Ä¶ additional files used by the package

This example, named `my-project`, creates a project with a single package, named `my-component`, and a `demo/` directory for testing and demonstrating the component.

This is configured in the project root‚Äôs `package.json` file:

```
{  "name": "my-project",  "workspaces": ["demo", "packages/*"]}
```

In this example, multiple packages can be developed together from the `packages` directory. These packages can also be referenced from `demo`, where you can install a working copy of Astro.

 Terminal window

```
npm create astro@latest demo -- --template minimal# yarnyarn create astro demo --template minimal# pnpmpnpm create astro@latest demo -- --template minimal
```

There are two initial files that will make up your individual package: `package.json` and `index.js`.

### package.json

[Section titled ‚Äúpackage.json‚Äù](#packagejson)

The `package.json` in the package directory includes all of the information related to your package, including its description, dependencies, and any other package metadata.

```
{  "name": "my-component",  "description": "Component description",  "version": "1.0.0",  "homepage": "https://github.com/owner/project#readme",  "type": "module",  "exports": {    ".": "./index.js",    "./astro": "./MyAstroComponent.astro",    "./react": "./MyReactComponent.jsx"  },  "files": ["index.js", "MyAstroComponent.astro", "MyReactComponent.jsx"],  "keywords": ["astro", "withastro", "astro-component", "...", "..."]}
```

#### description

[Section titled ‚Äúdescription‚Äù](#description)

A short description of your component used to help others know what it does.

```
{  "description": "An Astro Element Generator"}
```

#### type

[Section titled ‚Äútype‚Äù](#type)

The module format used by Node.js and Astro to interpret your `index.js` files.

```
{  "type": "module"}
```

Use `"type": "module"` so that your `index.js` can be used as an entrypoint with `import` and `export` .

#### homepage

[Section titled ‚Äúhomepage‚Äù](#homepage)

The url to the project homepage.

```
{  "homepage": "https://github.com/owner/project#readme"}
```

This is a great way to direct users to an online demo, documentation, or homepage for your project.

#### exports

[Section titled ‚Äúexports‚Äù](#exports)

The entry points of a package when imported by name.

```
{  "exports": {    ".": "./index.js",    "./astro": "./MyAstroComponent.astro",    "./react": "./MyReactComponent.jsx"  }}
```

In this example, importing `my-component` would use `index.js`, while importing `my-component/astro` or `my-component/react` would use `MyAstroComponent.astro` or `MyReactComponent.jsx` respectively.

#### files

[Section titled ‚Äúfiles‚Äù](#files)

An optional optimization to exclude unnecessary files from the bundle shipped to users via npm. Note that **only files listed here will be included in your package**, so if you add or change files necessary for your package to work, you must update this list accordingly.

```
{  "files": ["index.js", "MyAstroComponent.astro", "MyReactComponent.jsx"]}
```

#### keywords

[Section titled ‚Äúkeywords‚Äù](#keywords)

An array of keywords relevant to your component, used to help others [find your component on npm](https://www.npmjs.com/search?q=keywords:astro-component,withastro) and in any other search catalogs.

Add `astro-component`, `astro-integration`, or `withastro` as a special keyword to maximize its discoverability in the Astro ecosystem.

```
{  "keywords": ["astro-component", "withastro", "... etc", "... etc"]}
```

---

### index.js

[Section titled ‚Äúindex.js‚Äù](#indexjs)

The main **package entrypoint** used whenever your package is imported.

```
export { default as MyAstroComponent } from './MyAstroComponent.astro';
export { default as MyReactComponent } from './MyReactComponent.jsx';
```

This allows you to package multiple components together into a single interface.

#### Example: Using Named Imports

[Section titled ‚ÄúExample: Using Named Imports‚Äù](#example-using-named-imports)

```
---import { MyAstroComponent } from 'my-component';import { MyReactComponent } from 'my-component';---<MyAstroComponent /><MyReactComponent />
```

#### Example: Using Namespace Imports

[Section titled ‚ÄúExample: Using Namespace Imports‚Äù](#example-using-namespace-imports)

```
---import * as Example from 'example-astro-component';---<Example.MyAstroComponent /><Example.MyReactComponent />
```

#### Example: Using Individual Imports

[Section titled ‚ÄúExample: Using Individual Imports‚Äù](#example-using-individual-imports)

```
---import MyAstroComponent from 'example-astro-component/astro';import MyReactComponent from 'example-astro-component/react';---<MyAstroComponent /><MyReactComponent />
```

---

## Developing your package

[Section titled ‚ÄúDeveloping your package‚Äù](#developing-your-package)

Astro does not have a dedicated ‚Äúpackage¬†mode‚Äù for development. Instead, you should use a demo project to develop and test your package inside of your project. This can be a private website only used for development, or a public demo/documentation website for your package.

If you are extracting components from an existing project, you can even continue to use that project to develop your now-extracted components.

## Testing your component

[Section titled ‚ÄúTesting your component‚Äù](#testing-your-component)

Astro does not currently ship a test runner. *(If you are interested in helping out with this,join us on Discord!)*

In the meantime, our current recommendation for testing is:

1. Add a test `fixtures` directory to your `demo/src/pages` directory.
2. Add a new page for every test that you‚Äôd like to run.
3. Each page should include some different component usage that you‚Äôd like to test.
4. Run `astro build` to build your fixtures, then compare the output of the `dist/__fixtures__/` directory to what you expected.
  - Directorymy-project/demo/src/pages/__fixtures__/
    - test-name-01.astro
    - test-name-02.astro
    - test-name-03.astro

## Publishing your component

[Section titled ‚ÄúPublishing your component‚Äù](#publishing-your-component)

Once you have your package ready, you can publish it to npm using the `npm publish` command. If that fails, make sure that you have logged in via `npm login` and that your `package.json` is correct. If it succeeds, you‚Äôre done!

Notice that there was no `build` step for Astro packages. Any file type that Astro supports natively, such as `.astro`, `.ts`, `.jsx`, and `.css`, can be published directly without a build step.

If you need another file type that isn‚Äôt natively supported by Astro, add a build step to your package. This advanced exercise is left up to you.

## Integrations Library

[Section titled ‚ÄúIntegrations Library‚Äù](#integrations-library)

Share your hard work by adding your integration to our [integrations library](https://astro.build/integrations/)!

### package.jsondata

[Section titled ‚Äúpackage.json data‚Äù](#packagejson-data)

The library is automatically updated weekly, pulling in every package published to npm with the `astro-component`, `astro-integration`, or `withastro` keyword.

The integrations library reads the `name`, `description`, `repository`, and `homepage` data from your `package.json`.

Avatars are a great way to highlight your brand in the library! Once your package is published you can [file a GitHub issue](https://github.com/withastro/astro.build/issues/new/choose) with your avatar attached and we will add it to your listing.

### Categories

[Section titled ‚ÄúCategories‚Äù](#categories)

In addition to the required `astro-component`, `astro-integration`, or `withastro` keyword, special keywords are also used to automatically organize packages. Including any of the keywords below will add your integration to the matching category in our integrations library.

| category | keywords |
| --- | --- |
| Accessibility | a11y,accessibility |
| Adapters | astro-adapter |
| Analytics | analytics |
| CSS + UI | css,ui,icon,icons,renderer |
| Frameworks | renderer |
| Content Loaders | astro-loader |
| Images + Media | media,image,images,video,audio |
| Performance + SEO | performance,perf,seo,optimization |
| Dev Toolbar | devtools,dev-overlay,dev-toolbar |
| Utilities | tooling,utils,utility |

Packages that don‚Äôt include any keyword matching a category will be shown as `Uncategorized`.

## Share

[Section titled ‚ÄúShare‚Äù](#share)

We encourage you to share your work, and we really do love seeing what our talented Astronauts create. Come and share what you create with us in our [Discord](https://astro.build/chat) or mention [@astrodotbuild](https://twitter.com/astrodotbuild) in a Tweet!

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Routing Reference

# Routing Reference

There is no separate routing configuration in Astro.

Every [supported page file](https://docs.astro.build/en/basics/astro-pages/#supported-page-files) located within the special `src/pages/` directory creates a route. When the file name contains a [parameter](#params), a route can create multiple pages dynamically, otherwise it creates a single page.

By default, all Astro page routes and endpoints are generated and prerendered at build time. [On-demand server rendering](https://docs.astro.build/en/guides/on-demand-rendering/) can be set for individual routes, or as the default.

## prerender

[Section titled ‚Äúprerender‚Äù](#prerender)

**Type:** `boolean`
 **Default:** `true` in static mode (default); `false` with `output: 'server'` configuration

 **Added in:** `astro@1.0.0`

A value exported from each individual route to determine whether or not it is prerendered.

By default, all pages and endpoints are prerendered and will be statically generated at build time. You can opt out of prerendering on one or more routes, and you can have both static and on-demand rendered routes in the same project.

### Per-page override

[Section titled ‚ÄúPer-page override‚Äù](#per-page-override)

You can override the default value to enable [on demand rendering](https://docs.astro.build/en/guides/on-demand-rendering/) for an individual route by exporting `prerender` with the value `false` from that file:

 src/pages/rendered-on-demand.astro

```
---export const prerender = false---
```

### Switch toservermode

[Section titled ‚ÄúSwitch to server mode‚Äù](#switch-to-server-mode)

You can override the default value for all routes by configuring [output: 'server'](https://docs.astro.build/en/reference/configuration-reference/#output). In this output mode, all pages and endpoints will be generated on the server upon request by default instead of being prerendered.

In `server` mode, enable prerendering for an individual route by exporting `prerender` with the value `true` from that file:

 src/pages/static-about-page.astro

```
---// with `output: 'server'` configuredexport const prerender = true---
```

## partial

[Section titled ‚Äúpartial‚Äù](#partial)

**Type:** `boolean`
 **Default:** `false`

 **Added in:** `astro@3.4.0`

A value exported from an individual route to determine whether or not it should be rendered as a full HTML page.

By default, all files located within the reserved `src/pages/` directory automatically include the `<!DOCTYPE html>` declaration and additional `<head>` content such as Astro‚Äôs scoped styles and scripts.

You can override the default value to designate the content as a [page partial](https://docs.astro.build/en/basics/astro-pages/#page-partials) for an individual route by exporting a value for `partial` from that file:

 src/pages/my-page-partial.astro

```
---export const partial = true---
```

The `export const partial` must be identifiable statically. It can have the value of:

- The boolean **true**.
- An environment variable using import.meta.env such as `import.meta.env.USE_PARTIALS`.

## getStaticPaths()

[Section titled ‚ÄúgetStaticPaths()‚Äù](#getstaticpaths)

**Type:** `(options: GetStaticPathsOptions) => Promise<GetStaticPathsResult> | GetStaticPathsResult`

 **Added in:** `astro@1.0.0`

A function to generate multiple, prerendered page routes from a single `.astro` page component with one or more [parameters](#params) in its file path. Use this for routes that will be created at build time, also known as static site building.

The `getStaticPaths()` function must return an array of objects to determine which URL paths will be prerendered by Astro. Each object must include a `params` object, to specify route paths. The object may optionally contain a `props` object with [data to be passed](#data-passing-with-props) to each page template.

 src/pages/blog/[post].astro

```
---// In 'server' mode, opt in to prerendering:// export const prerender = true
export async function getStaticPaths() {  return [    // { params: { /* required */ }, props: { /* optional */ } },    { params: { post: '1' } }, // [post] is the parameter    { params: { post: '2' } }, // must match the file name    // ...  ];}---
```

`getStaticPaths()` can also be used in static file endpoints for [dynamic routing](https://docs.astro.build/en/guides/endpoints/#params-and-dynamic-routing).

### params

[Section titled ‚Äúparams‚Äù](#params)

The `params` key of each object in the array returned by `getStaticPaths()` tells Astro what routes to build.

The keys in `params` must match the parameters defined in your component file path. The value for each `params` object must match the parameters used in the page name. `params` are encoded into the URL, so only strings are supported as values.

For example,`src/pages/posts/[id].astro`has an `id` parameter in its file name. The following `getStaticPaths()` function in this `.astro` component tells Astro to statically generate `posts/1`, `posts/2`, and `posts/3` at build time.

 src/pages/posts/[id].astro

```
---export async function getStaticPaths() {  return [    { params: { id: '1' } },    { params: { id: '2' } },    { params: { id: '3' } }  ];}
const { id } = Astro.params;---<h1>{id}</h1>
```

### Data passing withprops

[Section titled ‚ÄúData passing with props‚Äù](#data-passing-with-props)

To pass additional data to each generated page, you can set a `props` value on each object in the array returned by `getStaticPaths()`. Unlike `params`, `props` are not encoded into the URL and so aren‚Äôt limited to only strings.

For example, if you generate pages with data fetched from a remote API, you can pass the full data object to the page component inside of `getStaticPaths()`. The page template can reference the data from each post using `Astro.props`.

 src/pages/posts/[id].astro

```
---export async function getStaticPaths() {  const response = await fetch('...');  const data = await response.json();
  return data.map((post) => {    return {      params: { id: post.id },      props: { post },    };  });}
const { id } = Astro.params;const { post } = Astro.props;---<h1>{id}: {post.name}</h1>
```

### routePattern

[Section titled ‚ÄúroutePattern‚Äù](#routepattern)

**Type:** `string`

 **Added in:** `astro@5.14.0`

A property available in [getStaticPaths()](#getstaticpaths) options to access the current [routePattern](https://docs.astro.build/en/reference/api-reference/#routepattern) as a string.

This provides data from the [Astro render context](https://docs.astro.build/en/reference/api-reference/) that would not otherwise be available within the scope of `getStaticPaths()` and can be useful to calculate the `params` and `props` for each page route.

`routePattern` always reflects the original dynamic segment definition in the file path (e.g. `/[...locale]/[files]/[slug]`), unlike `params`, which are explicit values for a page (e.g. `/fr/fichiers/article-1/`).

The following example shows how to localize your route segments and return an array of static paths by passing `routePattern` to a custom `getLocalizedData()` helper function. The [params](https://docs.astro.build/en/reference/routing-reference/#params) object will be set with explicit values for each route segment: `locale`, `files`, and `slug`. Then, these values will be used to generate the routes and can be used in your page template via `Astro.params`.

 src/pages/[...locale]/[files]/[slug].astro

```
---import { getLocalizedData } from "../../../utils/i18n";
export async function getStaticPaths({ routePattern }) {  const response = await fetch('...');  const data = await response.json();
  console.log(routePattern); // [...locale]/[files]/[slug]
  // Call your custom helper with `routePattern` to generate the static paths  return data.flatMap((file) => getLocalizedData(file, routePattern));}
const { locale, files, slug } = Astro.params;---
```

### paginate()

[Section titled ‚Äúpaginate()‚Äù](#paginate)

**Added in:** `astro@1.0.0`

A function that can be returned from [getStaticPaths()](#getstaticpaths) to divide a collection of content items into separate pages.

`paginate()` will automatically generate the necessary array to return from `getStaticPaths()` to create one URL for every page of your paginated collection. The page number will be passed as a `param`, and the page data will be passed as a `page` prop.

The following example fetches and passes 150 items to the `paginate` function, and creates static, prerendered pages at build time that will display 10 items per page:

 src/pages/pokemon/[page].astro

```
---export async function getStaticPaths({ paginate }) {  // Load your data with fetch(), getCollection(), etc.  const response = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=150`);  const result = await response.json();  const allPokemon = result.results;
  // Return a paginated collection of paths for all items  return paginate(allPokemon, { pageSize: 10 });}
const { page } = Astro.props;---
```

`paginate()` has the following arguments:

- `data` - array containing the page‚Äôs data passed to the `paginate()` function
- `options` - Optional object with the following properties:
  - `pageSize` - The number of items shown per page (`10` by default)
  - `params` - Send additional parameters for creating dynamic routes
  - `props` - Send additional props to be available on each page

`paginate()` assumes a file name of `[page].astro` or `[...page].astro`. The `page` param becomes the page number in your URL:

- `/posts/[page].astro` would generate the URLs `/posts/1`, `/posts/2`, `/posts/3`, etc.
- `/posts/[...page].astro` would generate the URLs `/posts`, `/posts/2`, `/posts/3`, etc.

#### The paginationpageprop

[Section titled ‚ÄúThe pagination page prop‚Äù](#the-pagination-page-prop)

**Type:** `Page<TData>`

Pagination will pass a `page` prop to every rendered page that represents a single page of data in the paginated collection. This includes the data that you‚Äôve paginated (`page.data`) as well as metadata for the page (`page.url`, `page.start`, `page.end`, `page.total`, etc). This metadata is useful for things like a ‚ÄúNext Page‚Äù button or a ‚ÄúShowing 1-10 of 100‚Äù message.

##### page.data

[Section titled ‚Äúpage.data‚Äù](#pagedata)

**Type:** `Array<TData>`

Array of data returned from the `paginate()` function for the current page.

##### page.start

[Section titled ‚Äúpage.start‚Äù](#pagestart)

**Type:** `number`

Index of the first item on the current page, starting at `0`. (e.g. if `pageSize: 25`, this would be `0` on page 1, `25` on page 2, etc.)

##### page.end

[Section titled ‚Äúpage.end‚Äù](#pageend)

**Type:** `number`

Index of the last item on the current page.

##### page.size

[Section titled ‚Äúpage.size‚Äù](#pagesize)

**Type:** `number`
 **Default:** `10`

The total number of items per page.

##### page.total

[Section titled ‚Äúpage.total‚Äù](#pagetotal)

**Type:** `number`

The total number of items across all pages.

##### page.currentPage

[Section titled ‚Äúpage.currentPage‚Äù](#pagecurrentpage)

**Type:** `number`

The current page number, starting with `1`.

##### page.lastPage

[Section titled ‚Äúpage.lastPage‚Äù](#pagelastpage)

**Type:** `number`

The total number of pages.

##### page.url.current

[Section titled ‚Äúpage.url.current‚Äù](#pageurlcurrent)

**Type:** `string`

Get the URL of the current page (useful for canonical URLs). If a value is set for [base](https://docs.astro.build/en/reference/configuration-reference/#base), the URL starts with that value.

##### page.url.prev

[Section titled ‚Äúpage.url.prev‚Äù](#pageurlprev)

**Type:** `string | undefined`

Get the URL of the previous page (will be `undefined` if on page 1). If a value is set for [base](https://docs.astro.build/en/reference/configuration-reference/#base), prepend the base path to the URL.

##### page.url.next

[Section titled ‚Äúpage.url.next‚Äù](#pageurlnext)

**Type:** `string | undefined`

Get the URL of the next page (will be `undefined` if no more pages). If a value is set for [base](https://docs.astro.build/en/reference/configuration-reference/#base), prepend the base path to the URL.

##### page.url.first

[Section titled ‚Äúpage.url.first‚Äù](#pageurlfirst)

**Type:** `string | undefined`

 **Added in:** `astro@4.12.0`

Get the URL of the first page (will be `undefined` if on page 1). If a value is set for [base](https://docs.astro.build/en/reference/configuration-reference/#base), prepend the base path to the URL.

##### page.url.last

[Section titled ‚Äúpage.url.last‚Äù](#pageurllast)

**Type:** `string | undefined`

 **Added in:** `astro@4.12.0`

Get the URL of the last page (will be `undefined` if no more pages). If a value is set for [base](https://docs.astro.build/en/reference/configuration-reference/#base), prepend the base path to the URL.

 Reference     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# About this Tutorial

> How to get started with the "Build your first Astro blog" tutorial.

# About this Tutorial

## What do I need to know to get started?

[Section titled ‚ÄúWhat do I need to know to get started?‚Äù](#what-do-i-need-to-know-to-get-started)

If you have some basic familiarity with **HTML**, **Markdown**, **CSS**, and a little **JavaScript**, then you‚Äôre totally good to go! You‚Äôll be able to complete the entire tutorial just by following the instructions. Astro is for everyone! üßë‚ÄçüöÄ üë©‚ÄçüöÄ üë®‚ÄçüöÄ

You will also need a [GitHub](https://github.com) (or similar) account for publishing your project to the web.

 How do I use the checklists at the bottom of each page?

You check them off!

At the end of each page, you‚Äôll find a clickable checklist of tasks you should now be able to do. Check these items off to see your progress in the Tutorial Tracker.

Using the tracker is optional, but it can help you remember your place if you complete the tutorial over multiple visits. You can also leave some checklists blank as a reminder of units that you want to revisit later.

(This data is only saved to your browser‚Äôs local storage and is not available elsewhere. No data is sent to, nor stored by Astro.)

 Unit 1 is things I already know how to do. Can I skip it?

You can use the lessons inside [Unit 1](https://docs.astro.build/en/tutorial/1-setup/) to make sure you have the development tools and online accounts you‚Äôll need to complete the tutorial. It will walk you through creating a new Astro project, storing it on GitHub, and deploying it to Netlify.

If you [create a new, empty Astro project](https://docs.astro.build/en/install-and-setup/) and are comfortable with your setup, you can safely skip ahead to [Unit 2](https://docs.astro.build/en/tutorial/2-pages/) where you will start making new pages in your project.

 What if I need help, or want to learn more about Astro?

Our [friendly Astro Discord server](https://astro.build/chat) is the place to be!

Hop into the support forum channel to ask questions, or say hi and chat in `#general` or `#off-topic`.

 Where can I leave feedback about this tutorial?

This tutorial is a project of our Docs team. You can find us on Discord in the `#docs` channel, or file issues to the [Docs repo on GitHub](https://github.com/withastro/docs/issues).

## Checklist for moving on

[Section titled ‚ÄúChecklist for moving on‚Äù](#checklist-for-moving-on)

- I‚Äôm ready to build this thing!

     Tutorials     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Build your first Astro Blog

> Learn the basics of Astro with a project-based tutorial. All the background knowledge you need to get started!

# Build your first Astro Blog

In this tutorial, you‚Äôll learn Astro‚Äôs key features by building a fully-functioning blog, from zero to full launch! üöÄ

Along the way, you‚Äôll:

- Set up your development environment
- Create pages and blog posts for your website
- Build with Astro components
- Query and work with local files
- Add interactivity to your site
- Deploy your site to the web

Want a preview of what you‚Äôre going to build? You can view the final project on [GitHub](https://github.com/withastro/blog-tutorial-demo) or open a working version in an online coding environment such as [IDX](https://idx.google.com/import?url=https:%2F%2Fgithub.com%2Fwithastro%2Fblog-tutorial-demo%2F) or [StackBlitz](https://stackblitz.com/github/withastro/blog-tutorial-demo/tree/complete?file=src%2Fpages%2Findex.astro).

## Checklist

[Section titled ‚ÄúChecklist‚Äù](#checklist)

- Looks great! I‚Äôm ready to get started!

     Tutorials     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Prepare your dev environment

> Tutorial: Build your first Astro blog ‚Äî
Install the local tools that you‚Äôll need to complete the tutorial

### Test your knowledge

[Section titled ‚ÄúTest your knowledge‚Äù](#test-your-knowledge)

Which of the following is‚Ä¶

1. A code editor, for making changes to your files and their content?
  1. web browser
  2. Terminal
  3. VS Code
2. An online version control provider for your repository?
  1. GitHub
  2. Terminal
  3. VS Code
3. An application for running commands?
  1. GitHub
  2. Terminal
  3. web browser

---

# Create your first Astro project

> Tutorial: Build your first Astro blog ‚Äî
Create a new project for the Astro tutorial and get ready to code

## Checklist

[Section titled ‚ÄúChecklist‚Äù](#checklist)

- I can create a new Astro project.
- I can start the Astro dev server.

---

# Write your first line of Astro

> Tutorial: Build your first Astro blog ‚Äî
Make your first edits to your tutorial project's home page

## Checklist

[Section titled ‚ÄúChecklist‚Äù](#checklist)

- I can make changes and see them in the browser.
- I am an Astro developer!

---

# Store your repository online

> Tutorial: Build your first Astro blog ‚Äî
Create a GitHub repo for your tutorial project

# Store your repository online

Get ready to‚Ä¶

- Put your project repository online

This tutorial will use GitHub to store our repository and connect to a web host. You are welcome to use the online git provider of your choice.

## Create a repository on GitHub

[Section titled ‚ÄúCreate a repository on GitHub‚Äù](#create-a-repository-on-github)

Although there are a few ways to get your local code stored in GitHub, this tutorial will guide you through a method that does not require using git in the command line.

1. Log in to GitHub.com in a browser and click the + in the upper right of the screen to make a new repository.
2. Choose a name for your repository. This does not have to be the same name as your project folder.
3. You will be presented with options, but you do not need to change any of the defaults. Scroll down and click the button to Create Repository.
4. You will be presented with various setup next steps, but you won‚Äôt need to use any of them. Make a note of the URL of your repository. You can now exit this page without doing anything.

## Commit your local code to GitHub

[Section titled ‚ÄúCommit your local code to GitHub‚Äù](#commit-your-local-code-to-github)

In the last section, you made a change to your page‚Äôs content. This means that your project files have changed, and VS Code should show a number on top of the ‚ÄúSource‚Äù menu icon. This source tab is where you will regularly go to update your files on GitHub.

1. Click the Source Control tab in your VS Code to see a list of files that have changed. If you see a message that you need to install `git`, follow the instructions provided, then reload VS Code.
2. Click the ‚Ä¢‚Ä¢‚Ä¢ ‚Äú3 dots‚Äù menu above the commit message and choose Remote > Add Remote.
3. Select Add remote from GitHub. If necessary, follow any authentication steps then return to VS Code and repeat this action.
4. You should see a list of all your repositories on GitHub. Choose the one you created for this project. If you don‚Äôt see your project, paste in its GitHub URL directly. You may also be asked to give this repository a local name. You can select any name you like.
5. At the top of the menu pane, there will be a place to enter a **commit message** (description of your file changes). Type in `initial commit` and press the Commit button to commit these changes.
6. You may see a message telling you that you have no ‚Äústaged‚Äù commits, and asking you if you want to stage them. Click Always and continue.
7. Lastly, the list of changed files should be replaced with a Publish button. Click this to send your committed changes to GitHub.

### See your project on GitHub

[Section titled ‚ÄúSee your project on GitHub‚Äù](#see-your-project-on-github)

To verify that your project is successfully stored on GitHub, visit GitHub.com and look under your account for a list of your repositories. Choose the new one you created, and verify that it contains your Astro project files.

## Checklist

[Section titled ‚ÄúChecklist‚Äù](#checklist)

- I have stored my project on GitHub.

### Resources

[Section titled ‚ÄúResources‚Äù](#resources)

- [Using Git Source control in VS Code](https://code.visualstudio.com/docs/sourcecontrol/overview#_git-support) external

 Tutorials     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
