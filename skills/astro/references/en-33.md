# Server islands and more

# Server islands

> Combine high performance static HTML with dynamic server-rendered content.

# Server islands

Server islands allow you to on-demand render dynamic or personalized ‚Äúislands‚Äù individually, without sacrificing the performance of the rest of the page.

This means your visitor will see the most important parts of your page sooner, and allows your main content to be more aggressively cached, providing faster performance.

## Server island components

[Section titled ‚ÄúServer island components‚Äù](#server-island-components)

A server island is a normal server-rendered [Astro component](https://docs.astro.build/en/basics/astro-components/) that is instructed to delay rendering until its contents are available.

Your page will be rendered immediately with any specified [fallback content as a placeholder](#server-island-fallback-content). Then, the component‚Äôs own contents are fetched on the client and displayed when available.

With [an adapter installed](https://docs.astro.build/en/guides/on-demand-rendering/#server-adapters) to perform the delayed rendering, add the [server:deferdirective](https://docs.astro.build/en/reference/directives-reference/#server-directives) to any component on your page to turn it into its own island:

 src/pages/index.astro

```
---import Avatar from '../components/Avatar.astro';---<Avatar server:defer />
```

These components can do [anything you normally would in an on-demand rendered page](https://docs.astro.build/en/guides/on-demand-rendering/#on-demand-rendering-features) using an adapter, such as fetch content, and access cookies:

 src/components/Avatar.astro

```
---import { getUserAvatar } from '../sessions';const userSession = Astro.cookies.get('session');const avatarURL = await getUserAvatar(userSession);---<img alt="User avatar" src={avatarURL} />
```

### Passing props to server islands

[Section titled ‚ÄúPassing props to server islands‚Äù](#passing-props-to-server-islands)

Props provided to server island components must be [serializable](https://developer.mozilla.org/en-US/docs/Glossary/Serialization): able to be translated into a format suitable for transfer over a network, or storage. Additionally, Astro does not serialize every type of serializable data structure. Therefore, there are some limitations on what can be passed as props to a server island.

Notably, functions cannot be passed to components marked with `server:defer` as they cannot be serialized. Objects with circular references are also not serializable.

The following prop types are supported:
plain object, `number`, `string`, `Array`, `Map`, `Set`, `RegExp`, `Date`, `BigInt`, `URL`, `Uint8Array`, `Uint16Array`, `Uint32Array`, and `Infinity`

## Server island fallback content

[Section titled ‚ÄúServer island fallback content‚Äù](#server-island-fallback-content)

When using the `server:defer` attribute on a component to delay its rendering, you can ‚Äúslot‚Äù in default loading content using the included named `"fallback"` slot.

Your fallback content will be rendered along with the rest of the page initially on page load and will be replaced with your component‚Äôs content when available.

To add fallback content, add `slot="fallback"` on a child (other components or HTML elements) passed to your server island component:

```
---import Avatar from '../components/Avatar.astro';import GenericAvatar from '../components/GenericAvatar.astro';---<Avatar server:defer>  <GenericAvatar slot="fallback" /></Avatar>
```

This fallback content can be things like:

- A generic avatar instead of the user‚Äôs own.
- Placeholder UI such as custom messages.
- Loading indicators such as spinners.

## How it works

[Section titled ‚ÄúHow it works‚Äù](#how-it-works)

Server island implementation happens mostly at build-time where component content is swapped out for a small script.

Each of the islands marked with `server:defer` is split off into its own special route which the script fetches at run time. When Astro builds your site it will omit the component and inject a script in its place, and any content you‚Äôve marked with `slot="fallback"`.

When the page loads in the browser, these components will be requested to a special endpoint that renders them and returns the HTML. This means that users will see the most critical parts of the page instantly. Fallback content will be visible for a short amount of time before the dynamic islands are then loaded.

Each island is loaded independently from the rest. This means a slower island won‚Äôt delay the rest of your personalized content from being available.

This rendering pattern was built to be portable. It does not depend on any server infrastructure so it will work with any host you have, from a Node.js server in a Docker container to the serverless provider of your choice.

## Caching

[Section titled ‚ÄúCaching‚Äù](#caching)

The data for server islands is retrieved via a `GET` request, passing props as an encrypted string in the URL query. This allows caching data with the [Cache-ControlHTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) using standard `Cache-Control` directives.

However, [the browser limits URLs to a maximum length of 2048 bytes](https://chromium.googlesource.com/chromium/src/+/master/docs/security/url_display_guidelines/url_display_guidelines.md#url-length) for practical reasons and to avoid causing denial-of-service problems. If your query string causes your URL to exceed this limit, Astro will instead send a `POST` request that contains all props in the body.

`POST` requests are not cached by browsers because they are used to submit data, and could cause data integrity or security issues. Therefore, any existing caching logic in your project will break. Whenever possible, pass only necessary props to your server islands and avoid sending entire data objects and arrays to keep your query small.

## Accessing the page URL in a server island

[Section titled ‚ÄúAccessing the page URL in a server island‚Äù](#accessing-the-page-url-in-a-server-island)

In most cases you, your server island component can get information about the page rendering it by [passing props](https://docs.astro.build/en/basics/astro-components/#component-props) like in normal components.

However, server islands run in their own isolated context outside of the page request. `Astro.url` and `Astro.request.url` in a server island component both return a URL that looks like `/_server-islands/Avatar` instead of the current page‚Äôs URL in the browser. Additionally, if you are prerendering the page you will not have access to information such as query parameters in order to pass as props.

To access information from the page‚Äôs URL, you can check the [Referer](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) header, which will contain the address of the page that is loading the island in the browser:

```
---const referer = Astro.request.headers.get('Referer');const url = new URL(referer);const productId = url.searchParams.get('product');---
```

## Reusing the encryption key

[Section titled ‚ÄúReusing the encryption key‚Äù](#reusing-the-encryption-key)

Astro uses [cryptography](https://developer.mozilla.org/en-US/docs/Glossary/Cryptography) to encrypt props passed to server islands, protecting sensitive data from accidental exposure. This encryption relies on a new, random key that is generated on each build and embedded in the server bundle.

Most deploy hosts will handle keeping your front end and back end in sync automatically. However, you may need a constant encryption key if you are using rolling deployments, multi-region hosting or a CDN that caches pages containing server islands.

In environments with rolling deployments (e.g., Kubernetes) where your frontend assets (which encrypt props) and your backend functions (which decrypt props) may be temporarily using different keys, or when a CDN is still serving pages built with an old key, encrypted props passed to your server island cannot be decrypted.

In these situations, use the Astro CLI to generate a reusable, encoded encryption key to set as an environment variable in your build environment:

 Terminal window

```
astro create-key
```

Use this value to configure the `ASTRO_KEY` environment variable (e.g. in a `.env` file) and include it in your CI/CD or host‚Äôs build settings. This ensures the same key is always reused in the generated bundle so that encryption and decryption remain in sync.

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Sessions

> Share data between requests for on-demand rendered pages.

# Sessions

**Added in:** `astro@5.7.0`

Sessions are used to share data between requests for [on-demand rendered pages](https://docs.astro.build/en/guides/on-demand-rendering/).

Unlike [cookies](https://docs.astro.build/en/guides/on-demand-rendering/#cookies), sessions are stored on the server, so you can store larger amounts of data without worrying about size limits or security issues. They are useful for storing things like user data, shopping carts, and form state, and they work without any client-side JavaScript:

 src/components/CartButton.astro

```
---export const prerender = false; // Not needed with 'server' outputconst cart = await Astro.session?.get('cart');---
<a href="/checkout">üõí {cart?.length ?? 0} items</a>
```

## Configuring sessions

[Section titled ‚ÄúConfiguring sessions‚Äù](#configuring-sessions)

Sessions require a storage driver to store the session data. The [Node](https://docs.astro.build/en/guides/integrations-guide/node/#sessions), [Cloudflare](https://docs.astro.build/en/guides/integrations-guide/cloudflare/#sessions), and [Netlify](https://docs.astro.build/en/guides/integrations-guide/netlify/#sessions) adapters automatically configure a default driver for you, but other adapters currently require you to [specify a driver manually](https://docs.astro.build/en/reference/configuration-reference/#sessiondriver).

 astro.config.mjs

```
{    adapter: vercel(),    session: {      driver: "redis",    },  }
```

See [thesessionconfiguration option](https://docs.astro.build/en/reference/configuration-reference/#session-options) for more details on setting a storage driver, and other configurable options.

## Interacting with session data

[Section titled ‚ÄúInteracting with session data‚Äù](#interacting-with-session-data)

The [sessionobject](https://docs.astro.build/en/reference/api-reference/#session) allows you to interact with the stored user state (e.g. adding items to a shopping cart) and the session ID (e.g. deleting the session ID cookie when logging out). The object is accessible as `Astro.session` in your Astro components and pages and as `context.session` object in API endpoints, middleware, and actions.

The session is generated automatically when it is first used and can be regenerated at any time with [session.regenerate()](https://docs.astro.build/en/reference/api-reference/#regenerate) or destroyed with [session.destroy()](https://docs.astro.build/en/reference/api-reference/#destroy).

For many use cases, you will only need to use [session.get()](https://docs.astro.build/en/reference/api-reference/#get) and [session.set()](https://docs.astro.build/en/reference/api-reference/#set).

See [the Sessions API reference](https://docs.astro.build/en/reference/api-reference/#session) for more details.

### Astro components and pages

[Section titled ‚ÄúAstro components and pages‚Äù](#astro-components-and-pages)

In `.astro` components and pages, you can access the session object via the global `Astro` object. For example, to display the number of items in a shopping cart:

 src/components/CartButton.astro

```
---export const prerender = false; // Not needed with 'server' outputconst cart = await Astro.session?.get('cart');---
<a href="/checkout">üõí {cart?.length ?? 0} items</a>
```

### API endpoints

[Section titled ‚ÄúAPI endpoints‚Äù](#api-endpoints)

In API endpoints, the session object is available on the `context` object. For example, to add an item to a shopping cart:

 src/pages/api/addToCart.ts

```
export async function POST(context: APIContext) {  const cart = await context.session?.get('cart') || [];  const data = await context.request.json<{ item: string }>();  if(!data?.item) {    return new Response('Item is required', { status: 400 });  }  cart.push(data.item);  await context.session?.set('cart', cart);  return Response.json(cart);}
```

### Actions

[Section titled ‚ÄúActions‚Äù](#actions)

In actions, the session object is available on the `context` object. For example, to add an item to a shopping cart:

 src/actions/addToCart.ts

```
import { defineAction } from 'astro:actions';import { z } from 'astro/zod';
export const server = {  addToCart: defineAction({    input: z.object({ productId: z.string() }),    handler: async (input, context) => {      const cart = await context.session?.get('cart');      cart.push(input.productId);      await context.session?.set('cart', cart);      return cart;    },  }),};
```

### Middleware

[Section titled ‚ÄúMiddleware‚Äù](#middleware)

In middleware, the session object is available on the `context` object. For example, to set the last visit time in the session:

 src/middleware.ts

```
import { defineMiddleware } from 'astro:middleware';
export const onRequest = defineMiddleware(async (context, next) => {  context.session?.set('lastVisit', new Date());  return next();});
```

## Session data types

[Section titled ‚ÄúSession data types‚Äù](#session-data-types)

By default session data is untyped, and you can store arbitrary data in any key. Values are serialized and deserialized using [devalue](https://github.com/Rich-Harris/devalue), which is the same library used in content collections and actions. This means that supported types are the same, and include strings, numbers, `Date`, `Map`, `Set`, `URL`, arrays, and plain objects.

You can optionally [define TypeScript types](https://docs.astro.build/en/guides/typescript/#extending-global-types) for your session data by creating a `src/env.d.ts` file and adding a declaration for the `App.SessionData` type:

 src/env.d.ts

```
declare namespace App {  interface SessionData {    user: {      id: string;      name: string;    };    cart: string[];  }}
```

This will allow you to access the session data with type-checking and auto-completion in your editor:

 src/components/CartButton.astro

```
---const cart = await Astro.session?.get('cart');// const cart: string[] | undefined
const something = await Astro.session?.get('something');// const something: any
Astro.session?.set('user', { id: 1, name: 'Houston' });// Error: Argument of type '{ id: number; name: string }' is not assignable to parameter of type '{ id: string; name: string; }'.---
```

  Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Styles and CSS

> Learn how to style components in Astro with scoped styles, external CSS, and tooling like Sass and PostCSS.

# Styles and CSS

Astro was designed to make styling and writing CSS a breeze. Write your own CSS directly inside of an Astro component or import your favorite CSS library like [Tailwind](https://tailwindcss.com/docs/installation/framework-guides/astro). Advanced styling languages like [Sass](https://sass-lang.com/) and [Less](https://lesscss.org/) are also supported.

## Styling in Astro

[Section titled ‚ÄúStyling in Astro‚Äù](#styling-in-astro)

Styling an Astro component is as easy as adding a `<style>` tag to your component or page template. When you place a `<style>` tag inside of an Astro component, Astro will detect the CSS and handle your styles for you, automatically.

 src/components/MyComponent.astro

```
<style>  h1 { color: red; }</style>
```

### Scoped Styles

[Section titled ‚ÄúScoped Styles‚Äù](#scoped-styles)

Astro `<style>` CSS rules are automatically **scoped by default**. Scoped styles are compiled behind-the-scenes to only apply to HTML written inside of that same component. The CSS that you write inside of an Astro component is automatically encapsulated inside of that component.

This CSS:

 src/pages/index.astro

```
<style>  h1 {    color: red;  }
  .text {    color: blue;  }</style>
```

Compiles to this:

```
<style>  h1[data-astro-cid-hhnqfkh6] {     color: red;  }
  .text[data-astro-cid-hhnqfkh6] {    color: blue;  }</style>
```

Scoped styles don‚Äôt leak and won‚Äôt impact the rest of your site. In Astro, it is okay to use low-specificity selectors like `h1 {}` or `p {}` because they will be compiled with scopes in the final output.

Scoped styles also won‚Äôt apply to other Astro components contained inside of your template. If you need to style a child component, consider wrapping that component in a `<div>` (or other element) that you can then style.

The specificity of scoped styles is preserved, allowing them to work consistently alongside other CSS files or CSS libraries while still preserving the exclusive boundaries that prevent styles from applying outside the component.

### Global Styles

[Section titled ‚ÄúGlobal Styles‚Äù](#global-styles)

While we recommend scoped styles for most components, you may eventually find a valid reason to write global, unscoped CSS. You can opt-out of automatic CSS scoping with the `<style is:global>` attribute.

 src/components/GlobalStyles.astro

```
<style is:global>  /* Unscoped, delivered as-is to the browser.     Applies to all <h1> tags on your site. */  h1 { color: red; }</style>
```

You can also mix global & scoped CSS rules together in the same `<style>` tag using the `:global()` selector. This becomes a powerful pattern for applying CSS styles to children of your component.

 src/components/MixedStyles.astro

```
<style>  /* Scoped to this component, only. */  h1 { color: red; }  /* Mixed: Applies to child `h1` elements only. */  article :global(h1) {    color: blue;  }</style><h1>Title</h1><article><slot /></article>
```

This is a great way to style things like blog posts, or documents with CMS-powered content where the contents live outside of Astro. But be careful: components whose appearance differs based on whether or not they have a certain parent component can become difficult to troubleshoot.

Scoped styles should be used as often as possible. Global styles should be used only as-needed.

### Combining classes withclass:list

[Section titled ‚ÄúCombining classes with class:list‚Äù](#combining-classes-with-classlist)

If you need to combine classes on an element dynamically, you can use the `class:list` utility attribute in `.astro` files.

 src/components/ClassList.astro

```
---const { isRed } = Astro.props;---<div class:list={['box', { red: isRed }]}><slot /></div>
<style>  .box { border: 1px solid blue; }  .red { border-color: red; }</style>
```

   See our [directives reference](https://docs.astro.build/en/reference/directives-reference/#classlist) page to learn more about `class:list`.

### CSS Variables

[Section titled ‚ÄúCSS Variables‚Äù](#css-variables)

**Added in:** `astro@0.21.0`

The Astro `<style>` can reference any CSS variables available on the page. You can also pass CSS variables directly from your component frontmatter using the `define:vars` directive.

 src/components/DefineVars.astro

```
---const foregroundColor = "rgb(221 243 228)";const backgroundColor = "rgb(24 121 78)";---<style define:vars={{ foregroundColor, backgroundColor }}>  h1 {    background-color: var(--backgroundColor);    color: var(--foregroundColor);  }</style><h1>Hello</h1>
```

   See our [directives reference](https://docs.astro.build/en/reference/directives-reference/#definevars) page to learn more about `define:vars`.

### Passing aclassto a child component

[Section titled ‚ÄúPassing a class to a child component‚Äù](#passing-a-class-to-a-child-component)

In Astro, HTML attributes like `class` do not automatically pass through to child components.

Instead, accept a `class` prop in the child component and apply it to the root element. When destructuring, you must rename it, because `class` is a [reserved word](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words) in JavaScript.

Using the default scoped style strategy, you must also pass the `data-astro-cid-*` attribute. You can do this by passing the `...rest` of the props to the component. If you have changed `scopedStyleStrategy` to `'class'` or `'where'`, the `...rest` prop is not necessary.

 src/components/MyComponent.astro

```
---const { class: className, ...rest } = Astro.props;---<div class={className} {...rest}>  <slot/></div>
```

 src/pages/index.astro

```
---import MyComponent from "../components/MyComponent.astro"---<style>  .red {    color: red;  }</style><MyComponent class="red">This will be red!</MyComponent>
```

### Inline styles

[Section titled ‚ÄúInline styles‚Äù](#inline-styles)

You can style HTML elements inline using the `style` attribute. This can be a CSS string or an object of CSS properties:

 src/pages/index.astro

```
// These are equivalent:<p style={{ color: "brown", textDecoration: "underline" }}>My text</p><p style="color: brown; text-decoration: underline;">My text</p>
```

## External Styles

[Section titled ‚ÄúExternal Styles‚Äù](#external-styles)

There are two ways to resolve external global stylesheets: an ESM import for files located within your project source, and an absolute URL link for files in your `public/` directory, or hosted outside of your project.

   Read more about using [static assets](https://docs.astro.build/en/guides/imports/) located in `public/` or `src/`.

### Import a local stylesheet

[Section titled ‚ÄúImport a local stylesheet‚Äù](#import-a-local-stylesheet)

You can import stylesheets in your Astro component frontmatter using ESM import syntax. CSS imports work like [any other ESM import in an Astro component](https://docs.astro.build/en/basics/astro-components/#the-component-script), which should be referenced as **relative to the component** and must be written at the **top** of your component script, with any other imports.

 src/pages/index.astro

```
---// Astro will bundle and optimize this CSS for you automatically// This also works for preprocessor files like .scss, .styl, etc.import '../styles/utils.css';---<html></html>
```

CSS `import` via ESM are supported inside of any JavaScript file, including JSX components like React & Preact.  This can be useful for writing granular, per-component styles for your React components.

### Import a stylesheet from an npm package

[Section titled ‚ÄúImport a stylesheet from an npm package‚Äù](#import-a-stylesheet-from-an-npm-package)

You may also need to load stylesheets from an external npm package. This is especially common for utilities like [Open Props](https://open-props.style/). If your package **recommends using a file extension** (i.e. `package-name/styles.css` instead of `package-name/styles`), this should work like any local stylesheet:

 src/pages/random-page.astro

```
---import 'package-name/styles.css';---<html></html>
```

If your package **does not suggest using a file extension** (i.e. `package-name/styles`), you‚Äôll need to update your Astro config first!

Say you are importing a CSS file from `package-name` called `normalize` (with the file extension omitted). To ensure we can prerender your page correctly, add `package-name` to [thevite.ssr.noExternalarray](https://vite.dev/config/ssr-options.html#ssr-noexternal):

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  vite: {    ssr: {      noExternal: ['package-name'],    }  }})
```

Now, you are free to import `package-name/normalize`. This will be bundled and optimized by Astro like any other local stylesheet.

 src/pages/random-page.astro

```
---import 'package-name/normalize';---<html></html>
```

### Load a static stylesheet via ‚Äúlink‚Äù tags

[Section titled ‚ÄúLoad a static stylesheet via ‚Äúlink‚Äù tags‚Äù](#load-a-static-stylesheet-via-link-tags)

You can also use the `<link>` element to load a stylesheet on the page. This should be an absolute URL path to a CSS file located in your `/public` directory, or an URL to an external website. Relative `<link>` href values are not supported.

 src/pages/index.astro

```
<head>    <link rel="stylesheet" href="/styles/global.css" />    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.css" /></head>
```

Because this approach uses the `public/` directory, it skips the normal CSS processing, bundling and optimizations that are provided by Astro. If you need these transformations, use the [Import a Stylesheet](#import-a-local-stylesheet) method above.

## Cascading Order

[Section titled ‚ÄúCascading Order‚Äù](#cascading-order)

Astro components will sometimes have to evaluate multiple sources of CSS. For example, your component might import a CSS stylesheet, include its own `<style>` tag, *and* be rendered inside a layout that imports CSS.

When conflicting CSS rules apply to the same element, browsers first use *specificity* and then *order of appearance* to determine which value to show.

If one rule is more *specific* than another, no matter where the CSS rule appears, its value will take precedence:

 src/components/MyComponent.astro

```
<style>  h1 { color: red }  div > h1 {    color: purple  }</style><div>  <h1>    This header will be purple!  </h1></div>
```

If two rules have the same specificity, then the *order of appearance* is evaluated, and the last rule‚Äôs value will take precedence:

 src/components/MyComponent.astro

```
<style>  h1 { color: purple }  h1 { color: red }</style><div>  <h1>    This header will be red!  </h1></div>
```

Astro CSS rules are evaluated in this order of appearance:

- **<link>tags in the head** (lowest precedence)
- **imported styles**
- **scoped styles** (highest precedence)

### Scoped Styles

[Section titled ‚ÄúScoped Styles‚Äù](#scoped-styles-1)

Depending on your chosen value for [scopedStyleStrategy](https://docs.astro.build/en/reference/configuration-reference/#scopedstylestrategy), scoped styles may or may not increase the [CLASS column specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity#class_column).

However, [scoped styles](#scoped-styles) will always come last in the order of appearance. These styles will therefore take precedence over other styles of the same specificity. For example, if you import a stylesheet that conflicts with a scoped style, the scoped style‚Äôs value will apply:

 src/components/make-it-purple.css

```
h1 {  color: purple;}
```

 src/components/MyComponent.astro

```
---import "./make-it-purple.css"---<style>  h1 { color: red }</style><div>  <h1>    This header will be red!  </h1></div>
```

Scoped styles will be overwritten if the imported style is more specific. The style with a higher specificity will take precedence over the scoped style:

 src/components/make-it-purple.css

```
#intro {  color: purple;}
```

 src/components/MyComponent.astro

```
---import "./make-it-purple.css"---<style>  h1 { color: red }</style><div>  <h1 id="intro">    This header will be purple!  </h1></div>
```

### Import Order

[Section titled ‚ÄúImport Order‚Äù](#import-order)

When importing multiple stylesheets in an Astro component, the CSS rules are evaluated in the order that they are imported. A higher specificity will always determine which styles to show, no matter when the CSS is evaluated. But, when conflicting styles have the same specificity, the *last one imported* wins:

 src/components/make-it-purple.css

```
div > h1 {  color: purple;}
```

 src/components/make-it-green.css

```
div > h1 {  color: green;}
```

 src/components/MyComponent.astro

```
---import "./make-it-green.css"import "./make-it-purple.css"---<style>  h1 { color: red }</style><div>  <h1>    This header will be purple!  </h1></div>
```

While `<style>` tags are scoped and only apply to the component that declares them, *imported* CSS can ‚Äúleak‚Äù. Importing a component applies any CSS it imports, even if the component is never used:

 src/components/PurpleComponent.astro

```
---import "./make-it-purple.css"---<div>  <h1>I import purple CSS.</h1></div>
```

 src/components/MyComponent.astro

```
---import "./make-it-green.css"import PurpleComponent from "./PurpleComponent.astro";---<style>  h1 { color: red }</style><div>  <h1>    This header will be purple!  </h1></div>
```

### Link Tags

[Section titled ‚ÄúLink Tags‚Äù](#link-tags)

Style sheets loaded via [link tags](#load-a-static-stylesheet-via-link-tags) are evaluated in order, before any other styles in an Astro file. Therefore, these styles will have lower precedence than imported stylesheets and scoped styles:

 src/pages/index.astro

```
---import "../components/make-it-purple.css"---
<html lang="en">  <head>    <meta charset="utf-8" />    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />    <meta name="viewport" content="width=device-width" />    <meta name="generator" content={Astro.generator} />    <title>Astro</title>    <link rel="stylesheet" href="/styles/make-it-blue.css" />  </head>  <body>    <div>      <h1>This will be purple</h1>    </div>  </body></html>
```

## Tailwind

[Section titled ‚ÄúTailwind‚Äù](#tailwind)

Astro comes with support for adding popular CSS libraries, tools, and frameworks to your project like [Tailwind](https://tailwindcss.com) and more!

Astro supports both Tailwind 3 and 4. You can [add Tailwind 4 support through a Vite plugin](#add-tailwind-4) to your project with a CLI command, or install legacy dependencies manually to add [Tailwind 3 support through an Astro integration](#legacy-tailwind-3-support).

To [upgrade your Astro project from Tailwind 3 to 4](#upgrade-from-tailwind-3) you will need to both add Tailwind 4 support, and remove legacy Tailwind 3 support.

### Add Tailwind 4

[Section titled ‚ÄúAdd Tailwind 4‚Äù](#add-tailwind-4)

In Astro `>=5.2.0`, use the `astro add tailwind` command for your package manager to install the official Vite Tailwind plugin. To add Tailwind 4 support to earlier versions of Astro, follow the [instructions in the Tailwind docs](https://tailwindcss.com/docs/installation/framework-guides/astro) to add the `@tailwindcss/vite` Vite plugin manually.

- [npm](#tab-panel-1836)
- [pnpm](#tab-panel-1837)
- [Yarn](#tab-panel-1838)

   Terminal window

```
npx astro add tailwind
```

   Terminal window

```
pnpm astro add tailwind
```

   Terminal window

```
yarn astro add tailwind
```

Then, import `tailwindcss` into `src/styles/global.css` (or another CSS file of your choosing) to make Tailwind classes available to your Astro project. This file including the import will be created by default if you used the `astro add tailwind` command to install the Vite plugin.

 src/styles/global.css

```
@import "tailwindcss";
```

Import this file in the pages where you want Tailwind to apply. This is often done in a layout component so that Tailwind styles can be used on all pages sharing that layout:

 src/layouts/Layout.astro

```
---import "../styles/global.css";---
```

### Upgrade from Tailwind 3

[Section titled ‚ÄúUpgrade from Tailwind 3‚Äù](#upgrade-from-tailwind-3)

Follow the steps to update an existing Astro project using Tailwind v3 (using the `@astrojs/tailwind` integration) to Tailwind 4 (using [the@tailwindcss/viteplugin](https://tailwindcss.com/docs/installation/framework-guides/astro)).

1. [Add Tailwind 4 support to your project](#add-tailwind-4) through the CLI for the latest version of Astro, or by adding the Vite plugin manually.
2. Uninstall the `@astrojs/tailwind` integration from your project:
  - [npm](#tab-panel-1839)
  - [pnpm](#tab-panel-1840)
  - [Yarn](#tab-panel-1841)
     Terminal window
  ```
  npm uninstall @astrojs/tailwind
  ```
     Terminal window
  ```
  pnpm remove @astrojs/tailwind
  ```
     Terminal window
  ```
  yarn remove @astrojs/tailwind
  ```
3. Remove the `@astrojs/tailwind` integration from your `astro.config.mjs`:
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';import tailwind from '@astrojs/tailwind';
  export default defineConfig({  // ...  integrations: [tailwind()],  // ...});
  ```
4. Then, upgrade your project according to [Tailwind‚Äôs v4 upgrade guide](https://tailwindcss.com/docs/upgrade-guide#changes-from-v3).

### Legacy Tailwind 3 support

[Section titled ‚ÄúLegacy Tailwind 3 support‚Äù](#legacy-tailwind-3-support)

To add (or keep) support for Tailwind 3, you will need to have both `tailwindcss@3` and the official Astro Tailwind integration `@astrojs/tailwind` installed. Installing these dependencies manually is only used for legacy Tailwind 3 compatibility, and is not required for Tailwind 4. You will also need a [legacy Tailwind configuration](https://v3.tailwindcss.com/docs/configuration#creating-your-configuration-file):

1. Install Tailwind and the Astro Tailwind integration to your project dependencies using your preferred package manager:
  - [npm](#tab-panel-1842)
  - [pnpm](#tab-panel-1843)
  - [Yarn](#tab-panel-1844)
     Terminal window
  ```
  npm install tailwindcss@3 @astrojs/tailwind
  ```
     Terminal window
  ```
  pnpm add tailwindcss@3 @astrojs/tailwind
  ```
     Terminal window
  ```
  yarn add tailwindcss@3 @astrojs/tailwind
  ```
2. Import the integration to your `astro.config.mjs` file, and add it to your `integrations[]` array:
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';import tailwind from '@astrojs/tailwind';
  export default defineConfig({  // ...  integrations: [tailwind()],  // ...});
  ```
3. Create a `tailwind.config.mjs` file in your project‚Äôs root directory. You can use the following command to generate a basic configuration file for you:
  - [npm](#tab-panel-1845)
  - [pnpm](#tab-panel-1846)
  - [Yarn](#tab-panel-1847)
     Terminal window
  ```
  npx tailwindcss init
  ```
     Terminal window
  ```
  pnpm dlx tailwindcss init
  ```
     Terminal window
  ```
  yarn dlx tailwindcss init
  ```
4. Add the following basic configuration to your `tailwind.config.mjs` file:
   tailwind.config.mjs
  ```
  /** @type {import('tailwindcss').Config} */export default {  content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],  theme: {    extend: {},  },  plugins: [],};
  ```

   ![](https://docs.astro.build/houston_chef.webp) **Related recipe:** [Style rendered Markdown with Tailwind Typography](https://docs.astro.build/en/recipes/tailwind-rendered-markdown/)

## CSS Preprocessors

[Section titled ‚ÄúCSS Preprocessors‚Äù](#css-preprocessors)

Astro supports CSS preprocessors such as [Sass](https://sass-lang.com/), [Stylus](https://stylus-lang.com/), and [Less](https://lesscss.org/) through [Vite](https://vite.dev/guide/features.html#css-pre-processors).

### Sass and SCSS

[Section titled ‚ÄúSass and SCSS‚Äù](#sass-and-scss) Terminal window

```
npm install sass
```

Use `<style lang="scss">` or `<style lang="sass">` in `.astro` files.

### Stylus

[Section titled ‚ÄúStylus‚Äù](#stylus) Terminal window

```
npm install stylus
```

Use `<style lang="styl">` or `<style lang="stylus">` in `.astro` files.

### Less

[Section titled ‚ÄúLess‚Äù](#less) Terminal window

```
npm install less
```

Use `<style lang="less">` in `.astro` files.

### LightningCSS

[Section titled ‚ÄúLightningCSS‚Äù](#lightningcss) Terminal window

```
npm install lightningcss
```

Update your `vite` configuration in `astro.config.mjs`:

 astro.config.mjs

```
import { defineConfig } from 'astro/config'
export default defineConfig({  vite: {    css: {      transformer: "lightningcss",    },  },})
```

### In framework components

[Section titled ‚ÄúIn framework components‚Äù](#in-framework-components)

You can also use all of the above CSS preprocessors within JS frameworks as well! Be sure to follow the patterns each framework recommends:

- **React** / **Preact**: `import Styles from './styles.module.scss';`
- **Vue**: `<style lang="scss">`
- **Svelte**: `<style lang="scss">`

## PostCSS

[Section titled ‚ÄúPostCSS‚Äù](#postcss)

Astro comes with PostCSS included as part of [Vite](https://vite.dev/guide/features.html#postcss). To configure PostCSS for your project, create a `postcss.config.cjs` file in the project root. You can import plugins using `require()` after installing them (for example `npm install autoprefixer`).

 postcss.config.cjs

```
module.exports = {  plugins: [    require('autoprefixer'),    require('cssnano'),  ],};
```

## Frameworks and Libraries

[Section titled ‚ÄúFrameworks and Libraries‚Äù](#frameworks-and-libraries)

### üìò React / Preact

[Section titled ‚Äúüìò React / Preact‚Äù](#-react--preact)

`.jsx` files support both global CSS and CSS Modules. To enable the latter, use the `.module.css` extension (or `.module.scss`/`.module.sass` if using Sass).

 src/components/MyReactComponent.jsx

```
import './global.css'; // include global CSSimport Styles from './styles.module.css'; // Use CSS Modules (must end in `.module.css`, `.module.scss`, or `.module.sass`!)
```

### üìó Vue

[Section titled ‚Äúüìó Vue‚Äù](#-vue)

Vue in Astro supports the same methods as `vue-loader` does:

- [vue-loader - Scoped CSS](https://vue-loader.vuejs.org/guide/scoped-css.html)
- [vue-loader - CSS Modules](https://vue-loader.vuejs.org/guide/css-modules.html)

### üìï Svelte

[Section titled ‚Äúüìï Svelte‚Äù](#-svelte)

Svelte in Astro also works exactly as expected: [Svelte Styling Docs](https://svelte.dev/docs#component-format-style).

## Markdown Styling

[Section titled ‚ÄúMarkdown Styling‚Äù](#markdown-styling)

Any Astro styling methods are available to a [Markdown layout component](https://docs.astro.build/en/basics/layouts/#markdown-layouts), but different methods will have different styling effects on your page.

You can apply global styles to your Markdown content by adding [imported stylesheets](#external-styles) to the layout that wraps your page content. It is also possible to style your Markdown with [<style is:global>tags](#global-styles) in the layout component.  Note that any styles added are subject to [Astro‚Äôs cascading order](#cascading-order), and you should check your rendered page carefully to ensure your styles are being applied as intended.

You can also add CSS integrations including [Tailwind](https://docs.astro.build/en/recipes/tailwind-rendered-markdown/). If you are using Tailwind, the [typography plugin](https://tailwindcss.com/docs/typography-plugin) can be useful for styling Markdown.

## Production

[Section titled ‚ÄúProduction‚Äù](#production)

### Bundle control

[Section titled ‚ÄúBundle control‚Äù](#bundle-control)

When Astro builds your site for production deployment, it minifies and combines your CSS into chunks. Each page on your site gets its own chunk, and additionally, CSS that is shared between multiple pages is further split off into their own chunks for reuse.

However, when you have several pages sharing styles, some shared chunks can become really small. If all of them were sent separately, it would lead to many stylesheets requests and affect site performance. Therefore, by default Astro will link only those in your HTML above 4kB in size as `<link rel="stylesheet">` tags, while inlining smaller ones into `<style type="text/css">`. This approach provides a balance between the number of additional requests and the volume of CSS that can be cached between pages.

You can configure the size at which stylesheets will be linked externally (in bytes) using the `assetsInlineLimit` vite build option. Note that this option affects script and image inlining as well.

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  vite: {    build: {      assetsInlineLimit: 1024,    }  };});
```

If you would rather all project styles remain external, you can configure the `inlineStylesheets` build option.

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  build: {    inlineStylesheets: 'never'  }});
```

You can also set this option to `'always'` which will inline all stylesheets.

## Advanced

[Section titled ‚ÄúAdvanced‚Äù](#advanced)

### ?rawCSS Imports

[Section titled ‚Äú?raw CSS Imports‚Äù](#raw-css-imports)

For advanced use cases, CSS can be read directly from disk without being bundled or optimized by Astro. This can be useful when you need complete control over some snippet of CSS, and need to bypass Astro‚Äôs automatic CSS handling.

This is not recommended for most users.

 src/components/RawInlineStyles.astro

```
---// Advanced example! Not recommended for most users.import rawStylesCSS from '../styles/main.css?raw';---<style is:inline set:html={rawStylesCSS}></style>
```

See [Vite‚Äôs docs](https://vite.dev/guide/assets.html#importing-asset-as-string) for full details.

### ?urlCSS Imports

[Section titled ‚Äú?url CSS Imports‚Äù](#url-css-imports)

For advanced use cases, you can import a direct URL reference for a CSS file inside of your project `src/` directory. This can be useful when you need complete control over how a CSS file is loaded on the page. However, this will prevent the optimization of that CSS file with the rest of your page CSS .

This is not recommended for most users. Instead, place your CSS files inside of `public/` to get a consistent URL reference.

  src/components/RawStylesUrl.astro

```
---// Advanced example! Not recommended for most users.import stylesUrl from '../styles/main.css?url';---<link rel="preload" href={stylesUrl} as="style"><link rel="stylesheet" href={stylesUrl}>
```

See [Vite‚Äôs docs](https://vite.dev/guide/assets.html#importing-asset-as-url) for full details.

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
