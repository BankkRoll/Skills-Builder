# Syntax Highlighting and more

# Syntax Highlighting

> Learn how to highlight your code blocks in Astro.

# Syntax Highlighting

Astro comes with built-in support for [Shiki](https://shiki.style/) and [Prism](https://prismjs.com/). This provides syntax highlighting for:

- all [code fences (```)](#markdown-code-blocks) used in a Markdown or MDX file.
- content within the [built-in<Code />component](#code-) (powered by Shiki) in `.astro` files.
- content within the [<Prism />component](#prism-) (powered by Prism) in `.astro` files.

Add [community integrations such as Expressive Code](https://astro.build/integrations/?search=syntax+highlight) for even more text marking and annotation options in your code blocks.

## Markdown code blocks

[Section titled “Markdown code blocks”](#markdown-code-blocks)

A Markdown code block is indicated by a block with three backticks ``` at the start and end. You can indicate the programming language being used after the opening backticks to indicate how to color and style your code to make it easier to read.

```
```js// Javascript code with syntax highlighting.var fun = function lang(l) {  dateformat.i18n = require('./lang/' + l);  return true;};```
```

Astro’s Markdown code blocks are styled by Shiki by default, preconfigured with the `github-dark` theme. The compiled output will be limited to inline `style`s without any extraneous CSS classes, stylesheets, or client-side JS.

You can [add a Prism stylesheet and switch to Prism’s highlighting](#add-a-prism-stylesheet), or disable Astro’s syntax highlighting entirely, with the [markdown.syntaxHighlight](https://docs.astro.build/en/reference/configuration-reference/#markdownsyntaxhighlight) configuration option.

   See the full [markdown.shikiConfigreference](https://docs.astro.build/en/reference/configuration-reference/#markdownshikiconfig) for the complete set of Markdown syntax highlighting options available when using Shiki.

### Setting a default Shiki theme

[Section titled “Setting a default Shiki theme”](#setting-a-default-shiki-theme)

You can configure any [built-in Shiki theme](https://shiki.style/themes) for your Markdown code blocks in your Astro config:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  markdown: {    shikiConfig: {      theme: 'dracula',    },  },});
```

   See the full [Shiki config reference](https://docs.astro.build/en/reference/configuration-reference/#markdownshikiconfig) for the complete set of Markdown code block options.

### Setting light and dark mode themes

[Section titled “Setting light and dark mode themes”](#setting-light-and-dark-mode-themes)

You can specify dual Shiki themes for light and dark mode in your Astro config:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  markdown: {    shikiConfig: {      themes: {        light: 'github-light',        dark: 'github-dark',      },    },  },});
```

Then, [add Shiki’s dark mode CSS variables via media query or classes](https://shiki.style/guide/dual-themes#query-based-dark-mode) to apply to all your Markdown code blocks by default. Replace the `.shiki` class in the examples from Shiki’s documentation with `.astro-code`:

 src/styles/global.css

```
@media (prefers-color-scheme: dark) {  .shiki,  .shiki span {  .astro-code,  .astro-code span {    color: var(--shiki-dark) !important;    background-color: var(--shiki-dark-bg) !important;    /* Optional, if you also want font styles */    font-style: var(--shiki-dark-font-style) !important;    font-weight: var(--shiki-dark-font-weight) !important;    text-decoration: var(--shiki-dark-text-decoration) !important;  }}
```

   See the full [Shiki config reference](https://docs.astro.build/en/reference/configuration-reference/#markdownshikiconfig) for the complete set of Markdown code block options.

### Adding your own Shiki theme

[Section titled “Adding your own Shiki theme”](#adding-your-own-shiki-theme)

Instead of using one of Shiki’s predefined themes, you can import a custom Shiki theme from a local file.

 astro.config.mjs

```
import { defineConfig } from 'astro/config';import customTheme from './my-shiki-theme.json';
export default defineConfig({  markdown: {    shikiConfig: {      theme: customTheme,    },  },});
```

### Customizing Shiki themes

[Section titled “Customizing Shiki themes”](#customizing-shiki-themes)

You can follow [Shiki’s own theme documentation](https://shiki.style/themes) for more customization options for themes, [light vs dark mode toggles](https://shiki.style/guide/dual-themes), or styling via [CSS variables](https://shiki.style/guide/theme-colors#css-variables-theme).

You will need to adjust the examples from Shiki’s documentation for your Astro project by making the following substitutions:

- Code blocks are styled using the `.astro-code` class instead of `.shiki`
- When using the `css-variables` theme, custom properties are prefixed with `--astro-code-` instead of `--shiki-`

## Components for code blocks

[Section titled “Components for code blocks”](#components-for-code-blocks)

There are two Astro components available for `.astro` and `.mdx` files to render code blocks: [<Code />](#code-) and [<Prism />](#prism-).

You can reference the `Props` of these components using the [ComponentPropstype](https://docs.astro.build/en/guides/typescript/#componentprops-type) utility.

### <Code />

[Section titled “<Code />”](#code-)

This component is powered internally by Shiki. It supports all popular Shiki themes and languages as well as several other Shiki options such as custom themes, languages, [transformers](#transformers), and default colors.

These values are passed to the `<Code />` component using the `theme`, `lang`, `transformers`, and `defaultColor` attributes respectively as props. The `<Code />` component will not inherit your `shikiConfig` settings for Markdown code blocks.

```
---import { Code } from 'astro:components';---<Code code={`const foo = 'bar';`} lang="js" /><Code code={`const foo = 'bar';`} lang="js" theme="dark-plus" /><Code code={`const foo = 'bar';`} lang="js" wrap /><p>  <Code code={`const foo = 'bar';`} lang="js" inline />  will be rendered inline.</p><Code code={`const foo = 'bar';`} lang="js" defaultColor={false} />
```

#### Transformers

[Section titled “Transformers”](#transformers)

**Added in:** `astro@4.11.0`

[Shiki transformers](https://shiki.style/packages/transformers#shikijs-transformers) can optionally be applied to code by passing them in through the `transformers` property as an array. Since Astro v4.14.0, you can also provide a string for [Shiki’smetaattribute](https://shiki.style/guide/transformers#meta) to pass options to transformers.

Note that `transformers` only applies classes and you must provide your own CSS rules to target the elements of your code block.

 src/pages/index.astro

```
---import { transformerNotationFocus, transformerMetaHighlight } from '@shikijs/transformers'import { Code } from 'astro:components'const code = `const foo = 'hello'const bar = ' world'console.log(foo + bar) // [!code focus]`---<Code  code={code}  lang="js"  transformers={[transformerMetaHighlight()]}  meta="{1,3}"/>
<style is:global>  pre.has-focused .line:not(.focused) {    filter: blur(1px);  }</style>
```

### <Prism />

[Section titled “<Prism />”](#prism-)

This component provides language-specific syntax highlighting for code blocks by applying Prism’s CSS classes. Note that you must [provide a Prism CSS stylesheet](#add-a-prism-stylesheet) (or bring your own) to style the classes.

To use the `Prism` highlighter component, you must install the `@astrojs/prism` package:

- [npm](#tab-panel-1848)
- [pnpm](#tab-panel-1849)
- [Yarn](#tab-panel-1850)

   Terminal window

```
npm install @astrojs/prism
```

   Terminal window

```
pnpm add @astrojs/prism
```

   Terminal window

```
yarn add @astrojs/prism
```

Then, you can import and use the `<Prism />` component like any other Astro component, passing a language and the code to render.

```
---import { Prism } from '@astrojs/prism';---<Prism lang="js" code={`const foo = 'bar';`} />
```

In addition to the [list of languages supported by Prism](https://prismjs.com/#supported-languages), you can also use `lang="astro"` to display Astro code blocks.

## Add a Prism stylesheet

[Section titled “Add a Prism stylesheet”](#add-a-prism-stylesheet)

If you opt to use Prism (either by configuring `markdown.syntaxHighlight: 'prism'` or with the `<Prism />` component), Astro will apply Prism’s CSS classes instead of Shiki’s to your code. You will need to bring your own CSS stylesheet for syntax highlighting to appear.

1. Choose a premade stylesheet from the available [Prism Themes](https://github.com/PrismJS/prism-themes).
2. Add this stylesheet to [your project’spublic/directory](https://docs.astro.build/en/basics/project-structure/#public).
3. Load this into your page’s `<head>` in a [layout component](https://docs.astro.build/en/basics/layouts/) via a `<link>` tag. (See [Prism basic usage](https://prismjs.com/#basic-usage).)

You can also visit the [list of languages supported by Prism](https://prismjs.com/#supported-languages) for options and usage.

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Testing

> An intro to testing in Astro

# Testing

Testing helps you write and maintain working Astro code. Astro supports many popular tools for unit tests, component tests, and end-to-end tests including Jest, Mocha, Jasmine, [Cypress](https://cypress.io) and [Playwright](https://playwright.dev). You can even install framework-specific testing libraries such as React Testing Library to test your UI framework components.

Testing frameworks allow you to state **assertions** or **expectations** about how your code should behave in specific situations, then compare these to the actual behavior of your current code.

## Unit and integration tests

[Section titled “Unit and integration tests”](#unit-and-integration-tests)

### Vitest

[Section titled “Vitest”](#vitest)

A Vite-native unit test framework with ESM, TypeScript and JSX support powered by esbuild.

Use Astro’s `getViteConfig()` helper in your [vitest.config.tsconfiguration file](https://vitest.dev/config/) to set up Vitest with your Astro project’s settings:

 vitest.config.ts

```
/// <reference types="vitest/config" />import { getViteConfig } from 'astro/config';
export default getViteConfig({  test: {    // Vitest configuration options  },});
```

By default, `getViteConfig()` will try to load an Astro config file in your project and apply it to the test environment.
As of Astro 4.8, if you need to customize the Astro configuration applied in your tests, pass a second argument to `getViteConfig()`:

```
export default getViteConfig(  { test: { /* Vitest configuration options */ } },  {    site: 'https://example.com/',    trailingSlash: 'always',  },);
```

See the [Astro + Vitest starter template](https://github.com/withastro/astro/tree/latest/examples/with-vitest) on GitHub.

#### Vitest and Container API

[Section titled “Vitest and Container API”](#vitest-and-container-api)

**Added in:** `astro@4.9.0`

You can natively test Astro components using the [container API](https://docs.astro.build/en/reference/container-reference/). First, setup [vitestas explained above](#vitest), then create a `.test.js` file to test your component:

 example.test.js

```
import { experimental_AstroContainer as AstroContainer } from 'astro/container';import { expect, test } from 'vitest';import Card from '../src/components/Card.astro';
test('Card with slots', async () => {  const container = await AstroContainer.create();  const result = await container.renderToString(Card, {    slots: {      default: 'Card content',    },  });
  expect(result).toContain('This is a card');  expect(result).toContain('Card content');});
```

## End-to-end tests

[Section titled “End-to-end tests”](#end-to-end-tests)

### Playwright

[Section titled “Playwright”](#playwright)

Playwright is an end-to-end testing framework for modern web apps. Use the Playwright API in JavaScript or TypeScript to test your Astro code on all modern rendering engines including Chromium, WebKit, and Firefox.

#### Installation

[Section titled “Installation”](#installation)

You can get started and run your tests using the [VS Code Extension](https://playwright.dev/docs/getting-started-vscode).

Alternatively, you can install Playwright within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and add an optional GitHub Actions workflow.

- [npm](#tab-panel-1851)
- [pnpm](#tab-panel-1852)
- [Yarn](#tab-panel-1853)

   Terminal window

```
npm init playwright@latest
```

   Terminal window

```
pnpm create playwright
```

   Terminal window

```
yarn create playwright
```

#### Create your first Playwright test

[Section titled “Create your first Playwright test”](#create-your-first-playwright-test)

1. Choose a page to test. This example will test the example page `index.astro` below.
   src/pages/index.astro
  ```
  ------<html lang="en">  <head>    <title>Astro is awesome!</title>    <meta name="description" content="Pull content from anywhere and serve it fast with Astro's next-gen islands architecture." />  </head>  <body></body></html>
  ```
2. Create a new folder and add the following test file in `src/test`. Copy and paste the following test into the file to verify that the page meta information is correct. Update the value of the page `<title>` to match the page you are testing.
   src/test/index.spec.ts
  ```
  import { test, expect } from '@playwright/test';
  test('meta is correct', async ({ page }) => {  await page.goto("http://localhost:4321/");
    await expect(page).toHaveTitle('Astro is awesome!');});
  ```

#### Running your Playwright tests

[Section titled “Running your Playwright tests”](#running-your-playwright-tests)

You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.

1. To run our test from the previous example using the command line, use the `test` command. Optionally, include the file name to run just the single test:
   Terminal window
  ```
  npx playwright test index.spec.ts
  ```
2. To see the full HTML Test Report, open it using the following command:
   Terminal window
  ```
  npx playwright show-report
  ```

##### Advanced: Launching a development web server during the tests

[Section titled “Advanced: Launching a development web server during the tests”](#advanced-launching-a-development-web-server-during-the-tests)

You can also have Playwright start your server when you run your testing script by using the [webServer](https://playwright.dev/docs/test-advanced#launching-a-development-web-server-during-the-tests) option in the Playwright configuration file.

Here is an example of the configuration and commands required when using npm:

1. Add a test script to your `package.json` file in the project root, such as `"test:e2e": "playwright test"`.
2. In `playwright.config.ts`, add the `webServer` object and update the command value to `npm run preview`.
   playwright.config.ts
  ```
  import { defineConfig } from '@playwright/test';
  export default defineConfig({  webServer: {    command: 'npm run preview',    url: 'http://localhost:4321/',    timeout: 120 * 1000,    reuseExistingServer: !process.env.CI,  },  use: {    baseURL: 'http://localhost:4321/',  },});
  ```
3. Run `npm run build`, then run `npm run test:e2e` to run the Playwright tests.

More information about Playwright can be found in the links below:

- [Getting started with Playwright](https://playwright.dev/docs/intro)
- [Use a development server](https://playwright.dev/docs/test-webserver#configuring-a-web-server)

### Cypress

[Section titled “Cypress”](#cypress)

Cypress is a front-end testing tool built for the modern web. Cypress enables you to write end-to-end tests for your Astro site.

#### Installation

[Section titled “Installation”](#installation-1)

You can install Cypress using the package manager of your choice. This will install Cypress locally as a dev dependency for your project.

- [npm](#tab-panel-1854)
- [pnpm](#tab-panel-1855)
- [Yarn](#tab-panel-1856)

   Terminal window

```
npm install cypress --save-dev
```

   Terminal window

```
pnpm add --save-dev cypress
```

   Terminal window

```
yarn add cypress --dev
```

#### Configuration

[Section titled “Configuration”](#configuration)

In the root of your project, create a `cypress.config.js` file with the following content:

 cypress.config.js

```
import { defineConfig } from 'cypress'
export default defineConfig({  e2e: {    supportFile: false  }})
```

#### Create your first Cypress test

[Section titled “Create your first Cypress test”](#create-your-first-cypress-test)

1. Choose a page to test. This example will test the example page `index.astro` below.
   src/pages/index.astro
  ```
  ------<html lang="en">  <head>    <title>Astro is awesome!</title>    <meta name="description" content="Pull content from anywhere and serve it fast with Astro's next-gen islands architecture." />  </head>  <body>  <h1>Hello world from Astro</h1>  </body></html>
  ```
2. Create an `index.cy.js` file in the `cypress/e2e` folder. Use the following test in the file to verify that the page title and header are correct.
   cypress/e2e/index.cy.js
  ```
  it('titles are correct', () => {  const page = cy.visit('http://localhost:4321');
    page.get('title').should('have.text', 'Astro is awesome!')  page.get('h1').should('have.text', 'Hello world from Astro');});
  ```

#### Running your Cypress tests

[Section titled “Running your Cypress tests”](#running-your-cypress-tests)

Cypress can be run from the command line or from the Cypress App. The App provides a visual interface for running and debugging your tests.

First, start the dev server so Cypress can access your live site.

To run our test from the previous example using the command line, execute the following command:

 Terminal window

```
npx cypress run
```

Alternatively, to run the test using the Cypress App, execute the following command:

 Terminal window

```
npx cypress open
```

Once the Cypress App is launched, choose **E2E Testing**, then select the browser to be used to run tests.

Once the test run is finished, you should see green check marks in the output confirming that your test passed:

 Output from npx cypress run

```
Running:  index.cy.js                                                                     (1 of 1)
✓ titles are correct (107ms)
1 passing (1s)
```

#### Next steps

[Section titled “Next steps”](#next-steps)

More information about Cypress can be found in the links below:

- [Introduction to Cypress](https://docs.cypress.io/guides/core-concepts/introduction-to-cypress)
- [Testing Your App](https://docs.cypress.io/guides/end-to-end-testing/testing-your-app)

### NightwatchJS

[Section titled “NightwatchJS”](#nightwatchjs)

Nightwatch.js is a test automation framework with a powerful set of tools to write, run, and debug your tests across the web with built-in support for all major browsers and their mobile equivalents, as well as native mobile applications.

#### Installation

[Section titled “Installation”](#installation-2)

You can install NightwatchJS within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and select whether or not to include component testing and testing on mobile browsers.

- [npm](#tab-panel-1857)
- [pnpm](#tab-panel-1858)
- [Yarn](#tab-panel-1859)

   Terminal window

```
npm init nightwatch@latest
```

   Terminal window

```
pnpm create nightwatch
```

   Terminal window

```
yarn create nightwatch
```

#### Create your first Nightwatch test

[Section titled “Create your first Nightwatch test”](#create-your-first-nightwatch-test)

1. Choose a page to test. This example will test the example page `index.astro` below.
   src/pages/index.astro
  ```
  ------<html lang="en">  <head>    <title>Astro is awesome!</title>    <meta name="description" content="Pull content from anywhere and serve it fast with Astro's next-gen islands architecture." />  </head>  <body></body></html>
  ```
2. Create a new folder `src/test/` and add the following test file:
   src/test/index.js
  ```
  describe('Astro testing with Nightwatch', function () {    before(browser => browser.navigateTo('http://localhost:4321/'));
      it("check that the title is correct", function (browser) {        browser.assert.titleEquals('Astro is awesome!')    });
      after(browser => browser.end());});
  ```

#### Running your NightwatchJS tests

[Section titled “Running your NightwatchJS tests”](#running-your-nightwatchjs-tests)

You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.

You can run the tests with the [NightwatchJS VSCode Extension](https://marketplace.visualstudio.com/items?itemName=browserstackcom.nightwatch) or using the CLI steps below:

1. To run all tests, enter the following command in the terminal. Optionally, include the file name to run just the single test:
   Terminal window
  ```
  npx nightwatch test/index.js
  ```
  Additionally, you can run the tests against a specific browser using the `--environment` or `-e` CLI argument. If you don’t have the relevant browser installed, Nightwatch will attempt to set it up for you using [Selenium Manager](https://www.selenium.dev/blog/2022/introducing-selenium-manager/):
   Terminal window
  ```
  npx nightwatch test/index.ts -e firefox
  ```
2. To see the full HTML Test Report, open it using the following command:
   Terminal window
  ```
  npx nightwatch test/index.ts --open
  ```

More information about NightwatchJS can be found in the links below:

- [Intro to Nightwatch](https://nightwatchjs.org/guide/overview/what-is-nightwatch.html)
- [Testing with Nightwatch](https://nightwatchjs.org/guide/writing-tests/introduction.html)

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Troubleshooting

> Need help? Stuck on something? We've got you covered.

# Troubleshooting

Astro provides several different tools to help you troubleshoot and debug your code.

## Tips and tricks

[Section titled “Tips and tricks”](#tips-and-tricks)

### Debugging withconsole.log()

[Section titled “Debugging with console.log()”](#debugging-with-consolelog)

`console.log()` is a simple-but-popular method of debugging your Astro code. Where you write your `console.log()` statement will determine where your debugging output is printed:

```
---console.log('Hi! I’m the server. This is logged in the terminal where Astro is running.');---
<script>console.log('Hi! I’m the client. This is logged in browser dev console.');</script>
```

A `console.log()` statement in Astro frontmatter will always output to the **terminal** running the Astro CLI. This is because Astro runs on the server, and never in the browser.

Code that is written or imported inside of an Astro `<script>` tag is run in the browser. Any `console.log()` statements or other debug output will be  printed to the **console in your browser**.

### Debugging framework components

[Section titled “Debugging framework components”](#debugging-framework-components)

[Framework components](https://docs.astro.build/en/guides/framework-components/) (like React and Svelte) are unique: They render server-side by default, meaning that `console.log()` debug output will be visible in the terminal. However, they can also be hydrated for the browser, which may cause your debug logs to also appear in the browser.

This can be useful for debugging differences between the server output and the hydrated components in the browser.

### Astro<Debug />component

[Section titled “Astro <Debug /> component”](#astro-debug--component)

To help you debug your Astro components, Astro provides a built-in `<Debug />` component which renders any value directly into your component HTML template.

This component provides a way to inspect values on the client-side, without any JavaScript. It can be useful for quick debugging in the browser without having to flip back-and-forth between your terminal and your browser.

```
---import { Debug } from 'astro:components';const sum = (a, b) => a + b;---
<Debug answer={sum(2, 4)} />
```

The Debug component supports a variety of syntax options for even more flexible and concise debugging:

```
---import { Debug } from 'astro:components';const sum = (a, b) => a + b;const answer = sum(2, 4);---<Debug answer={sum(2, 4)} /><Debug {{answer: sum(2, 4)}} /><Debug {answer} />
```

## Common Error Messages

[Section titled “Common Error Messages”](#common-error-messages)

Here are some common error messages you might see in the terminal, what they might mean, and what to do about them. See our [full error reference guide](https://docs.astro.build/en/reference/error-reference/) for a complete list of Astro errors you may encounter.

### Cannot use import statement outside a module

[Section titled “Cannot use import statement outside a module”](#cannot-use-import-statement-outside-a-module)

In Astro components, `<script>` tags are loaded as [JS modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) by default. If you have included the [is:inlinedirective](https://docs.astro.build/en/reference/directives-reference/#isinline) or any other attribute in your tag, this default behavior is removed.

**Solution**: If you have added any attributes to your `<script>` tag, you must also add the `type="module"` attribute to be able to use import statements.

**Status**: Expected Astro behavior, as intended.

**Not sure that this is your problem?**

Check to see if anyone else has reported [this issue](https://github.com/withastro/astro/issues?q=is%3Aissue+is%3Aopen+Cannot+use+import+statement)!

### document(orwindow) is not defined

[Section titled “document (or window) is not defined”](#document-or-window-is-not-defined)

This error occurs when trying to access `document` or `window` on the server.

Astro components run on the server, so you can’t access these browser-specific objects within the frontmatter.

Framework components run on the server by default, so this error can occur when accessing `document` or `window` during rendering.

**Solution**: Determine the code that calls `document` or `window`. If you aren’t using `document` or `window` directly and still getting this error, check to see if any packages you’re importing are meant to run on the client.

- If the code is in an Astro component, move it to a `<script>` tag outside of the frontmatter. This tells Astro to run this code on the client, where `document` and `window` are available.
- If the code is in a framework component, try to access these objects after rendering using lifecycle methods (e.g. [useEffect()](https://react.dev/reference/react/useEffect) in React, [onMounted()](https://vuejs.org/api/composition-api-lifecycle.html#onmounted) in Vue, and [onMount()](https://svelte.dev/docs#run-time-svelte-onmount) in Svelte). Tell the framework component to hydrate client-side by using a [client:](https://docs.astro.build/en/reference/directives-reference/#client-directives) directive, like `client:load`, to run these lifecycle methods. You can also prevent the component from rendering on the server at all by adding the [client:only](https://docs.astro.build/en/reference/directives-reference/#clientonly) directive.

**Status**: Expected Astro behavior, as intended.

### Expected a default export

[Section titled “Expected a default export”](#expected-a-default-export)

This error can be thrown when trying to import or render an invalid component, or one that is not working properly. (This particular message occurs because of the way importing a UI component works in Astro.)

**Solution**: Try looking for errors in any component you are importing and rendering, and make sure it’s working correctly. Consider opening an Astro starter template from [astro.new](https://astro.new) and troubleshooting just your component in a minimal Astro project.

**Status**: Expected Astro behavior, as intended.

### Refused to execute inline script

[Section titled “Refused to execute inline script”](#refused-to-execute-inline-script)

You may see the following error logged in the browser console:

> Refused to execute inline script because it violates the following Content Security Policy directive: …

This means that your site’s [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) (CSP) disallows running inline `<script>` tags, which Astro outputs by default.

**Solution:** Update your CSP to include `script-src: 'unsafe-inline'` to allow inline scripts to run. Alternatively, you can use a third-party integration such as [astro-shield](https://github.com/KindSpells/astro-shield) to generate the CSP headers for you.

## Common gotchas

[Section titled “Common gotchas”](#common-gotchas)

### My component is not rendering

[Section titled “My component is not rendering”](#my-component-is-not-rendering)

First, check to see that you have **imported the component** in your [.astrocomponent script](https://docs.astro.build/en/basics/astro-components/#the-component-script) or [.mdxfile](https://docs.astro.build/en/guides/integrations-guide/mdx/#using-components-in-mdx).

Then check your import statement:

- Is your import linking to the wrong place? (Check your import path.)
- Does your import have the same name as the imported component? (Check your component name and that it [follows the.astrosyntax](https://docs.astro.build/en/reference/astro-syntax/#differences-between-astro-and-jsx).)
- Have you included the extension in the import? (Check that your imported file contains an extension. e.g. `.astro`, `.md`, `.vue`, `.svelte`. Note: File extensions are **not** required for `.js(x)` and `.ts(x)` files only.)

### My component is not interactive

[Section titled “My component is not interactive”](#my-component-is-not-interactive)

If your component is rendering (see above) but is not responding to user interaction, then you may be missing a [client:*directive](https://docs.astro.build/en/reference/directives-reference/#client-directives) to hydrate your component.

By default, a [UI Framework component is not hydrated in the client](https://docs.astro.build/en/guides/framework-components/#hydrating-interactive-components). If no `client:*` directive is provided, its HTML is rendered onto the page without JavaScript.

### Cannot find package ‘X’

[Section titled “Cannot find package ‘X’”](#cannot-find-package-x)

If you see a `"Cannot find package 'react'"` (or similar) warning when you start up Astro, that means that you need to install that package into your project.  Not all package managers will install peer dependencies for you automatically. If you are on Node v16+ and using npm, you should not need to worry about this section.

React, for example, is a peer dependency of the `@astrojs/react` integration. That means that you should install the official `react` and `react-dom` packages alongside your integration. The integration will then pull from these packages automatically.

 Terminal window

```
# Example: Install integrations and frameworks togethernpm install @astrojs/react react react-dom
```

See [Astro’s integration guide](https://docs.astro.build/en/guides/integrations-guide/) for instructions on adding framework renderers, CSS tools and other packages to Astro.

### Using Astro with Yarn 2+ (Berry)

[Section titled “Using Astro with Yarn 2+ (Berry)”](#using-astro-with-yarn-2-berry)

Yarn 2+, a.k.a. Berry, uses a technique called [Plug’n’Play (PnP)](https://yarnpkg.com/features/pnp) to store and manage Node modules, which can [cause problems](https://github.com/withastro/astro/issues/3450) while initializing a new Astro project using `create astro` or while working with Astro. A workaround is to set the [nodeLinkerproperty](https://yarnpkg.com/configuration/yarnrc#nodeLinker) in `.yarnrc.yml` to `node-modules`:

 .yarnrc.yml

```
nodeLinker: "node-modules"
```

### Adding dependencies to Astro in a monorepo

[Section titled “Adding dependencies to Astro in a monorepo”](#adding-dependencies-to-astro-in-a-monorepo)

When working with Astro in a monorepo setup, project dependencies should be added in each project’s own `package.json` file.

However, you may also want to use Astro in the root of the monorepo (e.g. [Nx projects recommend installing dependencies at the root](https://github.com/nrwl/nx/issues/3023#issuecomment-630558318)). In this case, manually add Astro-related dependencies (e.g. `@astrojs/vue`, `astro-component-lib`) to the `vite.ssr.noExternal` part of Astro’s config to ensure that these dependencies are properly installed and bundled:

 astro.config.mjs

```
import { defineConfig } from 'astro/config'export default defineConfig({  vite: {    ssr: {      noExternal: [        '@astrojs/vue',        'astro-component-lib',      ]    }  }})
```

### Using<head>in a component

[Section titled “Using <head> in a component”](#using-head-in-a-component)

In Astro, using a `<head>` tag works like any other HTML tag: it does not get moved to the top of the page or merged with the existing `<head>`. Because of this, you usually only want to include one `<head>` tag throughout a page. We recommend writing that single `<head>` and its contents in a [layout component](https://docs.astro.build/en/basics/layouts/).

### An unexpected<style>is included

[Section titled “An unexpected <style> is included”](#an-unexpected-style-is-included)

You may notice an imported component’s `<style>` tag included in your HTML source even if that component doesn’t appear in the final output. For example, this will occur with [conditionally rendered](https://docs.astro.build/en/reference/astro-syntax/#dynamic-html) components that are not displayed.

Astro’s build process works on the module graph: once a component is included in the template, its `<style>` tag is processed, optimized, and bundled, whether it appears in the final output or not.

### Escaping special characters in Markdown

[Section titled “Escaping special characters in Markdown”](#escaping-special-characters-in-markdown)

Certain characters have a special meaning in Markdown. You may need to use a different syntax if you want to display them. To do this, you can use [HTML entities](https://developer.mozilla.org/en-US/docs/Glossary/Entity) for these characters instead.

For example, to prevent `<` being interpreted as the beginning of an HTML element, write `&lt;`.

## Creating minimal reproductions

[Section titled “Creating minimal reproductions”](#creating-minimal-reproductions)

When troubleshooting your code, it can be helpful to create a **minimal reproduction** of the issue that you can share. This is a smaller, simplified Astro project that demonstrates your issue. Having a working reproduction in a new project helps to confirm that this is a repeatable problem, and is not caused by something else in your personal environment or existing project.

Sharing a minimal reproduction is helpful when asking for help in our support threads and is often required when filing a bug report to Astro.

### Create a StackBlitz viaastro.new

[Section titled “Create a StackBlitz via astro.new”](#create-a-stackblitz-via-astronew)

You can use [astro.new](https://astro.new/repro) to create a new Astro project with a single click. For minimal reproductions, we strongly recommend starting from the minimal (empty) example running in [StackBlitz](https://stackblitz.com), with as little extra code as possible.

StackBlitz will run this Astro project in the browser, outside of your local environment. It will also provide you with a shareable link so that any Astro maintainer or support squad member can view your minimal reproduction outside of their own local environment. This means that everyone is viewing the exact same project, with the same configuration and dependencies. This makes it easy for someone else to help troubleshoot your code. If the issue is reproducible, it allows you to verify that the issue lies within the Astro code itself and you can feel confident submitting a bug report.

Note that not every issue is reproducible in StackBlitz. For example, your issue might be dependent on a specific environment or package manager, or it may involve HTML Streaming, which isn’t supported in StackBlitz. In this case, create a new minimal (empty) Astro project using the CLI, reproduce the issue, and upload it to a GitHub repository. Instead of sharing a StackBlitz URL, provide a link to the GitHub repository of your minimal reproduction.

### Minimal code

[Section titled “Minimal code”](#minimal-code)

Once your empty project is set up, go through the steps to reproduce the issue. This can include adding packages, changing configuration, and writing code.

You should only add the minimum amount of code necessary to reproduce the issue. Do not reproduce other elements of your existing project, and remove all code that is not directly related to the issue.

### Create an issue

[Section titled “Create an issue”](#create-an-issue)

If your issue can be reproduced, then it is time to create an issue and file a bug report!

Go to the appropriate Astro repository on GitHub and open a new issue. Most repositories have an issue template that will ask questions or require information in order to submit. It’s important that you follow these templates because if you don’t provide the information we need, then we have to ask you for it… and no one is working on your issue!

Include the link to your minimal reproduction on StackBlitz (or GitHub repository, if necessary). Start with a description of the expected versus actual behavior to provide context for the issue. Then, include clear, step-by-step instructions on how to replicate the issue in an Astro project.

## Need more?

[Section titled “Need more?”](#need-more)

Come and chat with us on [Discord](https://astro.build/chat) and explain your issue in the `#support` forum channel. We’re always happy to help!

Visit the current [open Issues in Astro](https://github.com/withastro/astro/issues/) to see if you are encountering a known problem or file a bug report.

You can also visit [RFC Discussions](https://github.com/withastro/rfcs/discussions/) to see whether you’ve found a known limitation of Astro, and check to see whether there are current proposals related to your use case.

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
