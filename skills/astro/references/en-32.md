# On and more

# On

> Generate server-rendered pages and routes on demand with an adapter.

# On-demand rendering

Your Astro project code must be **rendered** to HTML in order to be displayed on the web.

By default, Astro pages, routes, and API endpoints will be pre-rendered at build time as static pages. However, you can choose to render some or all of your routes on demand by a server when a route is requested.

On-demand rendered pages and routes are generated per visit, and can be customized for each viewer. For example, a page rendered on demand can show a logged-in user their account information or display freshly updated data without requiring a full-site rebuild.

On-demand rendering on the server at request time is also known as **server-side rendering (SSR)**.

## Server adapters

[Section titled “Server adapters”](#server-adapters)

To render any page on demand, you need to add an **adapter**. Each adapter allows Astro to output a script that runs your project on a specific **runtime**: the environment that runs code on the server to generate pages when they are requested (e.g. Netlify, Cloudflare).

You may also wish to add an adapter even if your site is entirely static and you are not rendering any pages on demand. For example, the [Netlify adapter](https://docs.astro.build/en/guides/integrations-guide/netlify/) enables Netlify’s Image CDN, and [server islands](https://docs.astro.build/en/guides/server-islands/) require an adapter installed to use `server:defer` on a component.

### Adapters

- ![](https://docs.astro.build/logos/cloudflare-pages.svg)
  ### @astrojs/cloudflare
- ![](https://docs.astro.build/logos/netlify.svg)
  ### @astrojs/netlify
- ![](https://docs.astro.build/logos/node.svg)
  ### @astrojs/node
- ![](https://docs.astro.build/logos/vercel.svg)
  ### @astrojs/vercel

Astro maintains official adapters for [Node.js](https://nodejs.org/), [Netlify](https://www.netlify.com/), [Vercel](https://vercel.com/), and [Cloudflare](https://www.cloudflare.com/). You can find both [official and community adapters in our integrations directory](https://astro.build/integrations/?search=&categories%5B%5D=adapters). Choose the one that corresponds to your [deployment environment](https://docs.astro.build/en/guides/deploy/).

### Add an Adapter

[Section titled “Add an Adapter”](#add-an-adapter)

You can add any of the [official adapter integrations maintained by Astro](https://docs.astro.build/en/guides/integrations-guide/#official-integrations) with the following `astro add` command. This will install the adapter and make the appropriate changes to your `astro.config.mjs` file in one step.

For example, to install the Netlify adapter, run:

- [npm](#tab-panel-1833)
- [pnpm](#tab-panel-1834)
- [Yarn](#tab-panel-1835)

   Terminal window

```
npx astro add netlify
```

   Terminal window

```
pnpm astro add netlify
```

   Terminal window

```
yarn astro add netlify
```

You can also [add an adapter manually by installing the NPM package](https://docs.astro.build/en/guides/integrations-guide/#installing-an-npm-package) (e.g. `@astrojs/netlify`) and updating `astro.config.mjs` yourself.

Note that different adapters may have different configuration settings. Read each adapter’s documentation, and apply any necessary config options to your chosen adapter in `astro.config.mjs`

## Enabling on-demand rendering

[Section titled “Enabling on-demand rendering”](#enabling-on-demand-rendering)

**By default, your entire Astro site will be prerendered**, and static HTML pages will be sent to the browser. However, you may opt out of prerendering on any routes that require server rendering, for example, a page that checks for cookies and displays personalized content.

First, [add an adapter integration](#add-an-adapter) for your server runtime to enable on-demand server rendering in your Astro project.

Then, add `export const prerender = false` at the top of the individual page or endpoint you want to render on demand. The rest of your site will remain a static site:

 src/pages/page-rendered-on-demand.astro

```
---export const prerender = false---<html><html>
```

The following example shows opting out of prerendering in order to display a random number each time the endpoint is hit:

 src/pages/randomnumber.js

```
export const prerender = false;
export async function GET() {  let number = Math.random();  return new Response(    JSON.stringify({      number,      message: `Here's a random number: ${number}`,    }),  );}
```

### 'server'mode

[Section titled “'server' mode”](#server-mode)

For a **highly dynamic app**, after adding an adapter, you can [set your build output configuration tooutput: 'server'](https://docs.astro.build/en/reference/configuration-reference/#output) to **server-render all your pages by default**. This is the equivalent of opting out of prerendering on every page.

Then, if needed, you can choose to prerender any individual pages that do not require a server to execute, such as a privacy policy or about page.

 src/pages/about-my-app.astro

```
---export const prerender = true---<html><html>
```

Add `export const prerender = true` to any page or route to prerender a static page or endpoint:

 src/pages/myendpoint.js

```
export const prerender = true;
export async function GET() {  return new Response(    JSON.stringify({      message: `This is my static endpoint`,    }),  );}
```

    See more about the [outputsetting](https://docs.astro.build/en/reference/configuration-reference/#output) in the configuration reference.

## On-demand rendering features

[Section titled “On-demand rendering features”](#on-demand-rendering-features)

### HTML streaming

[Section titled “HTML streaming”](#html-streaming)

With HTML streaming, a document is broken up into chunks, sent over the network in order, and rendered on the page in that order. Astro uses HTML streaming in on-demand rendering to send each component to the browser as it renders them. This makes sure the user sees your HTML as fast as possible, although network conditions can cause large documents to be downloaded slowly, and waiting for data fetches can block page rendering.

   ![](https://docs.astro.build/houston_chef.webp) **Related recipe:** [Using streaming to improve page performance](https://docs.astro.build/en/recipes/streaming-improve-page-performance/)

### Cookies

[Section titled “Cookies”](#cookies)

A page or API endpoint rendered on demand can check, set, get, and delete cookies.

The example below updates the value of a cookie for a page view counter:

 src/pages/index.astro

```
---export const prerender = false; // Not needed in 'server' mode
let counter = 0
if (Astro.cookies.has('counter')) {  const cookie = Astro.cookies.get('counter')  const value = cookie?.number()  if (value !== undefined && !isNaN(value)) counter = value + 1}
Astro.cookies.set('counter', String(counter))---<html>  <h1>Counter = {counter}</h1></html>
```

See more details about [Astro.cookiesand theAstroCookietype](https://docs.astro.build/en/reference/api-reference/#cookies) in the API reference.

### Response

[Section titled “Response”](#response)

[Astro.response](https://docs.astro.build/en/reference/api-reference/#response) is a standard [ResponseInit](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#options) object. It can be used to set the response status and headers.

The example below sets a response status and status text for a product page when the product does not exist:

 src/pages/product/[id].astro

```
---export const prerender = false; // Not needed in 'server' mode
import { getProduct } from '../api';
const product = await getProduct(Astro.params.id);
// No product foundif (!product) {  Astro.response.status = 404;  Astro.response.statusText = 'Not found';}---<html>  </html>
```

#### Astro.response.headers

[Section titled “Astro.response.headers”](#astroresponseheaders)

You can set headers using the `Astro.response.headers` object:

 src/pages/index.astro

```
---export const prerender = false; // Not needed in 'server' mode
Astro.response.headers.set('Cache-Control', 'public, max-age=3600');---<html>  </html>
```

#### Return aResponseobject

[Section titled “Return a Response object”](#return-a-response-object)

You can also return a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object directly from any page using on-demand rendering either manually or with [Astro.redirect](https://docs.astro.build/en/reference/api-reference/#redirect).

The example below looks up an ID in the database on a dynamic page and either it returns a 404 if the product does not exist, or it redirects the user to another page if the product is no longer available, or it displays the product:

 src/pages/product/[id].astro

```
---export const prerender = false; // Not needed in 'server' mode
import { getProduct } from '../api';
const product = await getProduct(Astro.params.id);
// No product foundif (!product) {  return new Response(null, {    status: 404,    statusText: 'Not found'  });}
// The product is no longer availableif (!product.isAvailable) {  return Astro.redirect("/products", 301);}---<html>  </html>
```

### Request

[Section titled “Request”](#request)

`Astro.request` is a standard [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object. It can be used to get the `url`, `headers`, `method`, and even the body of the request.

You can access additional information from this object for pages that are not statically generated.

#### Astro.request.headers

[Section titled “Astro.request.headers”](#astrorequestheaders)

The headers for the request are available on `Astro.request.headers`. This works like the browser’s [Request.headers](https://developer.mozilla.org/en-US/docs/Web/API/Request/headers). It is a [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object where you can retrieve headers such as the cookie.

 src/pages/index.astro

```
---export const prerender = false; // Not needed in 'server' mode
const cookie = Astro.request.headers.get('cookie');// ...---<html>  </html>
```

#### Astro.request.method

[Section titled “Astro.request.method”](#astrorequestmethod)

The HTTP method used in the request is available as `Astro.request.method`. This works like the browser’s [Request.method](https://developer.mozilla.org/en-US/docs/Web/API/Request/method). It returns the string representation of the HTTP method used in the request.

 src/pages/index.astro

```
---export const prerender = false; // Not needed in 'server' mode
console.log(Astro.request.method) // GET (when navigated to in the browser)---
```

See more details about [Astro.request](https://docs.astro.build/en/reference/api-reference/#request) in the API reference.

### Server Endpoints

[Section titled “Server Endpoints”](#server-endpoints)

A server endpoint, also known as an **API route**, is a special function exported from a `.js` or `.ts` file within the `src/pages/` folder. A powerful feature of server-side rendering on demand, API routes are able to securely execute code on the server.

The function takes an [endpoint context](https://docs.astro.build/en/reference/api-reference/) and returns a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).

To learn more, see our [Endpoints Guide](https://docs.astro.build/en/guides/endpoints/#server-endpoints-api-routes).

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Prefetch

> Prefetch links for snappier navigation between pages.

# Prefetch

Page load times play a big role in the usability and overall enjoyment of a site. Astro’s **opt-in prefetching** brings the benefits of near-instant page navigations to your multi-page application (MPA) as your visitors interact with the site.

## Enable prefetching

[Section titled “Enable prefetching”](#enable-prefetching)

You can enable prefetching with the `prefetch` config:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  prefetch: true});
```

A prefetch script will be added to all pages of your site. You can then add the `data-astro-prefetch` attribute to any `<a />` links on your site to opt-in to prefetching. When you hover over the link, the script will fetch the page in the background.

```
<a href="/about" data-astro-prefetch>
```

Note that prefetching only works for links within your site, and not external links.

## Prefetch configuration

[Section titled “Prefetch configuration”](#prefetch-configuration)

The `prefetch` config also accepts an option object to further customize prefetching.

### Prefetch strategies

[Section titled “Prefetch strategies”](#prefetch-strategies)

Astro supports 4 prefetch strategies for various use cases:

- `hover` (default): Prefetch when you hover over or focus on the link.
- `tap`: Prefetch just before you click on the link.
- `viewport`: Prefetch as the links enter the viewport.
- `load`: Prefetch all links on the page after the page is loaded.

You can specify a strategy for an individual link by passing it to the `data-astro-prefetch` attribute:

```
<a href="/about" data-astro-prefetch="tap">About</a>
```

Each strategy is fine-tuned to only prefetch when needed and save your users’ bandwidth. For example:

- If a visitor is using [data saver mode](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData) or has a [slow connection](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType), prefetch will fallback to the `tap` strategy.
- Quickly hovering or scrolling over links will not prefetch them.

### Default prefetch strategy

[Section titled “Default prefetch strategy”](#default-prefetch-strategy)

The default prefetch strategy when adding the `data-astro-prefetch` attribute is `hover`. To change it, you can configure [prefetch.defaultStrategy](https://docs.astro.build/en/reference/configuration-reference/#prefetchdefaultstrategy) in your `astro.config.mjs` file:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  prefetch: {    defaultStrategy: 'viewport'  }});
```

### Prefetch all links by default

[Section titled “Prefetch all links by default”](#prefetch-all-links-by-default)

If you want to prefetch all links, including those without the `data-astro-prefetch` attribute, you can set [prefetch.prefetchAll](https://docs.astro.build/en/reference/configuration-reference/#prefetchprefetchall) to `true`:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  prefetch: {    prefetchAll: true  }});
```

You can then opt-out of prefetching for individual links by setting `data-astro-prefetch="false"`:

```
<a href="/about" data-astro-prefetch="false">About</a>
```

The default prefetch strategy for all links can be changed with `prefetch.defaultStrategy` as shown in the [Default prefetch strategy section](#default-prefetch-strategy).

## Prefetch programmatically

[Section titled “Prefetch programmatically”](#prefetch-programmatically)

As some navigation might not always appear as `<a />` links, you can also prefetch programmatically with the `prefetch()` API from the `astro:prefetch` module:

```
<button id="btn">Click me</button>
<script>  import { prefetch } from 'astro:prefetch';
  const btn = document.getElementById('btn');  btn.addEventListener('click', () => {    prefetch('/about');  });</script>
```

The `prefetch()` API includes the same [data saver mode](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData) and [slow connection](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType) detection so that it only prefetches when needed.

To ignore slow connection detection, you can use the `ignoreSlowConnection` option:

```
// Prefetch even on data saver mode or slow connectionprefetch('/about', { ignoreSlowConnection: true });
```

### eagerness

[Section titled “eagerness”](#eagerness)

**Type:** `'immediate' | 'eager' | 'moderate' | 'conservative'`
 **Default:** `'immediate'`

 **Added in:** `astro@5.6.0`

With the experimental [clientPrerender](https://docs.astro.build/en/reference/experimental-flags/client-prerender/) flag enabled, you can use the `eagerness` option on `prefetch()` to suggest to the browser how eagerly it should prefetch/prerender link targets.

This follows the same API described in the [Speculation Rules API](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/speculationrules#eagerness) and defaults to `immediate` (the most eager option). In decreasing order of eagerness, the other options are `eager`, `moderate`, and `conservative`.

The `eagerness` option allows you to balance the benefit of reduced wait times against bandwidth, memory, and CPU costs for your site visitors. Some browsers, such as Chrome, have [limits in place to guard against over-speculating](https://developer.chrome.com/blog/speculation-rules-improvements#chrome-limits)  (prerendering/prefetching too many links).

```
------<script>// Control prefetching eagerness with `experimental.clientPrerender`import { prefetch } from 'astro:prefetch';
// This page is resource-intensiveprefetch('/data-heavy-dashboard', { eagerness: 'conservative' });
// This page is critical to the visitor's journeyprefetch('/getting-started'); // defaults to `{ eagerness: 'immediate' }`
// This page may not be visitedprefetch('/terms-of-service', { eagerness: 'moderate' });</script>
```

To use `prefetch()` programmatically with large sets of links, you can set `eagerness: 'moderate'` to take advantage of [First In, First Out (FIFO)](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)) strategies and browser heuristics to let the browser decide when to prerender/prefetch them and in what order:

```
<a class="link-moderate" href="/nice-link-1">A Nice Link 1</a><a class="link-moderate" href="/nice-link-2">A Nice Link 2</a><a class="link-moderate" href="/nice-link-3">A Nice Link 3</a><a class="link-moderate" href="/nice-link-4">A Nice Link 4</a>...<a class="link-moderate" href="/nice-link-20">A Nice Link 20</a>
<script>  import { prefetch } from 'astro:prefetch';
  const linkModerate = document.getElementsByClassName('link-moderate');  linkModerate.forEach((link) => prefetch(link.getAttribute('href'), {eagerness: 'moderate'}));
</script>
```

Make sure to only import `prefetch()` in client-side scripts as it relies on browser APIs.

## Using with View Transitions

[Section titled “Using with View Transitions”](#using-with-view-transitions)

When you use [Astro’s<ClientRouter />](https://docs.astro.build/en/guides/view-transitions/#enabling-view-transitions-spa-mode)  on a page, prefetching will also be enabled by default. It sets a default configuration of `{ prefetchAll: true }` which enables [prefetching for all links](#prefetch-all-links-by-default) on the page.

You can customize the prefetch configuration in `astro.config.mjs` to override the default. For example:

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  // Disable prefetch completely  prefetch: false});
```

 astro.config.mjs

```
import { defineConfig } from 'astro/config';
export default defineConfig({  // Keep prefetch, but only prefetch for links with `data-astro-prefetch`  prefetch: {    prefetchAll: false  }});
```

## Browser support

[Section titled “Browser support”](#browser-support)

Astro’s prefetching uses [<link rel="prefetch">](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/prefetch) if supported by the browser, and falls back to the [fetch()API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) otherwise.

The most common browsers support Astro’s prefetching with subtle differences:

### Chrome

[Section titled “Chrome”](#chrome)

Chrome supports `<link rel="prefetch">`. Prefetching works as intended.

It also fully supports `<script type="speculationrules">` from the [Speculation Rules API](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API), which can be used to further describe [prefetching strategies and rules](#eagerness), enhancing user experience for your Chrome users. You’ll need to enable [clientPrerender](https://docs.astro.build/en/reference/experimental-flags/client-prerender/) experiment to utilize this functionality with `prefetch()`

### Firefox

[Section titled “Firefox”](#firefox)

Firefox supports `<link rel="prefetch">` but may display errors or fail entirely:

- Without an explicit cache header (e.g. [Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) or [Expires](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires)), prefetching will error with `NS_BINDING_ABORTED`.
- Even in the event of an error, if the response has a proper [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header, it will be re-used on navigation.
- Otherwise, if it errors with no other cache headers, the prefetch will not work.

### Safari

[Section titled “Safari”](#safari)

Safari does not support `<link rel="prefetch">` and will fall back to the `fetch()` API which requires cache headers (e.g. [Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control), [Expires](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires), and [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)) to be set. Otherwise, the prefetch will not work.

**Edge case:** `ETag` headers do not work in private windows.

### Recommendations

[Section titled “Recommendations”](#recommendations)

To best support all browsers, make sure your pages have the proper cache headers.

For static or prerendered pages, the `ETag` header is often automatically set by the deployment platform and is expected to work out of the box.

For dynamic and server-side rendered pages, set the appropriate cache headers yourself based on the page content. Visit the [MDN documentation on HTTP caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching) for more information.

## Migrating from@astrojs/prefetch

[Section titled “Migrating from @astrojs/prefetch”](#migrating-from-astrojsprefetch)

The `@astrojs/prefetch` integration was deprecated in v3.5.0 and will eventually be removed entirely. Use the following instructions to migrate to Astro’s built-in prefetching which replaces this integration.

1. Remove the `@astrojs/prefetch` integration and enable the `prefetch` config in `astro.config.mjs`:
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';import prefetch from '@astrojs/prefetch';
  export default defineConfig({  integrations: [prefetch()],  prefetch: true});
  ```
2. Convert from `@astrojs/prefetch`’s configuration options:
  - The deprecated integration used the `selector` config option to specify which links should be prefetched upon entering the viewport.
    Add `data-astro-prefetch="viewport"` to these individual links instead.
    ```
    <a href="/about" data-astro-prefetch="viewport">
    ```
  - The deprecated integration used the `intentSelector` config option to specify which links should be prefetched when they were hovered over or focused.
    Add `data-astro-prefetch` or `data-astro-prefetch="hover"` to these individual links instead:
    ```
    <a href="/about" data-astro-prefetch>
    <a href="/about" data-astro-prefetch="hover">
    ```
  - The `throttles` option from `@astrojs/prefetch` is no longer needed as the new prefetch feature will automatically schedule and prefetch optimally.

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Routing

> An intro to routing with Astro.

# Routing

Astro uses **file-based routing** to generate your build URLs based on the file layout of your project `src/pages/` directory.

## Navigating between pages

[Section titled “Navigating between pages”](#navigating-between-pages)

Astro uses standard HTML [<a>elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a) to navigate between routes. There is no framework-specific `<Link>` component provided.

 src/pages/index.astro

```
<p>Read more <a href="/about/">about</a> Astro!</p>
<p>Learn more in our <a href="/docs/reference/">reference</a> section!</p>
```

## Static routes

[Section titled “Static routes”](#static-routes)

`.astro` [page components](https://docs.astro.build/en/basics/astro-pages/) as well as Markdown and MDX Files (`.md`, `.mdx`) within the `src/pages/` directory **automatically become pages on your website**. Each page’s route corresponds to its path and filename within the `src/pages/` directory.

```
# Example: Static routessrc/pages/index.astro        -> mysite.com/src/pages/about.astro        -> mysite.com/aboutsrc/pages/about/index.astro  -> mysite.com/aboutsrc/pages/about/me.astro     -> mysite.com/about/mesrc/pages/posts/1.md         -> mysite.com/posts/1
```

## Dynamic routes

[Section titled “Dynamic routes”](#dynamic-routes)

An Astro page file can specify dynamic route parameters in its filename to generate multiple, matching pages. For example, `src/pages/authors/[author].astro` generates a bio page for every author on your blog. `author` becomes a *parameter* that you can access from inside the page.

In Astro’s default static output mode, these pages are generated at build time, and so you must predetermine the list of `author`s that get a corresponding file. In SSR mode, a page will be generated on request for any route that matches.

### Static (SSG) Mode

[Section titled “Static (SSG) Mode”](#static-ssg-mode)

Because all routes must be determined at build time, a dynamic route must export a `getStaticPaths()` that returns an array of objects with a `params` property. Each of these objects will generate a corresponding route.

`[dog].astro` defines the dynamic `dog` parameter in its filename, so the objects returned by `getStaticPaths()` must include `dog` in their `params`. The page can then access this parameter using `Astro.params`.

 src/pages/dogs/[dog].astro

```
---export function getStaticPaths() {  return [    { params: { dog: "clifford" }},    { params: { dog: "rover" }},    { params: { dog: "spot" }},  ];}
const { dog } = Astro.params;---<div>Good dog, {dog}!</div>
```

This will generate three pages: `/dogs/clifford`, `/dogs/rover`, and `/dogs/spot`, each displaying the corresponding dog name.

The filename can include multiple parameters, which must all be included in the `params` objects in `getStaticPaths()`:

 src/pages/[lang]-[version]/info.astro

```
---export function getStaticPaths() {  return [    { params: { lang: "en", version: "v1" }},    { params: { lang: "fr", version: "v2" }},  ];}
const { lang, version } = Astro.params;---
```

This will generate `/en-v1/info` and `/fr-v2/info`.

Parameters can be included in separate parts of the path. For example, the file `src/pages/[lang]/[version]/info.astro` with the same `getStaticPaths()` above will generate the routes `/en/v1/info` and `/fr/v2/info`.

#### Decodingparams

[Section titled “Decoding params”](#decoding-params)

`params` returned by a `getStaticPaths()` function are not decoded. Use [decodeURI()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI) when you need to decode parameter values.

 src/pages/[slug].astro

```
---export function getStaticPaths() {  return [    { params: { slug: decodeURI("%5Bpage%5D") }}, // decodes to "[page]"  ]}---
```

   Learn more about [getStaticPaths()](https://docs.astro.build/en/reference/routing-reference/#getstaticpaths).    ![](https://docs.astro.build/houston_chef.webp) **Related recipe:** [Add i18n features](https://docs.astro.build/en/recipes/i18n/)

#### Rest parameters

[Section titled “Rest parameters”](#rest-parameters)

If you need more flexibility in your URL routing, you can use a [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`[...path]`) in your `.astro` filename to match file paths of any depth:

 src/pages/sequences/[...path].astro

```
---export function getStaticPaths() {  return [    { params: { path: "one/two/three" }},    { params: { path: "four" }},    { params: { path: undefined }}  ]}
const { path } = Astro.params;---
```

This will generate `/sequences/one/two/three`, `/sequences/four`, and `/sequences`. (Setting the rest parameter to `undefined` allows it to match the top level page.)

Rest parameters can be used with **other named parameters**. For example, GitHub’s file viewer can be represented with the following dynamic route:

```
/[org]/[repo]/tree/[branch]/[...file]
```

In this example, a request for `/withastro/astro/tree/main/docs/public/favicon.svg` would be split into the following named parameters:

```
{  org: "withastro",  repo: "astro",  branch: "main",  file: "docs/public/favicon.svg"}
```

#### Example: Dynamic pages at multiple levels

[Section titled “Example: Dynamic pages at multiple levels”](#example-dynamic-pages-at-multiple-levels)

In the following example, a rest parameter (`[...slug]`) and the [props](https://docs.astro.build/en/reference/routing-reference/#data-passing-with-props) feature of `getStaticPaths()` generate pages for slugs of different depths.

 src/pages/[...slug].astro

```
---export function getStaticPaths() {  const pages = [    {      slug: undefined,      title: "Astro Store",      text: "Welcome to the Astro store!",    },    {      slug: "products",      title: "Astro products",      text: "We have lots of products for you",    },    {      slug: "products/astro-handbook",      title: "The ultimate Astro handbook",      text: "If you want to learn Astro, you must read this book.",    },  ];
  return pages.map(({ slug, title, text }) => {    return {      params: { slug },      props: { title, text },    };  });}
const { title, text } = Astro.props;---<html>  <head>    <title>{title}</title>  </head>  <body>    <h1>{title}</h1>    <p>{text}</p>  </body></html>
```

### On-demand dynamic routes

[Section titled “On-demand dynamic routes”](#on-demand-dynamic-routes)

For [on-demand rendering](https://docs.astro.build/en/guides/on-demand-rendering/) with an adapter, dynamic routes are defined the same way: include `[param]` or `[...path]` brackets in your file names to match arbitrary strings or paths. But because the routes are no longer built ahead of time, the page will be served to any matching route. Since these are not “static” routes, `getStaticPaths` should not be used.

For on-demand rendered routes, only one rest parameter using the spread notation may be used in the file name (e.g. `src/pages/[locale]/[...slug].astro` or `src/pages/[...locale]/[slug].astro`, but not `src/pages/[...locale]/[...slug].astro`).

 src/pages/resources/[resource]/[id].astro

```
---export const prerender = false; // Not needed in 'server' modeconst { resource, id } = Astro.params;---<h1>{resource}: {id}</h1>
```

This page will be served for any value of `resource` and `id`: `resources/users/1`, `resources/colors/blue`, etc.

#### Modifying the[...slug]example for SSR

[Section titled “Modifying the [...slug] example for SSR”](#modifying-the-slug-example-for-ssr)

Because SSR pages can’t use `getStaticPaths()`, they can’t receive props. The [previous example](#example-dynamic-pages-at-multiple-levels) can be adapted for SSR mode by looking up the value of the `slug` param in an object. If the route is at the root (”/”), the `slug` param will be `undefined`. If the value doesn’t exist in the object, we redirect to a 404 page.

 src/pages/[...slug].astro

```
---const pages = [  {    slug: undefined,    title: 'Astro Store',    text: 'Welcome to the Astro store!',  },  {    slug: 'products',    title: 'Astro products',    text: 'We have lots of products for you',  },  {    slug: 'products/astro-handbook',    title: 'The ultimate Astro handbook',    text: 'If you want to learn Astro, you must read this book.',  }];
const { slug } = Astro.params;const page = pages.find((page) => page.slug === slug);if (!page) return Astro.redirect("/404");const { title, text } = page;---<html>  <head>    <title>{title}</title>  </head>  <body>    <h1>{title}</h1>    <p>{text}</p>  </body></html>
```

## Redirects

[Section titled “Redirects”](#redirects)

Sometimes you will need to redirect your readers to a new page, either permanently because your site structure has changed or in response to an action such as logging in to an authenticated route.

You can define rules to [redirect users to permanently-moved pages](#configured-redirects) in your Astro config. Or, [redirect users dynamically](#dynamic-redirects) as they use your site.

### Configured Redirects

[Section titled “Configured Redirects”](#configured-redirects)

**Added in:** `astro@2.9.0`

You can specify a mapping of permanent redirects in your Astro config with the [redirects](https://docs.astro.build/en/reference/configuration-reference/#redirects) value.

For internal redirects, this is a mapping of an old route path to the new route. As of Astro v5.2.0, it is also possible to redirect to external URLs that start with `http` or `https` and [can be parsed](https://developer.mozilla.org/en-US/docs/Web/API/URL/canParse_static):

 astro.config.mjs

```
import { defineConfig } from "astro/config";
export default defineConfig({  redirects: {    "/old-page": "/new-page",    "/blog": "https://example.com/blog"  }});
```

These redirects follow [the same priority rules as file-based routes](#route-priority-order) and will always take lower precedence than an existing page file of the same name in your project. For example, `/old-page` will not redirect to `/new-page` if your project contains the file `src/pages/old-page.astro`.

Dynamic routes are allowed as long as both the new and old routes contain the same parameters, for example:

```
{  "/blog/[...slug]": "/articles/[...slug]"}
```

Using SSR or a static adapter, you can also provide an object as the value, allowing you to specify the `status` code in addition to the new `destination`:

 astro.config.mjs

```
import { defineConfig } from "astro/config";
export default defineConfig({  redirects: {    "/old-page": {      status: 302,      destination: "/new-page"    },    "/news": {      status: 302,      destination: "https://example.com/news"    }  }});
```

When running `astro build`, Astro will output HTML files with the [meta refresh](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#examples) tag by default. Supported adapters will instead write out the host’s configuration file with the redirects.

The status code is `301` by default. If building to HTML files the status code is not used by the server.

### Dynamic redirects

[Section titled “Dynamic redirects”](#dynamic-redirects)

On the `Astro` global, the `Astro.redirect` method allows you to redirect to another page dynamically. You might do this after checking if the user is logged in by getting their session from a cookie.

 src/pages/account.astro

```
---import { isLoggedIn } from "../utils";
const cookie = Astro.request.headers.get("cookie");
// If the user is not logged in, redirect them to the login pageif (!isLoggedIn(cookie)) {  return Astro.redirect("/login");}---
```

Because Astro uses [HTML streaming](https://docs.astro.build/en/guides/on-demand-rendering/#html-streaming) in on-demand rendering, redirects must be done at the page level, not inside child components.

## Rewrites

[Section titled “Rewrites”](#rewrites)

**Added in:** `astro@4.13.0`

A rewrite allows you to serve a different route without redirecting the browser to a different page. The browser will show the original address in the URL bar, but will instead display the content of the URL provided to [Astro.rewrite()](https://docs.astro.build/en/reference/api-reference/#rewrite).

Rewrites can be useful for showing the same content at multiple paths (e.g. `/products/shoes/men/` and `/products/men/shoes/`) without needing to maintain two different source files.

Rewrites are also useful for SEO purposes and user experience. They allow you to display content that otherwise would require redirecting your visitor to a different page or would return a 404 status. One common use of rewrites is to show the same localized content for different variants of a language.

The following example uses a rewrite to render the `/es/` version of a page when the `/es-CU/` (Cuban Spanish) URL path is visited. When a visitor navigates to the URL `/es-cu/articles/introduction`, Astro will render the content generated by the file `src/pages/es/articles/introduction.astro`.

 src/pages/es-cu/articles/introduction.astro

```
---return Astro.rewrite("/es/articles/introduction");---
```

Use `context.rewrite()` in your endpoint files to reroute to a different page:

 src/pages/api.js

```
export function GET(context) {  if (!context.locals.allowed) {    return context.rewrite("/");  }}
```

If the URL passed to `Astro.rewrite()` emits a runtime error, Astro will show the overlay error in development and return a 500 status code in production. If the URL does not exist in your project, a 404 status code will be returned.

You can intentionally create a rewrite to render your `/404` page, for example to indicate that a product in your e-commerce shop is no longer available:

 src/pages/[item].astro

```
---const { item } = Astro.params;
if (!itemExists(item)) {  return Astro.rewrite("/404");}---
```

You can also conditionally rewrite based on an HTTP response status, for example to display a certain page on your site when visiting a URL that doesn’t exist:

 src/middleware.mjs

```
export const onRequest = async (context, next) => {  const response = await next();  if (response.status === 404) {    return context.rewrite("/");  }  return response;}
```

Before displaying the content from the specified rewrite path, the function `Astro.rewrite()` will trigger a new, complete rendering phase. This re-executes any middleware for the new route/request.

   See the [Astro.rewrite()API reference](https://docs.astro.build/en/reference/api-reference/#rewrite) for more information.

## Route Priority Order

[Section titled “Route Priority Order”](#route-priority-order)

It’s possible for multiple defined routes to attempt to build the same URL path. For example, all of these routes could build `/posts/create`:

- Directorysrc/pages/
  - […slug].astro
  - Directoryposts/
    - create.astro
    - [page].astro
    - [pid].ts
    - […slug].astro

Astro needs to know which route should be used to build the page. To do so, it sorts them according to the following rules in order:

- Astro [reserved routes](#reserved-routes)
- Routes with more path segments will take precedence over less specific routes. In the example above, all routes under `/posts/` take precedence over `/[...slug].astro` at the root.
- Static routes without path parameters will take precedence over dynamic routes. E.g. `/posts/create.astro` takes precedence over all the other routes in the example.
- Dynamic routes using named parameters take precedence over rest parameters. E.g. `/posts/[page].astro` takes precedence over `/posts/[...slug].astro`.
- Pre-rendered dynamic routes take precedence over server dynamic routes.
- Endpoints take precedence over pages.
- File-based routes take precedence over redirects.
- If none of the rules above decide the order, routes are sorted alphabetically based on the default locale of your Node installation.

Given the example above, here are a few examples of how the rules will match a requested URL to the route used to build the HTML:

- `pages/posts/create.astro` - Will build only `/posts/create`
- `pages/posts/[pid].ts` - Will build `/posts/abc`, `/posts/xyz`, etc. But not `/posts/create`
- `pages/posts/[page].astro` - Will build `/posts/1`, `/posts/2`, etc. But not `/posts/create`, `/posts/abc` nor `/posts/xyz`
- `pages/posts/[...slug].astro` - Will build `/posts/1/2`, `/posts/a/b/c`, etc. But not `/posts/create`, `/posts/1`, `/posts/abc`, etc.
- `pages/[...slug].astro` - Will build `/abc`, `/xyz`, `/abc/xyz`, etc. But not `/posts/create`, `/posts/1`, `/posts/abc`, etc.

### Reserved routes

[Section titled “Reserved routes”](#reserved-routes)

Internal routes take priority over any user-defined or integration-defined routes as they are required for Astro features to work. The following are Astro’s reserved routes:

- `_astro/`: Serves all of the static assets to the client, including CSS documents, bundled client scripts, optimized images, and any Vite assets.
- `_server_islands/`: Serves the dynamic components deferred into a [server island](https://docs.astro.build/en/guides/server-islands/).
- `_actions/`: Serves any defined [actions](https://docs.astro.build/en/guides/actions/).

## Pagination

[Section titled “Pagination”](#pagination)

Astro supports built-in pagination for large collections of data that need to be split into multiple pages. Astro will generate common pagination properties, including previous/next page URLs, total number of pages, and more.

Paginated route names should use the same `[bracket]` syntax as a standard dynamic route. For instance, the file name `/astronauts/[page].astro` will generate routes for `/astronauts/1`, `/astronauts/2`, etc, where `[page]` is the generated page number.

You can use the `paginate()` function to generate these pages for an array of values like so:

 src/pages/astronauts/[page].astro

```
---export function getStaticPaths({ paginate }) {  const astronautPages = [    { astronaut: "Neil Armstrong" },    { astronaut: "Buzz Aldrin" },    { astronaut: "Sally Ride" },    { astronaut: "John Glenn" },  ];
  // Generate pages from our array of astronauts, with 2 to a page  return paginate(astronautPages, { pageSize: 2 });}// All paginated data is passed on the "page" propconst { page } = Astro.props;---<h1>Page {page.currentPage}</h1><ul>    {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}</ul>
```

This generates the following pages, with 2 items to a page:

- `/astronauts/1` - Page 1: Displays “Neil Armstrong” and “Buzz Aldrin”
- `/astronauts/2` - Page 2: Displays “Sally Ride” and “John Glenn”

### Thepageprop

[Section titled “The page prop”](#the-page-prop)

When you use the `paginate()` function, each page will be passed its data via a `page` prop. The `page` prop has many useful properties that you can use to build pages and links between them:

```
interface Page<T = any> {  /** array containing the page’s slice of data that you passed to the paginate() function */  data: T[];  /** metadata */  /** the count of the first item on the page, starting from 0 */  start: number;  /** the count of the last item on the page, starting from 0 */  end: number;  /** total number of results */  total: number;  /** the current page number, starting from 1 */  currentPage: number;  /** number of items per page (default: 10) */  size: number;  /** number of last page */  lastPage: number;  url: {    /** url of the current page */    current: string;    /** url of the previous page (if there is one) */    prev: string | undefined;    /** url of the next page (if there is one) */    next: string | undefined;    /** url of the first page (if the current page is not the first page) */    first: string | undefined;    /** url of the last page (if the current page in not the last page) */    last: string | undefined;  };}
```

The following example displays current information for the page along with links to navigate between pages:

 src/pages/astronauts/[page].astro

```
---// Paginate same list of `{ astronaut }` objects as the previous exampleexport function getStaticPaths({ paginate }) { /* ... */ }const { page } = Astro.props;---<h1>Page {page.currentPage}</h1><ul>  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}</ul>{page.url.first ? <a href={page.url.first}>First</a> : null}{page.url.prev ? <a href={page.url.prev}>Previous</a> : null}{page.url.next ? <a href={page.url.next}>Next</a> : null}{page.url.last ? <a href={page.url.last}>Last</a> : null}
```

   Learn more about [the paginationpageprop](https://docs.astro.build/en/reference/routing-reference/#the-pagination-page-prop).

### Nested Pagination

[Section titled “Nested Pagination”](#nested-pagination)

A more advanced use-case for pagination is **nested pagination.** This is when pagination is combined with other dynamic route params. You can use nested pagination to group your paginated collection by some property or tag.

For example, if you want to group your paginated Markdown posts by some tag, you would use nested pagination by creating a `/src/pages/[tag]/[page].astro` page that would match the following URLS:

- `/red/1` (tag=red)
- `/red/2` (tag=red)
- `/blue/1` (tag=blue)
- `/green/1` (tag=green)

Nested pagination works by returning an array of `paginate()` results from `getStaticPaths()`, one for each grouping.

In the following example, we will implement nested pagination to build the URLs listed above:

 src/pages/[tag]/[page].astro

```
---export function getStaticPaths({ paginate }) {  const allTags = ["red", "blue", "green"];  const allPosts = Object.values(import.meta.glob("../pages/post/*.md", { eager: true }));  // For every tag, return a `paginate()` result.  // Make sure that you pass `{ params: { tag }}` to `paginate()`  // so that Astro knows which tag grouping the result is for.  return allTags.flatMap((tag) => {    const filteredPosts = allPosts.filter((post) => post.frontmatter.tag === tag);    return paginate(filteredPosts, {      params: { tag },      pageSize: 10    });  });}
const { page } = Astro.props;const params = Astro.params;
```

## Excluding pages

[Section titled “Excluding pages”](#excluding-pages)

You can exclude pages or directories within `src/pages` from being built by prefixing their names with an underscore (`_`). Files with the `_` prefix won’t be recognized by the router and won’t be placed into the `dist/` directory.

You can use this to temporarily disable pages, and also to put tests, utilities, and components in the same folder as their related pages.

In this example, only `src/pages/index.astro` and `src/pages/projects/project1.md` will be built as page routes and HTML files.

- Directorysrc/pages/
  - Directory_hidden-directory/
    - page1.md
    - page2.md
  - _hidden-page.astro
  - **index.astro**
  - Directoryprojects/
    - _SomeComponent.astro
    - _utils.js
    - **project1.md**

 Learn     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
