# Build your Astro site with Docker and more

# Build your Astro site with Docker

> Learn how to build your Astro site using Docker.

# Build your Astro site with Docker

[Docker](https://docker.com) is a tool to build, deploy, and run applications using containers.

Docker images and containers can be deployed to many different platforms, like AWS, Azure, and [Google Cloud](https://docs.astro.build/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static). This recipe won‚Äôt cover how to deploy your site to a specific platform but will show you how to set up Docker for your project.

## Prerequisites

[Section titled ‚ÄúPrerequisites‚Äù](#prerequisites)

- Docker installed on your local machine. You can find [installation instructions for your operating system here](https://docs.docker.com/get-docker/).
- A Dockerfile in your project. You can [learn more about Dockerfiles here](https://docs.docker.com/engine/reference/builder/) and use the Dockerfiles in the following section as a starting point.

## Creating a Dockerfile

[Section titled ‚ÄúCreating a Dockerfile‚Äù](#creating-a-dockerfile)

Create a file called `Dockerfile` in your project‚Äôs root directory. This file contains the instructions to build your site, which will differ depending on your needs. This guide can‚Äôt show all possible options but will give you starting points for SSR and static mode.

If you‚Äôre using another package manager than npm, you‚Äôll need to adjust the commands accordingly.

### SSR

[Section titled ‚ÄúSSR‚Äù](#ssr)

This Dockerfile will build your site and serve it using Node.js on port `4321` and therefore requires the [Node adapter](https://docs.astro.build/en/guides/integrations-guide/node/) installed in your Astro project.

 Dockerfile

```
FROM node:lts AS runtimeWORKDIR /app
COPY . .
RUN npm installRUN npm run build
ENV HOST=0.0.0.0ENV PORT=4321EXPOSE 4321CMD ["node", "./dist/server/entry.mjs"]
```

### Adding a .dockerignore

[Section titled ‚ÄúAdding a .dockerignore‚Äù](#adding-a-dockerignore)

Adding a `.dockerignore` file to your project is best practice. This file describes which files or folders should be ignored in the Docker `COPY` or `ADD` commands, very similar to how `.gitignore` works. This speeds up the build process and reduces the size of the final image.

 .dockerignore

```
.DS_Storenode_modulesdist
```

This file should go in the same directory as the `Dockerfile` itself. [Read the.dockerignoredocumentation for extra info](https://docs.docker.com/engine/reference/builder/#dockerignore-file)

### Static

[Section titled ‚ÄúStatic‚Äù](#static)

#### Apache (httpd)

[Section titled ‚ÄúApache (httpd)‚Äù](#apache-httpd)

The following Dockerfile will build your site and serve it using Apache httpd on port `80` with the default configuration.

 Dockerfile

```
FROM node:lts AS buildWORKDIR /appCOPY . .RUN npm iRUN npm run build
FROM httpd:2.4 AS runtimeCOPY --from=build /app/dist /usr/local/apache2/htdocs/EXPOSE 80
```

#### NGINX

[Section titled ‚ÄúNGINX‚Äù](#nginx) Dockerfile

```
FROM node:lts AS buildWORKDIR /appCOPY package*.json ./RUN npm installCOPY . .RUN npm run build
FROM nginx:alpine AS runtimeCOPY ./nginx/nginx.conf /etc/nginx/nginx.confCOPY --from=build /app/dist /usr/share/nginx/htmlEXPOSE 8080
```

In order to build the Dockerfile above, you‚Äôll also need to create a configuration file for NGINX. Create a folder called `nginx` in your project‚Äôs root directory and create a file called `nginx.conf` inside.

 nginx.conf

```
worker_processes  1;
events {  worker_connections  1024;}
http {  server {    listen 8080;    server_name   _;
    root   /usr/share/nginx/html;    index  index.html index.htm;    include /etc/nginx/mime.types;
    gzip on;    gzip_min_length 1000;    gzip_proxied expired no-cache no-store private auth;    gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;
    error_page 404 /404.html;    location = /404.html {            root /usr/share/nginx/html;            internal;    }
    location / {            try_files $uri $uri/index.html =404;    }  }}
```

### Multi-stage build (using SSR)

[Section titled ‚ÄúMulti-stage build (using SSR)‚Äù](#multi-stage-build-using-ssr)

Here‚Äôs an example of a more advanced Dockerfile that, thanks to Docker‚Äôs [multi-stage builds](https://docs.docker.com/build/building/multi-stage/), optimizes the build process for your site by not reinstalling the npm dependencies when only the source code changes. This can reduce the build time even by minutes, depending on the size of your dependencies.

 Dockerfile

```
FROM node:lts AS baseWORKDIR /app
# By copying only the package.json and package-lock.json here, we ensure that the following `-deps` steps are independent of the source code.# Therefore, the `-deps` steps will be skipped if only the source code changes.COPY package.json package-lock.json ./
FROM base AS prod-depsRUN npm install --omit=dev
FROM base AS build-depsRUN npm install
FROM build-deps AS buildCOPY . .RUN npm run build
FROM base AS runtimeCOPY --from=prod-deps /app/node_modules ./node_modulesCOPY --from=build /app/dist ./dist
ENV HOST=0.0.0.0ENV PORT=4321EXPOSE 4321CMD ["node", "./dist/server/entry.mjs"]
```

## Recipe

[Section titled ‚ÄúRecipe‚Äù](#recipe)

1. Build your container by running the following command in your project‚Äôs root directory. Use any name for `<your-astro-image-name>`:
   Terminal window
  ```
  docker build -t <your-astro-image-name> .
  ```
  This will output an image, which you can run locally or deploy to a platform of your choice.
2. To run your image as a local container, use the following command.
  Replace `<local-port>` with an open port on your machine. Replace `<container-port>` with the port exposed by your Docker container (`4321`, `80`, or `8080` in the above examples.)
   Terminal window
  ```
  docker run -p <local-port>:<container-port> <your-astro-image-name>
  ```
  You should be able to access your site at `http://localhost:<local-port>`.
3. Now that your website is successfully built and packaged in a container, you can deploy it to a cloud provider. See the [Google Cloud](https://docs.astro.build/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static) deployment guide for one example, and the [Deploy your app](https://docs.docker.com/language/nodejs/deploy/) page in the Docker docs.

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Dynamically import images

> Learn how to dynamically import images using Vite's import.meta.glob function.

# Dynamically import images

Local [images](https://docs.astro.build/en/guides/images/) must be imported into `.astro` files in order to display them. There will be times where you will want or need to dynamically import the image paths of your images instead of explicitly importing each individual image.

In this recipe, you will learn how to dynamically import your images using Vite‚Äôs `import.meta.glob` function. You will build a card component that displays the name, age, and photo of a person.

## Recipe

[Section titled ‚ÄúRecipe‚Äù](#recipe)

1. Create a new `assets` folder under the `src` directory and add your images inside that new folder.
  - Directorysrc/
    - Directoryassets/
      - avatar-1.jpg
      - avatar-2.png
      - avatar-3.jpeg
2. Create a new Astro component for your card and import the `<Image />` component.
   src/components/MyCustomCardComponent.astro
  ```
  ---import { Image } from 'astro:assets';---
  ```
3. Specify the `props` that your component will receive in order to display the necessary information on each card. You can optionally define their types, if you are using TypeScript in your project.
   src/components/MyCustomCardComponent.astro
  ```
  ---import { Image } from 'astro:assets';
  interface Props {   imagePath: string;   altText: string;   name: string;   age: number;}
  const { imagePath, altText, name, age } = Astro.props;---
  ```
4. Create a new `images` variable and use the `import.meta.glob` function which returns an object of all of the image paths inside the `assets` folder. You will also need to import `ImageMetadata` type to help define the type of the `images` variable.
   src/components/MyCustomCardComponent.astro
  ```
  ---import type { ImageMetadata } from 'astro';import { Image } from 'astro:assets';
  interface Props {   imagePath: string;   altText: string;   name: string;   age: number;}
  const { imagePath, altText, name, age } = Astro.props;const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}')---
  ```
5. Use the props to create the markup for your card component.
   src/components/MyCustomCardComponent.astro
  ```
  ---import type { ImageMetadata } from 'astro';import { Image } from 'astro:assets';
  interface Props {   imagePath: string;   altText: string;   name: string;   age: number;}
  const { imagePath, altText, name, age } = Astro.props;const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}');---<div class="card">    <h2>{name}</h2>    <p>Age: {age}</p>    <Image src={} alt={altText} /></div>
  ```
6. Inside the `src` attribute, pass in the `images` object and use bracket notation for the image path. Then make sure to invoke the glob function.
  Since you are accessing the `images` object which has an unknown type, you should also `throw` an error in case an invalid file path is passed as a prop.
   src/components/MyCustomCardComponent.astro
  ```
  ---import type { ImageMetadata } from 'astro';import { Image } from 'astro:assets';
  interface Props {   imagePath: string;   altText: string;   name: string;   age: number;}
  const { imagePath, altText, name, age } = Astro.props;const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}');if (!images[imagePath]) throw new Error(`"${imagePath}" does not exist in glob: "src/assets/*.{jpeg,jpg,png,gif}"`);---<div class="card">    <h2>{name}</h2>    <p>Age: {age}</p>    <Image src={images[imagePath]()} alt={altText} /></div>
  ```
7. Import and use the card component inside an Astro page, passing in the values for the `props`.
   src/pages/index.astro
  ```
  ---import MyCustomCardComponent from '../components/MyCustomCardComponent.astro';---<MyCustomCardComponent    imagePath="/src/assets/avatar-1.jpg"    altText="A headshot of Priya against a brick wall background."    name="Priya"    age={25}/>
  ```

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Add icons to external links

> Learn how to install a rehype plugin to add icons to external links in your Markdown files.

# Add icons to external links

Using a rehype plugin, you can identify and modify links in your Markdown files that point to external sites. This example adds icons to the end of each external link, so that visitors will know they are leaving your site.

## Prerequisites

[Section titled ‚ÄúPrerequisites‚Äù](#prerequisites)

- An Astro project using Markdown for content pages.

## Recipe

[Section titled ‚ÄúRecipe‚Äù](#recipe)

1. Install the `rehype-external-links` plugin.
  - [npm](#tab-panel-1890)
  - [pnpm](#tab-panel-1891)
  - [Yarn](#tab-panel-1892)
     Terminal window
  ```
  npm install rehype-external-links
  ```
     Terminal window
  ```
  pnpm add rehype-external-links
  ```
     Terminal window
  ```
  yarn add rehype-external-links
  ```
2. Import the plugin into your `astro.config.mjs` file.
  Pass `rehypeExternalLinks` to the `rehypePlugins` array, along with an options object that includes a content property. Set this property‚Äôs `type` to `text` if you want to add plain text to the end of the link. To add HTML to the end of the link instead, set the property `type` to	`raw`.
  ```
  // ...import rehypeExternalLinks from 'rehype-external-links';
  export default defineConfig({  // ...  markdown: {    rehypePlugins: [      [        rehypeExternalLinks,        {          content: { type: 'text', value: ' üîó' }        }      ],    ]  },});
  ```

## Resources

[Section titled ‚ÄúResources‚Äù](#resources)

- [rehype-external-links](https://www.npmjs.com/package/rehype-external-links)

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Add i18n features

> Use dynamic routing and content collections to add internationalization support to your Astro site.

# Add i18n features

In this recipe, you will learn how to use content collections and dynamic routing to build your own internationalization (i18n) solution and serve your content in different languages.

This example serves each language at its own subpath, e.g. `example.com/en/blog` for English and `example.com/fr/blog` for French.

If you prefer the default language to not be visible in the URL unlike other languages, there are [instructions to hide the default language](https://docs.astro.build/en/recipes/i18n/#hide-default-language-in-the-url) below.

   See the [resources section](#resources) for external links to related topics such as right-to-left (RTL) styling and choosing language tags.

## Recipe

[Section titled ‚ÄúRecipe‚Äù](#recipe)

### Set up pages for each language

[Section titled ‚ÄúSet up pages for each language‚Äù](#set-up-pages-for-each-language)

1. Create a directory for each language you want to support. For example, `en/` and `fr/` if you are supporting English and French:
  - Directorysrc/
    - Directorypages/
      - Directory**en/**
        - about.astro
        - index.astro
      - Directory**fr/**
        - about.astro
        - index.astro
      - index.astro
2. Set up `src/pages/index.astro` to redirect to your default language.
  - [Static](#tab-panel-1893)
  - [On demand](#tab-panel-1894)
     src/pages/index.astro
  ```
  <meta http-equiv="refresh" content="0;url=/en/" />
  ```
  This approach uses a [meta refresh](https://en.wikipedia.org/wiki/Meta_refresh) and will work however you deploy your site. Some static hosts also let you configure server redirects with a custom configuration file. See your deploy platform‚Äôs documentation for more details.
  If you are using an SSR adapter, you can use [Astro.redirect](https://docs.astro.build/en/guides/routing/#dynamic-redirects) to redirect to the default language on the server.
  src/pages/index.astro
  ```
  ---return Astro.redirect('/en/');---
  ```

### Use collections for translated content

[Section titled ‚ÄúUse collections for translated content‚Äù](#use-collections-for-translated-content)

1. Create a folder in `src/content/` for each type of content you want to include and add subdirectories for each supported language. For example, to support English and French blog posts:
  - Directorysrc/
    - Directorycontent/
      - Directoryblog/
        - Directory**en/**  Blog posts in English
          - post-1.md
          - post-2.md
        - Directory**fr/**  Blog posts in French
          - post-1.md
          - post-2.md
2. Create a `src/content.config.ts` file and export a collection for each type of content.
   src/content.config.ts
  ```
  import { defineCollection } from 'astro:content';import { z } from 'astro/zod';
  const blogCollection = defineCollection({  schema: z.object({    title: z.string(),    author: z.string(),    date: z.date()  })});
  export const collections = {  'blog': blogCollection};
  ```
     Read more about [Content Collections](https://docs.astro.build/en/guides/content-collections/).
3. Use [dynamic routes](https://docs.astro.build/en/guides/routing/#dynamic-routes) to fetch and render content based on a `lang` and a `slug` parameter.
  - [Static](#tab-panel-1895)
  - [On demand](#tab-panel-1896)
  In static rendering mode, use `getStaticPaths` to map each content entry to a page:
  src/pages/[lang]/blog/[...slug].astro
  ```
  ---import { getCollection, render } from 'astro:content';
  export async function getStaticPaths() {  const pages = await getCollection('blog');
    const paths = pages.map(page => {    const [lang, ...slug] = page.id.split('/');    return { params: { lang, slug: slug.join('/') || undefined }, props: page };  });
    return paths;}
  const { lang, slug } = Astro.params;const page = Astro.props;const formattedDate = page.data.date.toLocaleString(lang);const { Content } = await render(page);---<h1>{page.data.title}</h1><p>by {page.data.author} ‚Ä¢ {formattedDate}</p><Content/>
  ```
  In [SSR mode](https://docs.astro.build/en/guides/on-demand-rendering/), fetch the requested entry directly:
  src/pages/[lang]/blog/[...slug].astro
  ```
  ---import { getEntry, render } from 'astro:content';
  const { lang, slug } = Astro.params;const page = await getEntry('blog', `${lang}/${slug}`);
  if (!page) {  return Astro.redirect('/404');}
  const formattedDate = page.data.date.toLocaleString(lang);const { Content, headings } = await render(page);---<h1>{page.data.title}</h1><p>by {page.data.author} ‚Ä¢ {formattedDate}</p><Content/>
  ```
        Read more about [dynamic routing](https://docs.astro.build/en/guides/routing/#dynamic-routes).

### Translate UI strings

[Section titled ‚ÄúTranslate UI strings‚Äù](#translate-ui-strings)

Create dictionaries of terms to translate the labels for UI elements around your site. This allows your visitors to experience your site fully in their language.

1. Create a `src/i18n/ui.ts` file to store your translation strings:
   src/i18n/ui.ts
  ```
  export const languages = {  en: 'English',  fr: 'Fran√ßais',};
  export const defaultLang = 'en';
  export const ui = {  en: {    'nav.home': 'Home',    'nav.about': 'About',    'nav.twitter': 'Twitter',  },  fr: {    'nav.home': 'Accueil',    'nav.about': '√Ä propos',  },} as const;
  ```
2. Create two helper functions: one to detect the page language based on the current URL, and one to get translations strings for different parts of the UI in `src/i18n/utils.ts`:
   src/i18n/utils.ts
  ```
  import { ui, defaultLang } from './ui';
  export function getLangFromUrl(url: URL) {  const [, lang] = url.pathname.split('/');  if (lang in ui) return lang as keyof typeof ui;  return defaultLang;}
  export function useTranslations(lang: keyof typeof ui) {  return function t(key: keyof typeof ui[typeof defaultLang]) {    return ui[lang][key] || ui[defaultLang][key];  }}
  ```
3. Import the helpers where needed and use them to choose the UI string that corresponds to the current language. For example, a nav component might look like:
   src/components/Nav.astro
  ```
  ---import { getLangFromUrl, useTranslations } from '../i18n/utils';
  const lang = getLangFromUrl(Astro.url);const t = useTranslations(lang);---<ul>    <li>        <a href={`/${lang}/home/`}>          {t('nav.home')}        </a>    </li>    <li>        <a href={`/${lang}/about/`}>          {t('nav.about')}        </a>    </li>    <li>        <a href="https://twitter.com/astrodotbuild">          {t('nav.twitter')}        </a>    </li></ul>
  ```
4. Each page must have a `lang` attribute on the `<html>` element that matches the language on the page. In this example, a [reusable layout](https://docs.astro.build/en/basics/layouts/) extracts the language from the current route:
   src/layouts/Base.astro
  ```
  ---import { getLangFromUrl } from '../i18n/utils';
  const lang = getLangFromUrl(Astro.url);---<html lang={lang}>    <head>        <meta charset="utf-8" />        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />        <meta name="viewport" content="width=device-width" />        <title>Astro</title>    </head>    <body>        <slot />    </body></html>
  ```
  You can then use this base layout to ensure that pages use the correct `lang` attribute automatically.
   src/pages/en/about.astro
  ```
  ---import Base from '../../layouts/Base.astro';---<Base>    <h1>About me</h1>    ...</Base>
  ```

### Let users switch between languages

[Section titled ‚ÄúLet users switch between languages‚Äù](#let-users-switch-between-languages)

Create links to the different languages you support so users can choose the language they want to read your site in.

1. Create a component to show a link for each language:
   src/components/LanguagePicker.astro
  ```
  ---import { languages } from '../i18n/ui';---<ul>  {Object.entries(languages).map(([lang, label]) => (    <li>      <a href={`/${lang}/`}>{label}</a>    </li>  ))}</ul>
  ```
2. Add `<LanguagePicker />` to your site so it is shown on every page. The example below adds it to the site footer in a base layout:
   src/layouts/Base.astro
  ```
  ---import LanguagePicker from '../components/LanguagePicker.astro';import { getLangFromUrl } from '../i18n/utils';
  const lang = getLangFromUrl(Astro.url);---<html lang={lang}>    <head>        <meta charset="utf-8" />        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />        <meta name="viewport" content="width=device-width" />        <title>Astro</title>    </head>    <body>        <slot />        <footer>          <LanguagePicker />        </footer>    </body></html>
  ```

### Hide default language in the URL

[Section titled ‚ÄúHide default language in the URL‚Äù](#hide-default-language-in-the-url)

1. Create a directory for each language except the default language. For example, store your default language pages directly in `pages/`, and your translated pages in `fr/`:
  - Directorysrc/
    - Directorypages/
      - about.astro
      - index.astro
      - Directory**fr/**
        - about.astro
        - index.astro
2. Add another line to the `src/i18n/ui.ts` file to toggle the feature:
   src/i18n/ui.ts
  ```
  export const showDefaultLang = false;
  ```
3. Add a helper function to `src/i18n/utils.ts`, to translate paths based on the current language:
   src/i18n/utils.ts
  ```
  import { ui, defaultLang, showDefaultLang } from './ui';
  export function useTranslatedPath(lang: keyof typeof ui) {  return function translatePath(path: string, l: string = lang) {    return !showDefaultLang && l === defaultLang ? path : `/${l}${path}`  }}
  ```
4. Import the helper where needed. For example, a `nav` component might look like:
   src/components/Nav.astro
  ```
  ---import { getLangFromUrl, useTranslations, useTranslatedPath } from '../i18n/utils';
  const lang = getLangFromUrl(Astro.url);const t = useTranslations(lang);const translatePath = useTranslatedPath(lang);---<ul>    <li>        <a href={translatePath('/home/')}>          {t('nav.home')}        </a>    </li>    <li>        <a href={translatePath('/about/')}>          {t('nav.about')}        </a>    </li>    <li>        <a href="https://twitter.com/astrodotbuild">          {t('nav.twitter')}        </a>    </li></ul>
  ```
5. The helper function can also be used to translate paths for a specific language. For example, when users switch between languages:
   src/components/LanguagePicker.astro
  ```
  ---import { languages } from '../i18n/ui';import { getLangFromUrl, useTranslatedPath } from '../i18n/utils';
  const lang = getLangFromUrl(Astro.url);const translatePath = useTranslatedPath(lang);---<ul>  {Object.entries(languages).map(([lang, label]) => (    <li>      <a href={translatePath('/', lang)}>{label}</a>    </li>  ))}</ul>
  ```

### Translate Routes

[Section titled ‚ÄúTranslate Routes‚Äù](#translate-routes)

Translate the routes of your pages for each language.

1. Add route mappings to `src/i18n/ui.ts`:
   src/i18n/ui.ts
  ```
  export const routes = {  de: {    'services': 'leistungen',  },  fr: {    'services': 'prestations-de-service',  },}
  ```
2. Update the `useTranslatedPath` helper function in `src/i18n/utils.ts` to add router translation logic.
   src/i18n/utils.ts
  ```
  import { ui, defaultLang, showDefaultLang, routes } from './ui';
  export function useTranslatedPath(lang: keyof typeof ui) {  return function translatePath(path: string, l: string = lang) {    const pathName = path.replaceAll('/', '')    const hasTranslation = defaultLang !== l && routes[l] !== undefined && routes[l][pathName] !== undefined    const translatedPath = hasTranslation ? '/' + routes[l][pathName] : path
      return !showDefaultLang && l === defaultLang ? translatedPath : `/${l}${translatedPath}`  }}
  ```
3. Create a helper function to get the route, if it exists based on the current URL, in `src/i18n/utils.ts`:
   src/i18n/utils.ts
  ```
  import { ui, defaultLang, showDefaultLang, routes } from './ui';
  export function getRouteFromUrl(url: URL): string | undefined {  const pathname = new URL(url).pathname;  const parts = pathname?.split('/');  const path = parts.pop() || parts.pop();
    if (path === undefined) {    return undefined;  }
    const currentLang = getLangFromUrl(url);
    if (defaultLang === currentLang) {    const route = Object.values(routes)[0];    return route[path] !== undefined ? route[path] : undefined;  }
    const getKeyByValue = (obj: Record<string, string>, value: string): string | undefined  => {      return Object.keys(obj).find((key) => obj[key] === value);  }
    const reversedKey = getKeyByValue(routes[currentLang], path);
    if (reversedKey !== undefined) {    return reversedKey;  }
    return undefined;}
  ```
4. The helper function can be used to get a translated route. For example, when no translated route is defined, the user will be redirected to the home page:
   src/components/LanguagePicker.astro
  ```
  ---import { languages } from '../i18n/ui';import { getRouteFromUrl, useTranslatedPath } from '../i18n/utils';
  const route = getRouteFromUrl(Astro.url);---<ul>  {Object.entries(languages).map(([lang, label]) => {    const translatePath = useTranslatedPath(lang);    return (      <li>        <a href={translatePath(`/${route ? route : ''}`)}>{label}</a>      </li>    )  })}</ul>
  ```

## Resources

[Section titled ‚ÄúResources‚Äù](#resources)

- [Choosing a Language Tag](https://www.w3.org/International/questions/qa-choosing-language-tags)
- [Right-to-left (RTL) Styling 101](https://rtlstyling.com/)

## Community libraries

[Section titled ‚ÄúCommunity libraries‚Äù](#community-libraries)

Find [community-built i18n utilities](https://astro.build/integrations/?search=i18n) that you can add to your Astro project in our integrations directory.

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Create a dev toolbar app

> Learn how to create a dev toolbar app for your site.

# Create a dev toolbar app

Astro includes a [development toolbar](https://docs.astro.build/en/guides/dev-toolbar/) that you can use to inspect your site, check for accessibility and performance issues, and more. This toolbar can be extended with custom apps.

## Build a motivational dev toolbar app

[Section titled ‚ÄúBuild a motivational dev toolbar app‚Äù](#build-a-motivational-dev-toolbar-app)

In this recipe, you‚Äôll learn how to create a dev toolbar app that helps you stay motivated while working on your site. This app will display a motivational message every time you toggle it on.

### Creating the Astro integration

[Section titled ‚ÄúCreating the Astro integration‚Äù](#creating-the-astro-integration)

Dev toolbar apps can only be added by [Astro Integrations](https://docs.astro.build/en/guides/integrations-guide/) using [theastro:config:setuphook](https://docs.astro.build/en/reference/integrations-reference/#astroconfigsetup). You will need to create both a toolbar app and the integration that will add it to the toolbar of your existing Astro project.

1. In the root of your existing Astro project, create a new folder named `my-toolbar-app/` for your app and integration files. Create two new files in this folder: `app.ts` and `my-integration.ts`.
  - Directory**my-toolbar-app/**
    - **app.ts**
    - **my-integration.ts**
  - Directorysrc/
    - Directorypages/
      - ‚Ä¶
    - ‚Ä¶
  - astro.config.mjs
  - package.json
  - tsconfig.json
2. In `my-integration.ts`, add the following code to provide both the name of your integration and the [addDevToolbarApp()function](https://docs.astro.build/en/reference/dev-toolbar-app-reference/#toolbar-app-integration-setup) needed to add your dev toolbar app with the `astro:config:setup` hook:
   my-toolbar-app/my-integration.ts
  ```
  import { fileURLToPath } from 'node:url';import type { AstroIntegration } from 'astro';
  export default {  name: 'my-astro-integration',  hooks: {    'astro:config:setup': ({ addDevToolbarApp }) => {      addDevToolbarApp({        id: "my-toolbar-app",        name: "My Toolbar App",        icon: "üöÄ",        entrypoint: fileURLToPath(new URL('./app.ts', import.meta.url))      });    },  },} satisfies AstroIntegration;
  ```
3. To use this integration in your project, add it to the `integrations` array in your `astro.config.mjs` file.
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';import myIntegration from './my-toolbar-app/my-integration.ts';
  export default defineConfig({  integrations: [myIntegration],})
  ```
4. If not already running, start the dev server. If your integration has been successfully added to your project, you should see a new ‚Äúundefined‚Äù app in the dev toolbar.
  But, you will also see an error message that your dev toolbar app has failed to load. This is because you have not yet built the app itself. You will do that in the next section.

    See the [Astro Integration API documentation](https://docs.astro.build/en/reference/integrations-reference/) for more about building Astro integrations.

### Creating the app

[Section titled ‚ÄúCreating the app‚Äù](#creating-the-app)

Dev toolbar apps are defined using the `defineToolbarApp()` function from the `astro/toolbar` module. This function takes an object with an `init()` function that will be called when the dev toolbar app is loaded.

This `init()` function contains your app logic to render elements to the screen, send and receive client-side events from the dev toolbar, and communicate with the server.

 app.ts

```
import { defineToolbarApp } from "astro/toolbar";
export default defineToolbarApp({    init(canvas, app, server) {      // ...    },});
```

To display motivational messages on the screen, you will use the `canvas` property to access a standard [ShadowRoot](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot). Elements can be created and added to the ShadowRoot using the standard DOM APIs.

1. Copy the following code into `my-toolbar-app/app.ts`. This provides a list of motivational messages, and the logic to create a new `<h1>` element with a random message:
   my-toolbar-app/app.ts
  ```
  import { defineToolbarApp } from "astro/toolbar";
  const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
  export default defineToolbarApp({    init(canvas) {      const h1 = document.createElement('h1');      h1.textContent = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];
        canvas.append(h1);    },});
  ```
2. Start the dev server if it is not already running and toggle the app on in the dev toolbar. If your app is working successfully, you will see a motivational message displayed in the top-left corner of the screen. (And, it‚Äôs true!)
  However, this message will not change when the app is toggled on and off, as the `init()` function is only called once when the app is loaded.
3. To add client-side interactivity to your app, add the `app` argument and use `onAppToggled()` to select a new random message each time your toolbar app is toggled on:
   app.ts
  ```
  import { defineToolbarApp } from "astro/toolbar";
  const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
  export default defineToolbarApp({    init(canvas, app) {      const h1 = document.createElement('h1');      h1.textContent = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];
        canvas.append(h1);
        // Display a random message when the app is toggled      app.onToggled(({ state }) => {        const newMessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];        h1.textContent = newMessage;      });    },});
  ```
4. In your browser preview, toggle your app on and off several times. With this change, a new random message will be selected every time you toggle the app on, providing you with an infinite source of motivation!

   See the [Astro Dev Toolbar API documentation](https://docs.astro.build/en/reference/dev-toolbar-app-reference/) for more about building dev toolbar apps.

## Building apps with a UI framework

[Section titled ‚ÄúBuilding apps with a UI framework‚Äù](#building-apps-with-a-ui-framework)

UI frameworks like React, Vue, or Svelte can also be used to create dev toolbar apps. These frameworks provide a more declarative way to create UIs and can make your code more maintainable and easier to read.

The same motivational dev toolbar app built into your existing Astro project earlier on this page with JavaScript can be built using a UI framework (e.g. Preact) instead. Depending on your chosen framework, you may or may not require a build step.

### Without a build step

[Section titled ‚ÄúWithout a build step‚Äù](#without-a-build-step)

If your framework supports it, you can create a dev toolbar app without a build step. For example, you can use Preact‚Äôs `h` function to create elements and render them directly to the ShadowRoot:

 app.ts

```
import { defineToolbarApp } from "astro/toolbar";import { render, h } from "preact";
const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
export default defineToolbarApp({    init(canvas) {      const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];      render(h('h1', null, message), canvas);    },});
```

Alternatively, the [htmpackage](https://github.com/developit/htm) is a good choice for creating dev toolbar apps without a build step, offering native integration for React and Preact and support for other frameworks:

 app.ts

```
import { defineToolbarApp } from "astro/toolbar";import { render } from "preact";import { html } from 'htm/preact';
const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
export default defineToolbarApp({    init(canvas) {      const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];      render(html`<h1>${message}</h1>`, canvas);    },});
```

In both cases, you can now start your project and see the motivational message displayed in the top-left corner of the screen when you toggle the app on.

### With a build step

[Section titled ‚ÄúWith a build step‚Äù](#with-a-build-step)

Astro does not preprocess JSX code in dev toolbar apps, so a build step is required in order to use JSX components in your dev toolbar app.

The following steps will use TypeScript to do this, but any other tools that compile JSX code will also work (e.g. Babel, Rollup, ESBuild).

1. Install TypeScript inside your project:
  - [npm](#tab-panel-1900)
  - [pnpm](#tab-panel-1901)
  - [Yarn](#tab-panel-1902)
     Terminal window
  ```
  npm install --save-dev typescript
  ```
     Terminal window
  ```
  pnpm install --save-dev typescript
  ```
     Terminal window
  ```
  yarn add --dev typescript
  ```
2. Create a `tsconfig.json` file in the root of your toolbar app‚Äôs folder with the appropriate settings to build and for the framework you‚Äôre using ([React](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup), [Preact](https://preactjs.com/guide/v10/typescript), [Solid](https://www.solidjs.com/guides/typescript)). For example, for Preact:
   my-toolbar-app/tsconfig.json
  ```
  {  "compilerOptions": {    "skipLibCheck": true,    "module": "NodeNext",    "jsx": "react-jsx",    "jsxImportSource": "preact",  }}
  ```
3. Adjust the `entrypoint` in your integration to point to the compiled file, remembering that this file is relative to the root of your Astro project:
   my-integration.ts
  ```
  addDevToolbarApp({  id: "my-toolbar-app",  name: "My Toolbar App",  icon: "üöÄ",  entrypoint: join(__dirname, "./app.js"),});
  ```
4. Run `tsc` to build your toolbar app, or `tsc --watch` to automatically rebuild your app when you make changes.
  With these changes, you can now rename your `app.ts` file to `app.tsx` (or `.jsx`) and use JSX syntax to create your dev toolbar app:
   app.tsx
  ```
  import { defineToolbarApp } from "astro/toolbar";import { render } from "preact";
  const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
  export default defineToolbarApp({    init(canvas) {      const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];      render(<h1>{message}</h1>, canvas);    },});
  ```

You should now have all the tools you need to create a dev toolbar app using a UI framework of your choice!

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Add last modified time

> Build a remark plugin to add the last modified time to your Markdown and MDX.

# Add last modified time

Learn how to build a [remark plugin](https://github.com/remarkjs/remark) that adds the last modified time to the frontmatter of your Markdown and MDX files. Use this property to  display the modified time in your pages.

## Recipe

[Section titled ‚ÄúRecipe‚Äù](#recipe)

1. Install Helper Packages
  Install [Day.js](https://www.npmjs.com/package/dayjs) to modify and format times:
  - [npm](#tab-panel-1903)
  - [pnpm](#tab-panel-1904)
  - [Yarn](#tab-panel-1905)
     Terminal window
  ```
  npm install dayjs
  ```
     Terminal window
  ```
  pnpm add dayjs
  ```
     Terminal window
  ```
  yarn add dayjs
  ```
2. Create a Remark Plugin
  This plugin uses `execSync` to run a Git command that returns the timestamp of the latest commit in ISO 8601 format. The timestamp is then added to the frontmatter of the file.
   remark-modified-time.mjs
  ```
  import { execSync } from "child_process";
  export function remarkModifiedTime() {  return function (tree, file) {    const filepath = file.history[0];    const result = execSync(`git log -1 --pretty="format:%cI" "${filepath}"`);    file.data.astro.frontmatter.lastModified = result.toString();  };}
  ```
   Using the file system instead of Git
  Although using Git is the recommended way to get the last modified timestamp from a file, it is possible to use the file system modified time.
  This plugin uses `statSync` to get the `mtime` (modified time) of the file in ISO 8601 format. The timestamp is then added to the frontmatter of the file.
  remark-modified-time.mjs
  ```
  import { statSync } from "fs";
  export function remarkModifiedTime() {  return function (tree, file) {    const filepath = file.history[0];    const result = statSync(filepath);    file.data.astro.frontmatter.lastModified = result.mtime.toISOString();  };}
  ```
3. Add the plugin to your config
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';import { remarkModifiedTime } from './remark-modified-time.mjs';
  export default defineConfig({  markdown: {    remarkPlugins: [remarkModifiedTime],  },});
  ```
  Now all Markdown documents will have a `lastModified` property in their frontmatter.
4. Display Last Modified Time
  If your content is stored in a [content collection](https://docs.astro.build/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then render `lastModified` in your template wherever you would like it to appear.
   src/pages/posts/[slug].astro
  ```
  ---import { getCollection, render } from 'astro:content';import dayjs from "dayjs";import utc from "dayjs/plugin/utc";
  dayjs.extend(utc);
  export async function getStaticPaths() {  const blog = await getCollection('blog');  return blog.map(entry => ({    params: { slug: entry.id },    props: { entry },  }));}
  const { entry } = Astro.props;const { Content, remarkPluginFrontmatter } = await render(entry);
  const lastModified = dayjs(remarkPluginFrontmatter.lastModified)  .utc()  .format("HH:mm:ss DD MMMM YYYY UTC");---
  <html>  <head>...</head>  <body>    ...    <p>Last Modified: {lastModified}</p>    ...  </body></html>
  ```
  If you‚Äôre using a [Markdown layout](https://docs.astro.build/en/basics/layouts/#markdown-layouts), use the `lastModified` frontmatter property from `Astro.props` in your layout template.
   src/layouts/BlogLayout.astro
  ```
  ---import dayjs from "dayjs";import utc from "dayjs/plugin/utc";
  dayjs.extend(utc);
  const lastModified = dayjs()  .utc(Astro.props.frontmatter.lastModified)  .format("HH:mm:ss DD MMMM YYYY UTC");---
  <html>  <head>...</head>  <body>    <p>{lastModified}</p>    <slot />  </body></html>
  ```

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

---

# Add reading time

> Build a remark plugin to add reading time to your Markdown or MDX files.

# Add reading time

Create a [remark plugin](https://github.com/remarkjs/remark) which adds a reading time property to the frontmatter of your Markdown or MDX files. Use this property to display the reading time for each page.

## Recipe

[Section titled ‚ÄúRecipe‚Äù](#recipe)

1. Install Helper Packages
  Install these two helper packages:
  - [reading-time](https://www.npmjs.com/package/reading-time) to calculate minutes read
  - [mdast-util-to-string](https://www.npmjs.com/package/mdast-util-to-string) to extract all text from your markdown
  - [npm](#tab-panel-1906)
  - [pnpm](#tab-panel-1907)
  - [Yarn](#tab-panel-1908)
     Terminal window
  ```
  npm install reading-time mdast-util-to-string
  ```
     Terminal window
  ```
  pnpm add reading-time mdast-util-to-string
  ```
     Terminal window
  ```
  yarn add reading-time mdast-util-to-string
  ```
2. Create a remark plugin.
  This plugin uses the `mdast-util-to-string` package to get the Markdown file‚Äôs text. This text is then passed to the `reading-time` package to calculate the reading time in minutes.
   remark-reading-time.mjs
  ```
  import getReadingTime from 'reading-time';import { toString } from 'mdast-util-to-string';
  export function remarkReadingTime() {  return function (tree, { data }) {    const textOnPage = toString(tree);    const readingTime = getReadingTime(textOnPage);    // readingTime.text will give us minutes read as a friendly string,    // i.e. "3 min read"    data.astro.frontmatter.minutesRead = readingTime.text;  };}
  ```
3. Add the plugin to your config:
   astro.config.mjs
  ```
  import { defineConfig } from 'astro/config';import { remarkReadingTime } from './remark-reading-time.mjs';
  export default defineConfig({  markdown: {    remarkPlugins: [remarkReadingTime],  },});
  ```
  Now all Markdown documents will have a calculated `minutesRead` property in their frontmatter.
4. Display Reading Time
  If your blog posts are stored in a [content collection](https://docs.astro.build/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then, render `minutesRead` in your template wherever you would like it to appear.
   src/pages/posts/[slug].astro
  ```
  ---import { getCollection, render } from 'astro:content';
  export async function getStaticPaths() {  const blog = await getCollection('blog');  return blog.map(entry => ({    params: { slug: entry.id },    props: { entry },  }));}
  const { entry } = Astro.props;const { Content, remarkPluginFrontmatter } = await render(entry);---
  <html>  <head>...</head>  <body>    ...    <p>{remarkPluginFrontmatter.minutesRead}</p>    ...  </body></html>
  ```
  If you‚Äôre using a [Markdown layout](https://docs.astro.build/en/basics/layouts/#markdown-layouts), use the `minutesRead` frontmatter property from `Astro.props` in your layout template.
   src/layouts/BlogLayout.astro
  ```
  ---const { minutesRead } = Astro.props.frontmatter;---
  <html>  <head>...</head>  <body>    <p>{minutesRead}</p>    <slot />  </body></html>
  ```

 Recipes     [Contribute](https://docs.astro.build/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
