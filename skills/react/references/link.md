# hydrateRoot and more

# hydrateRoot

[API Reference](https://react.dev/reference/react)[Client APIs](https://react.dev/reference/react-dom/client)

# hydrateRoot

`hydrateRoot` lets you display React components inside a browser DOM node whose HTML content was previously generated by [react-dom/server.](https://react.dev/reference/react-dom/server)

$

```
const root = hydrateRoot(domNode, reactNode, options?)
```

/$

- [Reference](#reference)
  - [hydrateRoot(domNode, reactNode, options?)](#hydrateroot)
  - [root.render(reactNode)](#root-render)
  - [root.unmount()](#root-unmount)
- [Usage](#usage)
  - [Hydrating server-rendered HTML](#hydrating-server-rendered-html)
  - [Hydrating an entire document](#hydrating-an-entire-document)
  - [Suppressing unavoidable hydration mismatch errors](#suppressing-unavoidable-hydration-mismatch-errors)
  - [Handling different client and server content](#handling-different-client-and-server-content)
  - [Updating a hydrated root component](#updating-a-hydrated-root-component)
  - [Error logging in production](#error-logging-in-production)
- [Troubleshooting](#troubleshooting)
  - [I‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù](#im-getting-an-error-you-passed-a-second-argument-to-root-render)

---

## Reference

### hydrateRoot(domNode, reactNode, options?)

Call `hydrateRoot` to ‚Äúattach‚Äù React to existing HTML that was already rendered by React in a server environment.

 $

```
import { hydrateRoot } from 'react-dom/client';const domNode = document.getElementById('root');const root = hydrateRoot(domNode, reactNode);
```

/$

React will attach to the HTML that exists inside the `domNode`, and take over managing the DOM inside it. An app fully built with React will usually only have one `hydrateRoot` call with its root component.

[See more examples below.](#usage)

#### Parameters

- `domNode`: A [DOM element](https://developer.mozilla.org/en-US/docs/Web/API/Element) that was rendered as the root element on the server.
- `reactNode`: The ‚ÄúReact node‚Äù used to render the existing HTML. This will usually be a piece of JSX like `<App />` which was rendered with a `ReactDOM Server` method such as `renderToPipeableStream(<App />)`.
- **optional** `options`: An object with options for this React root.
  - **optional** `onCaughtError`: Callback called when React catches an error in an Error Boundary. Called with the `error` caught by the Error Boundary, and an `errorInfo` object containing the `componentStack`.
  - **optional** `onUncaughtError`: Callback called when an error is thrown and not caught by an Error Boundary. Called with the `error` that was thrown and an `errorInfo` object containing the `componentStack`.
  - **optional** `onRecoverableError`: Callback called when React automatically recovers from errors. Called with the `error` React throws, and an `errorInfo` object containing the `componentStack`. Some recoverable errors may include the original error cause as `error.cause`.
  - **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [useId.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.

#### Returns

`hydrateRoot` returns an object with two methods: [render](#root-render) and [unmount.](#root-unmount)

#### Caveats

- `hydrateRoot()` expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them.
- In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.
- You‚Äôll likely have only one `hydrateRoot` call in your app. If you use a framework, it might do this call for you.
- If your app is client-rendered with no HTML rendered already, using `hydrateRoot()` is not supported. Use [createRoot()](https://react.dev/reference/react-dom/client/createRoot) instead.

---

### root.render(reactNode)

Call `root.render` to update a React component inside a hydrated React root for a browser DOM element.

 $

```
root.render(<App />);
```

/$

React will update `<App />` in the hydrated `root`.

[See more examples below.](#usage)

#### Parameters

- `reactNode`: A ‚ÄúReact node‚Äù that you want to update. This will usually be a piece of JSX like `<App />`, but you can also pass a React element constructed with [createElement()](https://react.dev/reference/react/createElement), a string, a number, `null`, or `undefined`.

#### Returns

`root.render` returns `undefined`.

#### Caveats

- If you call `root.render` before the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.

---

### root.unmount()

Call `root.unmount` to destroy a rendered tree inside a React root.

 $

```
root.unmount();
```

/$

An app fully built with React will usually not have any calls to `root.unmount`.

This is mostly useful if your React root‚Äôs DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to ‚Äústop‚Äù managing the removed root‚Äôs content by calling `root.unmount`. Otherwise, the components inside the removed root won‚Äôt clean up and free up resources like subscriptions.

Calling `root.unmount` will unmount all the components in the root and ‚Äúdetach‚Äù React from the root DOM node, including removing any event handlers or state in the tree.

#### Parameters

`root.unmount` does not accept any parameters.

#### Returns

`root.unmount` returns `undefined`.

#### Caveats

- Calling `root.unmount` will unmount all the components in the tree and ‚Äúdetach‚Äù React from the root DOM node.
- Once you call `root.unmount` you cannot call `root.render` again on the root. Attempting to call `root.render` on an unmounted root will throw a ‚ÄúCannot update an unmounted root‚Äù error.

---

## Usage

### Hydrating server-rendered HTML

If your app‚Äôs HTML was generated by [react-dom/server](https://react.dev/reference/react-dom/client/createRoot), you need to *hydrate* it on the client.

 $

```
import { hydrateRoot } from 'react-dom/client';hydrateRoot(document.getElementById('root'), <App />);
```

/$

This will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.

To hydrate your app, React will ‚Äúattach‚Äù your components‚Äô logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.

 $[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app)import './styles.css';import { hydrateRoot } from 'react-dom/client';import App from './App.js';
hydrateRoot( document.getElementById('root'), <App />);
/$

You shouldn‚Äôt need to call `hydrateRoot` again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will [use state](https://react.dev/reference/react/useState) instead.

### Pitfall

The React tree you pass to `hydrateRoot` needs to produce **the same output** as it did on the server.

This is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client.

The most common causes leading to hydration errors include:

- Extra whitespace (like newlines) around the React-generated HTML inside the root node.
- Using checks like `typeof window !== 'undefined'` in your rendering logic.
- Using browser-only APIs like [window.matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your rendering logic.
- Rendering different data on the server and the client.

React recovers from some hydration errors, but **you must fix them like other bugs.** In the best case, they‚Äôll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements.

---

### Hydrating an entire document

Apps fully built with React can render the entire document as JSX, including the [<html>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html) tag:

 $

```
function App() {  return (    <html>      <head>        <meta charSet="utf-8" />        <meta name="viewport" content="width=device-width, initial-scale=1" />        <link rel="stylesheet" href="/styles.css"></link>        <title>My app</title>      </head>      <body>        <Router />      </body>    </html>  );}
```

/$

To hydrate the entire document, pass the [document](https://developer.mozilla.org/en-US/docs/Web/API/Window/document) global as the first argument to `hydrateRoot`:

 $

```
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App />);
```

/$

---

### Suppressing unavoidable hydration mismatch errors

If a single element‚Äôs attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.

To silence hydration warnings on an element, add `suppressHydrationWarning={true}`:

 $[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app)

```
export default function App() {
  return (
    <h1 suppressHydrationWarning={true}>
      Current Date: {new Date().toLocaleDateString()}
    </h1>
  );
}
```

/$

This only works one level deep, and is intended to be an escape hatch. Don‚Äôt overuse it. React will **not** attempt to patch mismatched text content.

---

### Handling different client and server content

If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a [state variable](https://react.dev/reference/react/useState) like `isClient`, which you can set to `true` in an [Effect](https://react.dev/reference/react/useEffect):

 $[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app)

```
import { useState, useEffect } from "react";

export default function App() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return (
    <h1>
      {isClient ? 'Is Client' : 'Is Server'}
    </h1>
  );
}
```

/$

This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.

### Pitfall

This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user.

---

### Updating a hydrated root component

After the root has finished hydrating, you can call [root.render](#root-render) to update the root React component. **Unlike withcreateRoot, you don‚Äôt usually need to do this because the initial content was already rendered as HTML.**

If you call `root.render` at some point after hydration, and the component tree structure matches up with what was previously rendered, React will [preserve the state.](https://react.dev/learn/preserving-and-resetting-state) Notice how you can type in the input, which means that the updates from repeated `render` calls every second in this example are not destructive:

 $[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app)

```
import { hydrateRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = hydrateRoot(
  document.getElementById('root'),
  <App counter={0} />
);

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);
```

/$

It is uncommon to call [root.render](#root-render) on a hydrated root. Usually, you‚Äôll [update state](https://react.dev/reference/react/useState) inside one of the components instead.

### Error logging in production

By default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options `onUncaughtError`, `onCaughtError` and `onRecoverableError`:

 $

```
import { hydrateRoot } from "react-dom/client";import App from "./App.js";import { reportCaughtError } from "./reportError";const container = document.getElementById("root");const root = hydrateRoot(container, <App />, {  onCaughtError: (error, errorInfo) => {    if (error.message !== "Known error") {      reportCaughtError({        error,        componentStack: errorInfo.componentStack,      });    }  },});
```

/$

The onCaughtError option is a function called with two arguments:

1. The error that was thrown.
2. An errorInfo object that contains the componentStack of the error.

Together with `onUncaughtError` and `onRecoverableError`, you can implement your own error reporting system:

 $[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app)

```
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import {
  onCaughtErrorProd,
  onRecoverableErrorProd,
  onUncaughtErrorProd,
} from "./reportError";

const container = document.getElementById("root");
hydrateRoot(container, <App />, {
  // Keep in mind to remove these options in development to leverage
  // React's default handlers or implement your own overlay for development.
  // The handlers are only specfied unconditionally here for demonstration purposes.
  onCaughtError: onCaughtErrorProd,
  onRecoverableError: onRecoverableErrorProd,
  onUncaughtError: onUncaughtErrorProd,
});
```

/$

## Troubleshooting

### I‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù

A common mistake is to pass the options for `hydrateRoot` to `root.render(...)`:

 ConsoleWarning: You passed a second argument to root.render(‚Ä¶) but it only accepts one argument.

To fix, pass the root options to `hydrateRoot(...)`, not `root.render(...)`:

 $

```
// üö© Wrong: root.render only takes one argument.root.render(App, {onUncaughtError});// ‚úÖ Correct: pass options to createRoot.const root = hydrateRoot(container, <App />, {onUncaughtError});
```

/$[PreviouscreateRoot](https://react.dev/reference/react-dom/client/createRoot)[NextServer APIs](https://react.dev/reference/react-dom/server)

---

# Introducing the New JSX Transform

September 22, 2020  by  [Luna Ruan](https://twitter.com/lunaruan)

> This blog site has been archived. Go to [react.dev/blog](https://react.dev/blog) to see the recent posts.

Although React 17 [doesn‚Äôt contain new features](https://react.dev/blog/2020/08/10/react-v17-rc.html), it will provide support for a new version of the JSX transform. In this post, we will describe what it is and how to try it.

## What‚Äôs a JSX Transform?

Browsers don‚Äôt understand JSX out of the box, so most React users rely on a compiler like Babel or TypeScript to **transform JSX code into regular JavaScript**. Many preconfigured toolkits like Create React App or Next.js also include a JSX transform under the hood.

Together with the React 17 release, we‚Äôve wanted to make a few improvements to the JSX transform, but we didn‚Äôt want to break existing setups. This is why we [worked with Babel](https://babeljs.io/blog/2020/03/16/7.9.0#a-new-jsx-transform-11154httpsgithubcombabelbabelpull11154) to **offer a new, rewritten version of the JSX transform** for people who would like to upgrade.

Upgrading to the new transform is completely optional, but it has a few benefits:

- With the new transform, you can **use JSX without importing React**.
- Depending on your setup, its compiled output may **slightly improve the bundle size**.
- It will enable future improvements that **reduce the number of concepts** you need to learn React.

**This upgrade will not change the JSX syntax and is not required.** The old JSX transform will keep working as usual, and there are no plans to remove the support for it.

[React 17 RC](https://react.dev/blog/2020/08/10/react-v17-rc.html) already includes support for the new transform, so go give it a try! To make it easier to adopt, **we‚Äôve also backported its support** to React 16.14.0, React 15.7.0, and React 0.14.10. You can find the upgrade instructions for different tools [below](#how-to-upgrade-to-the-new-jsx-transform).

Now let‚Äôs take a closer look at the differences between the old and the new transform.

## What‚Äôs Different in the New Transform?

When you use JSX, the compiler transforms it into React function calls that the browser can understand. **The old JSX transform** turned JSX into `React.createElement(...)` calls.

For example, let‚Äôs say your source code looks like this:

```
import React from 'react';

function App() {
  return <h1>Hello World</h1>;
}
```

Under the hood, the old JSX transform turns it into regular JavaScript:

```
import React from 'react';

function App() {
  return React.createElement('h1', null, 'Hello world');
}
```

> Note
>
>
>
> **Your source code doesn‚Äôt need to change in any way.** We‚Äôre describing how the JSX transform turns your JSX source code into the JavaScript code a browser can understand.

However, this is not perfect:

- Because JSX was compiled into `React.createElement`, `React` needed to be in scope if you used JSX.
- There are some [performance improvements and simplifications](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#motivation) that `React.createElement` does not allow.

To solve these issues, React 17 introduces two new entry points to the React package that are intended to only be used by compilers like Babel and TypeScript. Instead of transforming JSX to `React.createElement`, **the new JSX transform** automatically imports special functions from those new entry points in the React package and calls them.

Let‚Äôs say that your source code looks like this:

```
function App() {
  return <h1>Hello World</h1>;
}
```

This is what the new JSX transform compiles it to:

```
// Inserted by a compiler (don't import it yourself!)
import {jsx as _jsx} from 'react/jsx-runtime';

function App() {
  return _jsx('h1', { children: 'Hello world' });
}
```

Note how our original code **did not need to import React** to use JSX anymore! (But we would still need to import React in order to use Hooks or other exports that React provides.)

**This change is fully compatible with all of the existing JSX code**, so you won‚Äôt have to change your components. If you‚Äôre curious, you can check out the [technical RFC](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#detailed-design) for more details about how the new transform works.

> Note
>
>
>
> The functions inside `react/jsx-runtime` and `react/jsx-dev-runtime` must only be used by the compiler transform. If you need to manually create elements in your code, you should keep using `React.createElement`. It will continue to work and is not going away.

## How to Upgrade to the New JSX Transform

If you aren‚Äôt ready to upgrade to the new JSX transform or if you are using JSX for another library, don‚Äôt worry. The old transform will not be removed and will continue to be supported.

If you want to upgrade, you will need two things:

- **A version of React that supports the new transform** ([React 17 RC](https://react.dev/blog/2020/08/10/react-v17-rc.html) and higher supports it, but we‚Äôve also released React 16.14.0, React 15.7.0, and React 0.14.10 for people who are still on the older major versions).
- **A compatible compiler** (see instructions for different tools below).

Since the new JSX transform doesn‚Äôt require React to be in scope, [we‚Äôve also prepared an automated script](#removing-unused-react-imports) that will remove the unnecessary imports from your codebase.

### Create React App

Create React App [4.0.0](https://github.com/facebook/create-react-app/releases/tag/v4.0.0)+ uses the new transform for compatible React versions.

### Next.js

Next.js [v9.5.3](https://github.com/vercel/next.js/releases/tag/v9.5.3)+ uses the new transform for compatible React versions.

### Gatsby

Gatsby [v2.24.5](https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/CHANGELOG.md#22452-2020-08-28)+ uses the new transform for compatible React versions.

> Note
>
>
>
> If you get [this Gatsby error](https://github.com/gatsbyjs/gatsby/issues/26979) after upgrading to React 17 RC, run `npm update` to fix it.

### Manual Babel Setup

Support for the new JSX transform is available in Babel [v7.9.0](https://babeljs.io/blog/2020/03/16/7.9.0) and above.

First, you‚Äôll need to update to the latest Babel and plugin transform.

If you are using `@babel/plugin-transform-react-jsx`:

```
# for npm users
npm update @babel/core @babel/plugin-transform-react-jsx
```

```
# for yarn users
yarn upgrade @babel/core @babel/plugin-transform-react-jsx
```

If you are using `@babel/preset-react`:

```
# for npm users
npm update @babel/core @babel/preset-react
```

```
# for yarn users
yarn upgrade @babel/core @babel/preset-react
```

Currently, the old transform `{"runtime": "classic"}` is the default option. To enable the new transform, you can pass `{"runtime": "automatic"}` as an option to `@babel/plugin-transform-react-jsx` or `@babel/preset-react`:

```
// If you are using @babel/preset-react
{
  "presets": [
    ["@babel/preset-react", {
      "runtime": "automatic"
    }]
  ]
}
```

```
// If you're using @babel/plugin-transform-react-jsx
{
  "plugins": [
    ["@babel/plugin-transform-react-jsx", {
      "runtime": "automatic"
    }]
  ]
}
```

Starting from Babel 8, `"automatic"` will be the default runtime for both plugins. For more information, check out the Babel documentation for [@babel/plugin-transform-react-jsx](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx) and [@babel/preset-react](https://babeljs.io/docs/en/babel-preset-react).

> Note
>
>
>
> If you use JSX with a library other than React, you can use [theimportSourceoption](https://babeljs.io/docs/en/babel-preset-react#importsource) to import from that library instead ‚Äî as long as it provides the necessary entry points. Alternatively, you can keep using the classic transform which will continue to be supported.
>
>
>
> If you‚Äôre a library author and you are implementing the `/jsx-runtime` entry point for your library, keep in mind that [there is a case](https://github.com/facebook/react/issues/20031#issuecomment-710346866) in which even the new transform has to fall back to `createElement` for backwards compatibility. In that case, it will auto-import `createElement` directly from the *root* entry point specified by `importSource`.

### ESLint

If you are using [eslint-plugin-react](https://github.com/yannickcr/eslint-plugin-react), the `react/jsx-uses-react` and `react/react-in-jsx-scope` rules are no longer necessary and can be turned off or removed.

```
{
  // ...
  "rules": {
    // ...
    "react/jsx-uses-react": "off",
    "react/react-in-jsx-scope": "off"
  }
}
```

### TypeScript

TypeScript supports the new JSX transform in [v4.1](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#jsx-factories) and up.

### Flow

Flow supports the new JSX transform in [v0.126.0](https://github.com/facebook/flow/releases/tag/v0.126.0) and up, by adding `react.runtime=automatic` to your Flow configuration options.

## Removing Unused React Imports

Because the new JSX transform will automatically import the necessary `react/jsx-runtime` functions, React will no longer need to be in scope when you use JSX. This might lead to unused React imports in your code. It doesn‚Äôt hurt to keep them, but if you‚Äôd like to remove them, we recommend running a [‚Äúcodemod‚Äù](https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb) script to remove them automatically:

```
cd your_project
npx react-codemod update-react-imports
```

> Note
>
>
>
> If you‚Äôre getting errors when running the codemod, try specifying a different JavaScript dialect when `npx react-codemod update-react-imports` asks you to choose one. In particular, at this moment the ‚ÄúJavaScript with Flow‚Äù setting supports newer syntax than the ‚ÄúJavaScript‚Äù setting even if you don‚Äôt use Flow. [File an issue](https://github.com/reactjs/react-codemod/issues) if you run into problems.
>
>
>
> Keep in mind that the codemod output will not always match your project‚Äôs coding style, so you might want to run [Prettier](https://prettier.io/) after the codemod finishes for consistent formatting.

Running this codemod will:

- Remove all unused React imports as a result of upgrading to the new JSX transform.
- Change all default React imports (i.e. `import React from "react"`) to destructured named imports (ex. `import { useState } from "react"`) which is the preferred style going into the future. This codemod **will not** affect the existing namespace imports (i.e. `import * as React from "react"`) which is also a valid style. The default imports will keep working in React 17, but in the longer term we encourage moving away from them.

For example,

```
import React from 'react';

function App() {
  return <h1>Hello World</h1>;
}
```

will be replaced with

```
function App() {
  return <h1>Hello World</h1>;
}
```

If you use some other import from React ‚Äî for example, a Hook ‚Äî then the codemod will convert it to a named import.

For example,

```
import React from 'react';

function App() {
  const [text, setText] = React.useState('Hello World');
  return <h1>{text}</h1>;
}
```

will be replaced with

```
import { useState } from 'react';

function App() {
  const [text, setText] = useState('Hello World');
  return <h1>{text}</h1>;
}
```

In addition to cleaning up unused imports, this will also help you prepare for a future major version of React (not React 17) which will support ES Modules and not have a default export.

## Thanks

We‚Äôd like to thank Babel, TypeScript, Create React App, Next.js, Gatsby, ESLint, and Flow maintainers for their help implementing and integrating the new JSX transform. We also want to thank the React community for their feedback and discussion on the related [technical RFC](https://github.com/reactjs/rfcs/pull/107).

Is this page useful?[Edit this page](https://github.com/reactjs/reactjs.org/tree/main/content/blog/2020-09-22-introducing-the-new-jsx-transform.md)
