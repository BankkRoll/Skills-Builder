# renderToReadableStream and more

# renderToReadableStream

[API Reference](https://react.dev/reference/react)[Server APIs](https://react.dev/reference/react-dom/server)

# renderToReadableStream

`renderToReadableStream` renders a React tree to a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

$

```
const stream = await renderToReadableStream(reactNode, options?)
```

/$

- [Reference](#reference)
  - [renderToReadableStream(reactNode, options?)](#rendertoreadablestream)
- [Usage](#usage)
  - [Rendering a React tree as HTML to a Readable Web Stream](#rendering-a-react-tree-as-html-to-a-readable-web-stream)
  - [Streaming more content as it loads](#streaming-more-content-as-it-loads)
  - [Specifying what goes into the shell](#specifying-what-goes-into-the-shell)
  - [Logging crashes on the server](#logging-crashes-on-the-server)
  - [Recovering from errors inside the shell](#recovering-from-errors-inside-the-shell)
  - [Recovering from errors outside the shell](#recovering-from-errors-outside-the-shell)
  - [Setting the status code](#setting-the-status-code)
  - [Handling different errors in different ways](#handling-different-errors-in-different-ways)
  - [Waiting for all content to load for crawlers and static generation](#waiting-for-all-content-to-load-for-crawlers-and-static-generation)
  - [Aborting server rendering](#aborting-server-rendering)

### Note

This API depends on [Web Streams.](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) For Node.js, use [renderToPipeableStream](https://react.dev/reference/react-dom/server/renderToPipeableStream) instead.

---

## Reference

### renderToReadableStream(reactNode, options?)

Call `renderToReadableStream` to render your React tree as HTML into a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

 $

```
import { renderToReadableStream } from 'react-dom/server';async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

/$

On the client, call [hydrateRoot](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](#usage)

#### Parameters

- `reactNode`: A React node you want to render to HTML. For example, a JSX element like `<App />`. It is expected to represent the entire document, so the `App` component should render the `<html>` tag.
- **optional** `options`: An object with streaming options.
  - **optional** `bootstrapScriptContent`: If specified, this string will be placed in an inline `<script>` tag.
  - **optional** `bootstrapScripts`: An array of string URLs for the `<script>` tags to emit on the page. Use this to include the `<script>` that calls [hydrateRoot.](https://react.dev/reference/react-dom/client/hydrateRoot) Omit it if you don‚Äôt want to run React on the client at all.
  - **optional** `bootstrapModules`: Like `bootstrapScripts`, but emits [<script type="module">](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) instead.
  - **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [useId.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to [hydrateRoot.](https://react.dev/reference/react-dom/client/hydrateRoot#parameters)
  - **optional** `namespaceURI`: A string with the root [namespace URI](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS#important_namespace_uris) for the stream. Defaults to regular HTML. Pass `'http://www.w3.org/2000/svg'` for SVG or `'http://www.w3.org/1998/Math/MathML'` for MathML.
  - **optional** `nonce`: A [nonce](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#nonce) string to allow scripts for [script-srcContent-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src).
  - **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](#recovering-from-errors-outside-the-shell) or [not.](#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](#logging-crashes-on-the-server) make sure that you still call `console.error`. You can also use it to [adjust the status code](#setting-the-status-code) before the shell is emitted.
  - **optional** `progressiveChunkSize`: The number of bytes in a chunk. [Read more about the default heuristic.](https://github.com/facebook/react/blob/14c2be8dac2d5482fda8a0906a31d239df8551fc/packages/react-server/src/ReactFizzServer.js#L210-L225)
  - **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort server rendering](#aborting-server-rendering) and render the rest on the client.

#### Returns

`renderToReadableStream` returns a Promise:

- If rendering the [shell](#specifying-what-goes-into-the-shell) is successful, that Promise will resolve to a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)
- If rendering the shell fails, the Promise will be rejected. [Use this to output a fallback shell.](#recovering-from-errors-inside-the-shell)

The returned stream has an additional property:

- `allReady`: A Promise that resolves when all rendering is complete, including both the [shell](#specifying-what-goes-into-the-shell) and all additional [content.](#streaming-more-content-as-it-loads) You can `await stream.allReady` before returning a response [for crawlers and static generation.](#waiting-for-all-content-to-load-for-crawlers-and-static-generation) If you do that, you won‚Äôt get any progressive loading. The stream will contain the final HTML.

---

## Usage

### Rendering a React tree as HTML to a Readable Web Stream

Call `renderToReadableStream` to render your React tree as HTML into a [Readable Web Stream:](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

 $

```
import { renderToReadableStream } from 'react-dom/server';async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

/$

Along with the root component, you need to provide a list of bootstrap `<script>` paths. Your root component should return **the entire document including the root<html>tag.**

For example, it might look like this:

 $

```
export default function App() {  return (    <html>      <head>        <meta charSet="utf-8" />        <meta name="viewport" content="width=device-width, initial-scale=1" />        <link rel="stylesheet" href="/styles.css"></link>        <title>My app</title>      </head>      <body>        <Router />      </body>    </html>  );}
```

/$

React will inject the [doctype](https://developer.mozilla.org/en-US/docs/Glossary/Doctype) and your bootstrap `<script>` tags into the resulting HTML stream:

 $

```
<!DOCTYPE html><html>  </html><script src="/main.js" async=""></script>
```

/$

On the client, your bootstrap script should [hydrate the entiredocumentwith a call tohydrateRoot:](https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-an-entire-document)

 $

```
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App />);
```

/$

This will attach event listeners to the server-generated HTML and make it interactive.

##### Deep Dive

#### Reading CSS and JS asset paths from the build output

The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of `styles.css` you might end up with `styles.123456.css`. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.

However, if you don‚Äôt know the asset URLs until after the build, there‚Äôs no way for you to put them in the source code. For example, hardcoding `"/styles.css"` into JSX like earlier wouldn‚Äôt work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:

$

```
export default function App({ assetMap }) {  return (    <html>      <head>        <title>My app</title>        <link rel="stylesheet" href={assetMap['styles.css']}></link>      </head>      ...    </html>  );}
```

/$

On the server, render `<App assetMap={assetMap} />` and pass your `assetMap` with the asset URLs:

$

```
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};async function handler(request) {  const stream = await renderToReadableStream(<App assetMap={assetMap} />, {    bootstrapScripts: [assetMap['/main.js']]  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

/$

Since your server is now rendering `<App assetMap={assetMap} />`, you need to render it with `assetMap` on the client too to avoid hydration errors. You can serialize and pass `assetMap` to the client like this:

$

```
// You'd need to get this JSON from your build tooling.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};async function handler(request) {  const stream = await renderToReadableStream(<App assetMap={assetMap} />, {    // Careful: It's safe to stringify() this because this data isn't user-generated.    bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,    bootstrapScripts: [assetMap['/main.js']],  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

/$

In the example above, the `bootstrapScriptContent` option adds an extra inline `<script>` tag that sets the global `window.assetMap` variable on the client. This lets the client code read the same `assetMap`:

$

```
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App assetMap={window.assetMap} />);
```

/$

Both client and server render `App` with the same `assetMap` prop, so there are no hydration errors.

---

### Streaming more content as it loads

Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

 $

```
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Posts />    </ProfileLayout>  );}
```

/$

Imagine that loading data for `<Posts />` takes some time. Ideally, you‚Äôd want to show the rest of the profile page content to the user without waiting for the posts. To do this, [wrapPostsin a<Suspense>boundary:](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading)

 $

```
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

/$

This tells React to start streaming the HTML before `Posts` loads its data. React will send the HTML for the loading fallback (`PostsGlimmer`) first, and then, when `Posts` finishes loading its data, React will send the remaining HTML along with an inline `<script>` tag that replaces the loading fallback with that HTML. From the user‚Äôs perspective, the page will first appear with the `PostsGlimmer`, later replaced by the `Posts`.

You can further [nest<Suspense>boundaries](https://react.dev/reference/react/Suspense#revealing-nested-content-as-it-loads) to create a more granular loading sequence:

 $

```
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
```

/$

In this example, React can start streaming the page even earlier. Only `ProfileLayout` and `ProfileCover` must finish rendering first because they are not wrapped in any `<Suspense>` boundary. However, if `Sidebar`, `Friends`, or `Photos` need to load some data, React will send the HTML for the `BigSpinner` fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.

Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the `<script>` tags load.

[Read more about how streaming HTML works.](https://github.com/reactwg/react-18/discussions/37)

### Note

**Only Suspense-enabled data sources will activate the Suspense component.** They include:

- Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/getting-started/react-essentials)
- Lazy-loading component code with [lazy](https://react.dev/reference/react/lazy)
- Reading the value of a Promise with [use](https://react.dev/reference/react/use)

Suspense **does not** detect when data is fetched inside an Effect or event handler.

The exact way you would load data in the `Posts` component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

---

### Specifying what goes into the shell

The part of your app outside of any `<Suspense>` boundaries is called *the shell:*

 $

```
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
```

/$

It determines the earliest loading state that the user may see:

 $

```
<ProfileLayout>  <ProfileCover />  <BigSpinner /></ProfileLayout>
```

/$

If you wrap the whole app into a `<Suspense>` boundary at the root, the shell will only contain that spinner. However, that‚Äôs not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you‚Äôll want to place the `<Suspense>` boundaries so that the shell feels *minimal but complete*‚Äîlike a skeleton of the entire page layout.

The async call to `renderToReadableStream` will resolve to a `stream` as soon as the entire shell has been rendered. Usually, you‚Äôll start streaming then by creating and returning a response with that `stream`:

 $

```
async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

/$

By the time the `stream` is returned, components in nested `<Suspense>` boundaries might still be loading data.

---

### Logging crashes on the server

By default, all errors on the server are logged to console. You can override this behavior to log crash reports:

 $

```
async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js'],    onError(error) {      console.error(error);      logServerCrashReport(error);    }  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

/$

If you provide a custom `onError` implementation, don‚Äôt forget to also log errors to the console like above.

---

### Recovering from errors inside the shell

In this example, the shell contains `ProfileLayout`, `ProfileCover`, and `PostsGlimmer`:

 $

```
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

/$

If an error occurs while rendering those components, React won‚Äôt have any meaningful HTML to send to the client. Wrap your `renderToReadableStream` call in a `try...catch` to send a fallback HTML that doesn‚Äôt rely on server rendering as the last resort:

 $

```
async function handler(request) {  try {    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
```

/$

If there is an error while generating the shell, both `onError` and your `catch` block will fire. Use `onError` for error reporting and use the `catch` block to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.

---

### Recovering from errors outside the shell

In this example, the `<Posts />` component is wrapped in `<Suspense>` so it is *not* a part of the shell:

 $

```
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

/$

If an error happens in the `Posts` component or somewhere inside it, React will [try to recover from it:](https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content)

1. It will emit the loading fallback for the closest `<Suspense>` boundary (`PostsGlimmer`) into the HTML.
2. It will ‚Äúgive up‚Äù on trying to render the `Posts` content on the server anymore.
3. When the JavaScript code loads on the client, React will *retry* rendering `Posts` on the client.

If retrying rendering `Posts` on the client *also* fails, React will throw the error on the client. As with all the errors thrown during rendering, the [closest parent error boundary](https://react.dev/reference/react/Component#static-getderivedstatefromerror) determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.

If retrying rendering `Posts` on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server `onError` callback and the client [onRecoverableError](https://react.dev/reference/react-dom/client/hydrateRoot#hydrateroot) callbacks will fire so that you can get notified about the error.

---

### Setting the status code

Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.

By [dividing your app](#specifying-what-goes-into-the-shell) into the shell (above all `<Suspense>` boundaries) and the rest of the content, you‚Äôve already solved a part of this problem. If the shell errors, your `catch` block will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send ‚ÄúOK‚Äù.

 $

```
async function handler(request) {  try {    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      status: 200,      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
```

/$

If a component *outside* the shell (i.e. inside a `<Suspense>` boundary) throws an error, React will not stop rendering. This means that the `onError` callback will fire, but your code will continue running without getting into the `catch` block. This is because React will try to recover from that error on the client, [as described above.](#recovering-from-errors-outside-the-shell)

However, if you‚Äôd like, you can use the fact that something has errored to set the status code:

 $

```
async function handler(request) {  try {    let didError = false;    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      status: didError ? 500 : 200,      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
```

/$

This will only catch errors outside the shell that happened while generating the initial shell content, so it‚Äôs not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.

---

### Handling different errors in different ways

You can [create your ownErrorsubclasses](https://javascript.info/custom-errors) and use the [instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) operator to check which error is thrown. For example, you can define a custom `NotFoundError` and throw it from your component. Then you can save the error in `onError` and do something different before returning the response depending on the error type:

 $

```
async function handler(request) {  let didError = false;  let caughtError = null;  function getStatusCode() {    if (didError) {      if (caughtError instanceof NotFoundError) {        return 404;      } else {        return 500;      }    } else {      return 200;    }  }  try {    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        caughtError = error;        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      status: getStatusCode(),      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: getStatusCode(),      headers: { 'content-type': 'text/html' },    });  }}
```

/$

Keep in mind that once you emit the shell and start streaming, you can‚Äôt change the status code.

---

### Waiting for all content to load for crawlers and static generation

Streaming offers a better user experience because the user can see the content as it becomes available.

However, when a crawler visits your page, or if you‚Äôre generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.

You can wait for all the content to load by awaiting the `stream.allReady` Promise:

 $

```
async function handler(request) {  try {    let didError = false;    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        console.error(error);        logServerCrashReport(error);      }    });    let isCrawler = // ... depends on your bot detection strategy ...    if (isCrawler) {      await stream.allReady;    }    return new Response(stream, {      status: didError ? 500 : 200,      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
```

/$

A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for *all* data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.

---

### Aborting server rendering

You can force the server rendering to ‚Äúgive up‚Äù after a timeout:

 $

```
async function handler(request) {  try {    const controller = new AbortController();    setTimeout(() => {      controller.abort();    }, 10000);    const stream = await renderToReadableStream(<App />, {      signal: controller.signal,      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        console.error(error);        logServerCrashReport(error);      }    });    // ...
```

/$

React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.

[PreviousrenderToPipeableStream](https://react.dev/reference/react-dom/server/renderToPipeableStream)[NextrenderToStaticMarkup](https://react.dev/reference/react-dom/server/renderToStaticMarkup)

---

# renderToStaticMarkup

[API Reference](https://react.dev/reference/react)[Server APIs](https://react.dev/reference/react-dom/server)

# renderToStaticMarkup

`renderToStaticMarkup` renders a non-interactive React tree to an HTML string.

$

```
const html = renderToStaticMarkup(reactNode, options?)
```

/$

- [Reference](#reference)
  - [renderToStaticMarkup(reactNode, options?)](#rendertostaticmarkup)
- [Usage](#usage)
  - [Rendering a non-interactive React tree as HTML to a string](#rendering-a-non-interactive-react-tree-as-html-to-a-string)

---

## Reference

### renderToStaticMarkup(reactNode, options?)

On the server, call `renderToStaticMarkup` to render your app to HTML.

 $

```
import { renderToStaticMarkup } from 'react-dom/server';const html = renderToStaticMarkup(<Page />);
```

/$

It will produce non-interactive HTML output of your React components.

[See more examples below.](#usage)

#### Parameters

- `reactNode`: A React node you want to render to HTML. For example, a JSX node like `<Page />`.
- **optional** `options`: An object for server render.
  - **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [useId.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page.

#### Returns

An HTML string.

#### Caveats

- `renderToStaticMarkup` output cannot be hydrated.
- `renderToStaticMarkup` has limited Suspense support. If a component suspends, `renderToStaticMarkup` immediately sends its fallback as HTML.
- `renderToStaticMarkup` works in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser, [get the HTML by rendering it into a DOM node.](https://react.dev/reference/react-dom/server/renderToString#removing-rendertostring-from-the-client-code)

---

## Usage

### Rendering a non-interactive React tree as HTML to a string

Call `renderToStaticMarkup` to render your app to an HTML string which you can send with your server response:

 $

```
import { renderToStaticMarkup } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const html = renderToStaticMarkup(<Page />);  response.send(html);});
```

/$

This will produce the initial non-interactive HTML output of your React components.

### Pitfall

This method renders **non-interactive HTML that cannot be hydrated.**  This is useful if you want to use React as a simple static page generator, or if you‚Äôre rendering completely static content like emails.

Interactive apps should use [renderToString](https://react.dev/reference/react-dom/server/renderToString) on the server and [hydrateRoot](https://react.dev/reference/react-dom/client/hydrateRoot) on the client.

[PreviousrenderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream)[NextrenderToString](https://react.dev/reference/react-dom/server/renderToString)

---

# renderToStaticNodeStream

[API Reference](https://react.dev/reference/react)[Server APIs](https://react.dev/reference/react-dom/server)

# renderToStaticNodeStream

`renderToStaticNodeStream` renders a non-interactive React tree to a [Node.js Readable Stream.](https://nodejs.org/api/stream.html#readable-streams)

$

```
const stream = renderToStaticNodeStream(reactNode, options?)
```

/$

- [Reference](#reference)
  - [renderToStaticNodeStream(reactNode, options?)](#rendertostaticnodestream)
- [Usage](#usage)
  - [Rendering a React tree as static HTML to a Node.js Readable Stream](#rendering-a-react-tree-as-static-html-to-a-nodejs-readable-stream)

---

## Reference

### renderToStaticNodeStream(reactNode, options?)

On the server, call `renderToStaticNodeStream` to get a [Node.js Readable Stream](https://nodejs.org/api/stream.html#readable-streams).

 $

```
import { renderToStaticNodeStream } from 'react-dom/server';const stream = renderToStaticNodeStream(<Page />);stream.pipe(response);
```

/$

[See more examples below.](#usage)

The stream will produce non-interactive HTML output of your React components.

#### Parameters

- `reactNode`: A React node you want to render to HTML. For example, a JSX element like `<Page />`.
- **optional** `options`: An object for server render.
  - **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [useId.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page.

#### Returns

A [Node.js Readable Stream](https://nodejs.org/api/stream.html#readable-streams) that outputs an HTML string. The resulting HTML can‚Äôt be hydrated on the client.

#### Caveats

- `renderToStaticNodeStream` output cannot be hydrated.
- This method will wait for all [Suspense boundaries](https://react.dev/reference/react/Suspense) to complete before returning any output.
- As of React 18, this method buffers all of its output, so it doesn‚Äôt actually provide any streaming benefits.
- The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like [iconv-lite](https://www.npmjs.com/package/iconv-lite), which provides transform streams for transcoding text.

---

## Usage

### Rendering a React tree as static HTML to a Node.js Readable Stream

Call `renderToStaticNodeStream` to get a [Node.js Readable Stream](https://nodejs.org/api/stream.html#readable-streams) which you can pipe to your server response:

 $

```
import { renderToStaticNodeStream } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const stream = renderToStaticNodeStream(<Page />);  stream.pipe(response);});
```

/$

The stream will produce the initial non-interactive HTML output of your React components.

### Pitfall

This method renders **non-interactive HTML that cannot be hydrated.** This is useful if you want to use React as a simple static page generator, or if you‚Äôre rendering completely static content like emails.

Interactive apps should use [renderToPipeableStream](https://react.dev/reference/react-dom/server/renderToPipeableStream) on the server and [hydrateRoot](https://react.dev/reference/react-dom/client/hydrateRoot) on the client.

[PreviousrenderToStaticMarkup](https://react.dev/reference/react-dom/server/renderToStaticMarkup)[NextrenderToString](https://react.dev/reference/react-dom/server/renderToString)

---

# renderToString

[API Reference](https://react.dev/reference/react)[Server APIs](https://react.dev/reference/react-dom/server)

# renderToString

### Pitfall

`renderToString` does not support streaming or waiting for data. [See the alternatives.](#alternatives)

`renderToString` renders a React tree to an HTML string.

$

```
const html = renderToString(reactNode, options?)
```

/$

- [Reference](#reference)
  - [renderToString(reactNode, options?)](#rendertostring)
- [Usage](#usage)
  - [Rendering a React tree as HTML to a string](#rendering-a-react-tree-as-html-to-a-string)
- [Alternatives](#alternatives)
  - [Migrating fromrenderToStringto a streaming render on the server](#migrating-from-rendertostring-to-a-streaming-method-on-the-server)
  - [Migrating fromrenderToStringto a static prerender on the server](#migrating-from-rendertostring-to-a-static-prerender-on-the-server)
  - [RemovingrenderToStringfrom the client code](#removing-rendertostring-from-the-client-code)
- [Troubleshooting](#troubleshooting)
  - [When a component suspends, the HTML always contains a fallback](#when-a-component-suspends-the-html-always-contains-a-fallback)

---

## Reference

### renderToString(reactNode, options?)

On the server, call `renderToString` to render your app to HTML.

 $

```
import { renderToString } from 'react-dom/server';const html = renderToString(<App />);
```

/$

On the client, call [hydrateRoot](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](#usage)

#### Parameters

- `reactNode`: A React node you want to render to HTML. For example, a JSX node like `<App />`.
- **optional** `options`: An object for server render.
  - **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [useId.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to [hydrateRoot.](https://react.dev/reference/react-dom/client/hydrateRoot#parameters)

#### Returns

An HTML string.

#### Caveats

- `renderToString` has limited Suspense support. If a component suspends, `renderToString` immediately sends its fallback as HTML.
- `renderToString` works in the browser, but using it in the client code is [not recommended.](#removing-rendertostring-from-the-client-code)

---

## Usage

### Rendering a React tree as HTML to a string

Call `renderToString` to render your app to an HTML string which you can send with your server response:

 $

```
import { renderToString } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const html = renderToString(<App />);  response.send(html);});
```

/$

This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call [hydrateRoot](https://react.dev/reference/react-dom/client/hydrateRoot) to *hydrate* that server-generated HTML and make it interactive.

### Pitfall

`renderToString` does not support streaming or waiting for data. [See the alternatives.](#alternatives)

---

## Alternatives

### Migrating fromrenderToStringto a streaming render on the server

`renderToString` returns a string immediately, so it does not support streaming content as it loads.

When possible, we recommend using these fully-featured alternatives:

- If you use Node.js, use [renderToPipeableStream.](https://react.dev/reference/react-dom/server/renderToPipeableStream)
- If you use Deno or a modern edge runtime with [Web Streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API), use [renderToReadableStream.](https://react.dev/reference/react-dom/server/renderToReadableStream)

You can continue using `renderToString` if your server environment does not support streams.

---

### Migrating fromrenderToStringto a static prerender on the server

`renderToString` returns a string immediately, so it does not support waiting for data to load for static HTML generation.

We recommend using these fully-featured alternatives:

- If you use Node.js, use [prerenderToNodeStream.](https://react.dev/reference/react-dom/static/prerenderToNodeStream)
- If you use Deno or a modern edge runtime with [Web Streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API), use [prerender.](https://react.dev/reference/react-dom/static/prerender)

You can continue using `renderToString` if your static site generation environment does not support streams.

---

### RemovingrenderToStringfrom the client code

Sometimes, `renderToString` is used on the client to convert some component to HTML.

 $

```
// üö© Unnecessary: using renderToString on the clientimport { renderToString } from 'react-dom/server';const html = renderToString(<MyIcon />);console.log(html); // For example, "<svg>...</svg>"
```

/$

Importing `react-dom/server` **on the client** unnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, use [createRoot](https://react.dev/reference/react-dom/client/createRoot) and read HTML from the DOM:

 $

```
import { createRoot } from 'react-dom/client';import { flushSync } from 'react-dom';const div = document.createElement('div');const root = createRoot(div);flushSync(() => {  root.render(<MyIcon />);});console.log(div.innerHTML); // For example, "<svg>...</svg>"
```

/$

The [flushSync](https://react.dev/reference/react-dom/flushSync) call is necessary so that the DOM is updated before reading its [innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) property.

---

## Troubleshooting

### When a component suspends, the HTML always contains a fallback

`renderToString` does not fully support Suspense.

If some component suspends (for example, because it‚Äôs defined with [lazy](https://react.dev/reference/react/lazy) or fetches data), `renderToString` will not wait for its content to resolve. Instead, `renderToString` will find the closest [<Suspense>](https://react.dev/reference/react/Suspense) boundary above it and render its `fallback` prop in the HTML. The content will not appear until the client code loads.

To solve this, use one of the [recommended streaming solutions.](#alternatives) For server side rendering, they can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads. For static site generation, they can wait for all the content to resolve before generating the static HTML.

[PreviousrenderToStaticMarkup](https://react.dev/reference/react-dom/server/renderToStaticMarkup)[Nextresume](https://react.dev/reference/react-dom/server/resume)

---

# resume

[API Reference](https://react.dev/reference/react)[Server APIs](https://react.dev/reference/react-dom/server)

# resume

`resume` streams a pre-rendered React tree to a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

$

```
const stream = await resume(reactNode, postponedState, options?)
```

/$

- [Reference](#reference)
  - [resume(node, postponedState, options?)](#resume)
- [Usage](#usage)
  - [Resuming a prerender](#resuming-a-prerender)
  - [Further reading](#further-reading)

### Note

This API depends on [Web Streams.](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) For Node.js, use [resumeToNodeStream](https://react.dev/reference/react-dom/server/renderToPipeableStream) instead.

---

## Reference

### resume(node, postponedState, options?)

Call `resume` to resume rendering a pre-rendered React tree as HTML into a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

 $

```
import { resume } from 'react-dom/server';import {getPostponedState} from './storage';async function handler(request, writable) {  const postponed = await getPostponedState(request);  const resumeStream = await resume(<App />, postponed);  return resumeStream.pipeTo(writable)}
```

/$

[See more examples below.](#usage)

#### Parameters

- `reactNode`: The React node you called `prerender` with. For example, a JSX element like `<App />`. It is expected to represent the entire document, so the `App` component should render the `<html>` tag.
- `postponedState`: The opaque `postpone` object returned from a [prerender API](https://react.dev/reference/react-dom/static/index), loaded from wherever you stored it (e.g. redis, a file, or S3).
- **optional** `options`: An object with streaming options.
  - **optional** `nonce`: A [nonce](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#nonce) string to allow scripts for [script-srcContent-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src).
  - **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort server rendering](#aborting-server-rendering) and render the rest on the client.
  - **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/server/renderToReadableStream#logging-crashes-on-the-server) make sure that you still call `console.error`.

#### Returns

`resume` returns a Promise:

- If `resume` successfully produced a [shell](https://react.dev/reference/react-dom/server/renderToReadableStream#specifying-what-goes-into-the-shell), that Promise will resolve to a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) that can be piped to a [Writable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream).
- If an error happens in the shell, the Promise will reject with that error.

The returned stream has an additional property:

- `allReady`: A Promise that resolves when all rendering is complete. You can `await stream.allReady` before returning a response [for crawlers and static generation.](https://react.dev/reference/react-dom/server/renderToReadableStream#waiting-for-all-content-to-load-for-crawlers-and-static-generation) If you do that, you won‚Äôt get any progressive loading. The stream will contain the final HTML.

#### Caveats

- `resume` does not accept options for `bootstrapScripts`, `bootstrapScriptContent`, or `bootstrapModules`. Instead, you need to pass these options to the `prerender` call that generates the `postponedState`. You can also inject bootstrap content into the writable stream manually.
- `resume` does not accept `identifierPrefix` since the prefix needs to be the same in both `prerender` and `resume`.
- Since `nonce` cannot be provided to prerender, you should only provide `nonce` to `resume` if you‚Äôre not providing scripts to prerender.
- `resume` re-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.

## Usage

### Resuming a prerender

 $[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app)

```
import {
  flushReadableStreamToFrame,
  getUser,
  Postponed,
  sleep,
} from "./demo-helpers";
import { StrictMode, Suspense, use, useEffect } from "react";
import { prerender } from "react-dom/static";
import { resume } from "react-dom/server";
import { hydrateRoot } from "react-dom/client";

function Header() {
  return <header>Me and my descendants can be prerendered</header>;
}

const { promise: cookies, resolve: resolveCookies } = Promise.withResolvers();

function Main() {
  const { sessionID } = use(cookies);
  const user = getUser(sessionID);

  useEffect(() => {
    console.log("reached interactivity!");
  }, []);

  return (
    <main>
      Hello, {user.name}!
      <button onClick={() => console.log("hydrated!")}>
        Clicking me requires hydration.
      </button>
    </main>
  );
}

function Shell({ children }) {
  // In a real app, this is where you would put your html and body.
  // We're just using tags here we can include in an existing body for demonstration purposes
  return (
    <html>
      <body>{children}</body>
    </html>
  );
}

function App() {
  return (
    <Shell>
      <Suspense fallback="loading header">
        <Header />
      </Suspense>
      <Suspense fallback="loading main">
        <Main />
      </Suspense>
    </Shell>
  );
}

async function main(frame) {
  // Layer 1
  const controller = new AbortController();
  const prerenderedApp = prerender(<App />, {
    signal: controller.signal,
    onError(error) {
      if (error instanceof Postponed) {
      } else {
        console.error(error);
      }
    },
  });
  // We're immediately aborting in a macrotask.
  // Any data fetching that's not available synchronously, or in a microtask, will not have finished.
  setTimeout(() => {
    controller.abort(new Postponed());
  });

  const { prelude, postponed } = await prerenderedApp;
  await flushReadableStreamToFrame(prelude, frame);

  // Layer 2
  // Just waiting here for demonstration purposes.
  // In a real app, the prelude and postponed state would've been serialized in Layer 1 and Layer would deserialize them.
  // The prelude content could be flushed immediated as plain HTML while
  // React is continuing to render from where the prerender left off.
  await sleep(2000);

  // You would get the cookies from the incoming HTTP request
  resolveCookies({ sessionID: "abc" });

  const stream = await resume(<App />, postponed);

  await flushReadableStreamToFrame(stream, frame);

  // Layer 3
  // Just waiting here for demonstration purposes.
  await sleep(2000);

  hydrateRoot(frame.contentWindow.document, <App />);
}

main(document.getElementById("container"));
```

/$

### Further reading

Resuming behaves like `renderToReadableStream`. For more examples, check out the [usage section ofrenderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream#usage).
The [usage section ofprerender](https://react.dev/reference/react-dom/static/prerender#usage) includes examples of how to use `prerender` specifically.

[PreviousrenderToString](https://react.dev/reference/react-dom/server/renderToString)[NextresumeToPipeableStream](https://react.dev/reference/react-dom/server/resumeToPipeableStream)

---

# resumeToPipeableStream

[API Reference](https://react.dev/reference/react)[Server APIs](https://react.dev/reference/react-dom/server)

# resumeToPipeableStream

`resumeToPipeableStream` streams a pre-rendered React tree  to a pipeable [Node.js Stream.](https://nodejs.org/api/stream.html)

$

```
const {pipe, abort} = await resumeToPipeableStream(reactNode, postponedState, options?)
```

/$

- [Reference](#reference)
  - [resumeToPipeableStream(node, postponed, options?)](#resume-to-pipeable-stream)
- [Usage](#usage)
  - [Further reading](#further-reading)

### Note

This API is specific to Node.js. Environments with [Web Streams,](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) like Deno and modern edge runtimes, should use [resume](https://react.dev/reference/react-dom/server/renderToReadableStream) instead.

---

## Reference

### resumeToPipeableStream(node, postponed, options?)

Call `resume` to resume rendering a pre-rendered React tree as HTML into a [Node.js Stream.](https://nodejs.org/api/stream.html#writable-streams)

 $

```
import { resume } from 'react-dom/server';import {getPostponedState} from './storage';async function handler(request, response) {  const postponed = await getPostponedState(request);  const {pipe} = resumeToPipeableStream(<App />, postponed, {    onShellReady: () => {      pipe(response);    }  });}
```

/$

[See more examples below.](#usage)

#### Parameters

- `reactNode`: The React node you called `prerender` with. For example, a JSX element like `<App />`. It is expected to represent the entire document, so the `App` component should render the `<html>` tag.
- `postponedState`: The opaque `postpone` object returned from a [prerender API](https://react.dev/reference/react-dom/static/index), loaded from wherever you stored it (e.g. redis, a file, or S3).
- **optional** `options`: An object with streaming options.
  - **optional** `nonce`: A [nonce](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#nonce) string to allow scripts for [script-srcContent-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src).
  - **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort server rendering](#aborting-server-rendering) and render the rest on the client.
  - **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/server/renderToReadableStream#logging-crashes-on-the-server) make sure that you still call `console.error`.
  - **optional** `onShellReady`: A callback that fires right after the [shell](#specifying-what-goes-into-the-shell) has finished. You can call `pipe` here to start streaming. React will [stream the additional content](#streaming-more-content-as-it-loads) after the shell along with the inline `<script>` tags that replace the HTML loading fallbacks with the content.
  - **optional** `onShellError`: A callback that fires if there was an error rendering the shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neither `onShellReady` nor `onAllReady` will get called, so you can [output a fallback HTML shell](#recovering-from-errors-inside-the-shell) or use the prelude.

#### Returns

`resume` returns an object with two methods:

- `pipe` outputs the HTML into the provided [Writable Node.js Stream.](https://nodejs.org/api/stream.html#writable-streams) Call `pipe` in `onShellReady` if you want to enable streaming, or in `onAllReady` for crawlers and static generation.
- `abort` lets you [abort server rendering](#aborting-server-rendering) and render the rest on the client.

#### Caveats

- `resumeToPipeableStream` does not accept options for `bootstrapScripts`, `bootstrapScriptContent`, or `bootstrapModules`. Instead, you need to pass these options to the `prerender` call that generates the `postponedState`. You can also inject bootstrap content into the writable stream manually.
- `resumeToPipeableStream` does not accept `identifierPrefix` since the prefix needs to be the same in both `prerender` and `resumeToPipeableStream`.
- Since `nonce` cannot be provided to prerender, you should only provide `nonce` to `resumeToPipeableStream` if you‚Äôre not providing scripts to prerender.
- `resumeToPipeableStream` re-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.

## Usage

### Further reading

Resuming behaves like `renderToReadableStream`. For more examples, check out the [usage section ofrenderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream#usage).
The [usage section ofprerender](https://react.dev/reference/react-dom/static/prerender#usage) includes examples of how to use `prerenderToNodeStream` specifically.

[Previousresume](https://react.dev/reference/react-dom/server/resume)[NextStatic APIs](https://react.dev/reference/react-dom/static)
