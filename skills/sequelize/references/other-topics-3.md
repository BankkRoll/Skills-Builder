# Naming Strategies and more

# Naming Strategies

> The underscored option

Version: v6 - stable

## Theunderscoredoption​

Sequelize provides the `underscored` option for a model. When `true`, this option will set the `field` option on all attributes to the [snake_case](https://en.wikipedia.org/wiki/Snake_case) version of its name. This also applies to foreign keys automatically generated by associations and other automatically generated fields. Example:

```
const User = sequelize.define(  'user',  { username: Sequelize.STRING },  {    underscored: true,  },);const Task = sequelize.define(  'task',  { title: Sequelize.STRING },  {    underscored: true,  },);User.hasMany(Task);Task.belongsTo(User);
```

Above we have the models User and Task, both using the `underscored` option. We also have a One-to-Many relationship between them. Also, recall that since `timestamps` is true by default, we should expect the `createdAt` and `updatedAt` fields to be automatically created as well.

Without the `underscored` option, Sequelize would automatically define:

- A `createdAt` attribute for each model, pointing to a column named `createdAt` in each table
- An `updatedAt` attribute for each model, pointing to a column named `updatedAt` in each table
- A `userId` attribute in the `Task` model, pointing to a column named `userId` in the task table

With the `underscored` option enabled, Sequelize will instead define:

- A `createdAt` attribute for each model, pointing to a column named `created_at` in each table
- An `updatedAt` attribute for each model, pointing to a column named `updated_at` in each table
- A `userId` attribute in the `Task` model, pointing to a column named `user_id` in the task table

Note that in both cases the fields are still [camelCase](https://en.wikipedia.org/wiki/Camel_case) in the JavaScript side; this option only changes how these fields are mapped to the database itself. The `field` option of every attribute is set to their snake_case version, but the attribute itself remains camelCase.

This way, calling `sync()` on the above code will generate the following:

```
CREATE TABLE IF NOT EXISTS "users" (  "id" SERIAL,  "username" VARCHAR(255),  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL,  "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL,  PRIMARY KEY ("id"));CREATE TABLE IF NOT EXISTS "tasks" (  "id" SERIAL,  "title" VARCHAR(255),  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL,  "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL,  "user_id" INTEGER REFERENCES "users" ("id") ON DELETE SET NULL ON UPDATE CASCADE,  PRIMARY KEY ("id"));
```

## Singular vs. Plural​

At a first glance, it can be confusing whether the singular form or plural form of a name shall be used around in Sequelize. This section aims at clarifying that a bit.

Recall that Sequelize uses a library called [inflection](https://www.npmjs.com/package/inflection) under the hood, so that irregular plurals (such as `person -> people`) are computed correctly. However, if you're working in another language, you may want to define the singular and plural forms of names directly; sequelize allows you to do this with some options.

### When defining models​

Models should be defined with the singular form of a word. Example:

```
sequelize.define('foo', { name: DataTypes.STRING });
```

Above, the model name is `foo` (singular), and the respective table name is `foos`, since Sequelize automatically gets the plural for the table name.

### When defining a reference key in a model​

```
sequelize.define('foo', {  name: DataTypes.STRING,  barId: {    type: DataTypes.INTEGER,    allowNull: false,    references: {      model: 'bars',      key: 'id',    },    onDelete: 'CASCADE',  },});
```

In the above example we are manually defining a key that references another model. It's not usual to do this, but if you have to, you should use the table name there. This is because the reference is created upon the referenced table name. In the example above, the plural form was used (`bars`), assuming that the `bar` model was created with the default settings (making its underlying table automatically pluralized).

### When retrieving data from eager loading​

When you perform an `include` in a query, the included data will be added to an extra field in the returned objects, according to the following rules:

- When including something from a single association (`hasOne` or `belongsTo`) - the field name will be the singular version of the model name;
- When including something from a multiple association (`hasMany` or `belongsToMany`) - the field name will be the plural form of the model.

In short, the name of the field will take the most logical form in each situation.

Examples:

```
// Assuming Foo.hasMany(Bar)const foo = Foo.findOne({ include: Bar });// foo.bars will be an array// foo.bar will not exist since it doens't make sense// Assuming Foo.hasOne(Bar)const foo = Foo.findOne({ include: Bar });// foo.bar will be an object (possibly null if there is no associated model)// foo.bars will not exist since it doens't make sense// And so on.
```

### Overriding singulars and plurals when defining aliases​

When defining an alias for an association, instead of using simply `{ as: 'myAlias' }`, you can pass an object to specify the singular and plural forms:

```
Project.belongsToMany(User, {  as: {    singular: 'líder',    plural: 'líderes',  },});
```

If you know that a model will always use the same alias in associations, you can provide the singular and plural forms directly to the model itself:

```
const User = sequelize.define(  'user',  {    /* ... */  },  {    name: {      singular: 'líder',      plural: 'líderes',    },  },);Project.belongsToMany(User);
```

The mixins added to the user instances will use the correct forms. For example, instead of `project.addUser()`, Sequelize will provide `project.getLíder()`. Also, instead of `project.setUsers()`, Sequelize will provide `project.setLíderes()`.

Note: recall that using `as` to change the name of the association will also change the name of the foreign key. Therefore it is recommended to also specify the foreign key(s) involved directly in this case.

```
// Example of possible mistakeInvoice.belongsTo(Subscription, { as: 'TheSubscription' });Subscription.hasMany(Invoice);
```

The first call above will establish a foreign key called `theSubscriptionId` on `Invoice`. However, the second call will also establish a foreign key on `Invoice` (since as we know, `hasMany` calls places foreign keys in the target model) - however, it will be named `subscriptionId`. This way you will have both `subscriptionId` and `theSubscriptionId` columns.

The best approach is to choose a name for the foreign key and place it explicitly in both calls. For example, if `subscription_id` was chosen:

```
// Fixed exampleInvoice.belongsTo(Subscription, {  as: 'TheSubscription',  foreignKey: 'subscription_id',});Subscription.hasMany(Invoice, { foreignKey: 'subscription_id' });
```

---

# Optimistic Locking

> Sequelize has built-in support for optimistic locking through a model instance version count.

Version: v6 - stable

Sequelize has built-in support for optimistic locking through a model instance version count.

Optimistic locking is disabled by default and can be enabled by setting the `version` property to true in a specific model definition or global model configuration. See [model configuration](https://sequelize.org/docs/v6/core-concepts/model-basics/) for more details.

Optimistic locking allows concurrent access to model records for edits and prevents conflicts from overwriting data. It does this by checking whether another process has made changes to a record since it was read and throws an OptimisticLockError when a conflict is detected.

---

# Other Data Types

> Apart from the most common data types mentioned in the Model Basics guide, Sequelize provides several other data types.

Version: v6 - stable

Apart from the most common data types mentioned in the Model Basics guide, Sequelize provides several other data types.

## Ranges (PostgreSQL only)​

```
DataTypes.RANGE(DataTypes.INTEGER); // int4rangeDataTypes.RANGE(DataTypes.BIGINT); // int8rangeDataTypes.RANGE(DataTypes.DATE); // tstzrangeDataTypes.RANGE(DataTypes.DATEONLY); // daterangeDataTypes.RANGE(DataTypes.DECIMAL); // numrange
```

Since range types have extra information for their bound inclusion/exclusion it's not very straightforward to just use a tuple to represent them in javascript.

When supplying ranges as values you can choose from the following APIs:

```
// defaults to inclusive lower bound, exclusive upper boundconst range = [new Date(Date.UTC(2016, 0, 1)), new Date(Date.UTC(2016, 1, 1))];// '["2016-01-01 00:00:00+00:00", "2016-02-01 00:00:00+00:00")'// control inclusionconst range = [  { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false },  { value: new Date(Date.UTC(2016, 1, 1)), inclusive: true },];// '("2016-01-01 00:00:00+00:00", "2016-02-01 00:00:00+00:00"]'// composite formconst range = [  { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false },  new Date(Date.UTC(2016, 1, 1)),];// '("2016-01-01 00:00:00+00:00", "2016-02-01 00:00:00+00:00")'const Timeline = sequelize.define('Timeline', {  range: DataTypes.RANGE(DataTypes.DATE),});await Timeline.create({ range });
```

However, retrieved range values always come in the form of an array of objects. For example, if the stored value is `("2016-01-01 00:00:00+00:00", "2016-02-01 00:00:00+00:00"]`, after a finder query you will get:

```
[  { value: Date, inclusive: false },  { value: Date, inclusive: true },];
```

You will need to call `reload()` after updating an instance with a range type or use the `returning: true` option.

### Special Cases​

```
// empty range:Timeline.create({ range: [] }); // range = 'empty'// Unbounded range:Timeline.create({ range: [null, null] }); // range = '[,)'// range = '[,"2016-01-01 00:00:00+00:00")'Timeline.create({ range: [null, new Date(Date.UTC(2016, 0, 1))] });// Infinite range:// range = '[-infinity,"2016-01-01 00:00:00+00:00")'Timeline.create({ range: [-Infinity, new Date(Date.UTC(2016, 0, 1))] });
```

## Network Addresses​

 AllPostgreSQLMariaDBMySQLMSSQLSQLiteSnowflakedb2ibmi

| Sequelize DataType | PostgreSQL | MariaDB | MySQL | MSSQL | SQLite | Snowflake | db2 | ibmi | Oracle Database |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| CIDR | CIDR | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| INET | INET | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| MACADDR | MACADDR | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |

## Arrays (PostgreSQL only)​

```
// Defines an array of DataTypes.SOMETHING.DataTypes.ARRAY(/* DataTypes.SOMETHING */);// For example// VARCHAR(255)[]DataTypes.ARRAY(DataTypes.STRING);// VARCHAR(255)[][]DataTypes.ARRAY(DataTypes.ARRAY(DataTypes.STRING));
```

## BLOBs​

```
DataTypes.BLOB; // BLOB (bytea for PostgreSQL)DataTypes.BLOB('tiny'); // TINYBLOB (bytea for PostgreSQL)DataTypes.BLOB('medium'); // MEDIUMBLOB (bytea for PostgreSQL)DataTypes.BLOB('long'); // LONGBLOB (bytea for PostgreSQL)
```

The blob datatype allows you to insert data both as strings and as buffers. However, when a blob is retrieved from database with Sequelize, it will always be retrieved as a buffer.

## ENUMs​

The ENUM is a data type that accepts only a few values, specified as a list.

```
DataTypes.ENUM('foo', 'bar'); // An ENUM with allowed values 'foo' and 'bar'
```

ENUMs can also be specified with the `values` field of the column definition, as follows:

```
sequelize.define('foo', {  states: {    type: DataTypes.ENUM,    values: ['active', 'pending', 'deleted'],  },});
```

## JSON (SQLite, MySQL, MariaDB, Oracle and PostgreSQL only)​

The `DataTypes.JSON` data type is only supported for SQLite, MySQL, MariaDB, Oracle and PostgreSQL. However, there is a minimum support for MSSQL (see below).

### Note for PostgreSQL​

The JSON data type in PostgreSQL stores the value as plain text, as opposed to binary representation. If you simply want to store and retrieve a JSON representation, using JSON will take less disk space and less time to build from its input representation. However, if you want to do any operations on the JSON value, you should prefer the JSONB data type described below.

### JSONB (PostgreSQL only)​

PostgreSQL also supports a JSONB data type: `DataTypes.JSONB`. It can be queried in three different ways:

```
// Nested objectawait Foo.findOne({  where: {    meta: {      video: {        url: {          [Op.ne]: null,        },      },    },  },});// Nested keyawait Foo.findOne({  where: {    'meta.audio.length': {      [Op.gt]: 20,    },  },});// Containmentawait Foo.findOne({  where: {    meta: {      [Op.contains]: {        site: {          url: 'https://google.com',        },      },    },  },});
```

### MSSQL​

MSSQL does not have a JSON data type, however it does provide some support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed separately.

```
// ISJSON - to test if a string contains valid JSONawait User.findAll({  where: sequelize.where(sequelize.fn('ISJSON', sequelize.col('userDetails')), 1),});// JSON_VALUE - extract a scalar value from a JSON stringawait User.findAll({  attributes: [    [sequelize.fn('JSON_VALUE', sequelize.col('userDetails'), '$.address.Line1'), 'address line 1'],  ],});// JSON_VALUE - query a scalar value from a JSON stringawait User.findAll({  where: sequelize.where(    sequelize.fn('JSON_VALUE', sequelize.col('userDetails'), '$.address.Line1'),    '14, Foo Street',  ),});// JSON_QUERY - extract an object or arrayawait User.findAll({  attributes: [    [sequelize.fn('JSON_QUERY', sequelize.col('userDetails'), '$.address'), 'full address'],  ],});
```

## Miscellaneous DataTypes​

 AllPostgreSQLMariaDBMySQLMSSQLSQLiteSnowflakedb2ibmi

| Sequelize DataType | PostgreSQL | MariaDB | MySQL | MSSQL | SQLite | Snowflake | db2 | ibmi | Oracle Database |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| GEOMETRY | GEOMETRY | GEOMETRY | GEOMETRY | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| GEOMETRY('POINT') | GEOMETRY(POINT) | POINT | POINT | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| GEOMETRY('POINT', 4326) | GEOMETRY(POINT,4326) | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| GEOMETRY('POLYGON') | GEOMETRY(POLYGON) | POLYGON | POLYGON | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| GEOMETRY('LINESTRING') | GEOMETRY(LINESTRING) | LINESTRING | LINESTRING | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| GEOGRAPHY | GEOGRAPHY | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| HSTORE | HSTORE | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |

 note

In Postgres, the GEOMETRY and GEOGRAPHY types are implemented by [the PostGIS extension](https://postgis.net/workshops/postgis-intro/geometries.html).

In Postgres, You must install the [pg-hstore](https://www.npmjs.com/package/pg-hstore) package if you use `DataTypes.HSTORE`

---

# Query Interface

> An instance of Sequelize uses something called Query Interface to communicate to the database in a dialect-agnostic way. Most of the methods you've learned in this manual are implemented with the help of several methods from the query interface.

Version: v6 - stable

An instance of Sequelize uses something called **Query Interface** to communicate to the database in a dialect-agnostic way. Most of the methods you've learned in this manual are implemented with the help of several methods from the query interface.

The methods from the query interface are therefore lower-level methods; you should use them only if you do not find another way to do it with higher-level APIs from Sequelize. They are, of course, still higher-level than running raw queries directly (i.e., writing SQL by hand).

This guide shows a few examples, but for the full list of what it can do, and for detailed usage of each method, check the [QueryInterface API](https://sequelize.org/api/v6/class/src/dialects/abstract/query-interface.js~queryinterface).

## Obtaining the query interface​

From now on, we will call `queryInterface` the singleton instance of the [QueryInterface](https://sequelize.org/api/v6/class/src/dialects/abstract/query-interface.js~queryinterface) class, which is available on your Sequelize instance:

```
const { Sequelize, DataTypes } = require('sequelize');const sequelize = new Sequelize(/* ... */);const queryInterface = sequelize.getQueryInterface();
```

## Creating a table​

```
queryInterface.createTable('Person', {  name: DataTypes.STRING,  isBetaMember: {    type: DataTypes.BOOLEAN,    defaultValue: false,    allowNull: false,  },});
```

Generated SQL (using SQLite):

```
CREATE TABLE IF NOT EXISTS `Person` (  `name` VARCHAR(255),  `isBetaMember` TINYINT(1) NOT NULL DEFAULT 0);
```

**Note:** Consider defining a Model instead and calling `YourModel.sync()` instead, which is a higher-level approach.

## Adding a column to a table​

```
queryInterface.addColumn('Person', 'petName', { type: DataTypes.STRING });
```

Generated SQL (using SQLite):

```
ALTER TABLE `Person` ADD `petName` VARCHAR(255);
```

## Changing the datatype of a column​

```
queryInterface.changeColumn('Person', 'foo', {  type: DataTypes.FLOAT,  defaultValue: 3.14,  allowNull: false,});
```

Generated SQL (using MySQL):

```
ALTER TABLE `Person` CHANGE `foo` `foo` FLOAT NOT NULL DEFAULT 3.14;
```

## Removing a column​

```
queryInterface.removeColumn('Person', 'petName', {  /* query options */});
```

Generated SQL (using PostgreSQL):

```
ALTER TABLE "public"."Person" DROP COLUMN "petName";
```

## Changing and removing columns in SQLite​

SQLite does not support directly altering and removing columns. However, Sequelize will try to work around this by recreating the whole table with the help of a backup table, inspired by [these instructions](https://www.sqlite.org/lang_altertable.html#otheralter).

For example:

```
// Assuming we have a table in SQLite created as follows:queryInterface.createTable('Person', {  name: DataTypes.STRING,  isBetaMember: {    type: DataTypes.BOOLEAN,    defaultValue: false,    allowNull: false,  },  petName: DataTypes.STRING,  foo: DataTypes.INTEGER,});// And we change a column:queryInterface.changeColumn('Person', 'foo', {  type: DataTypes.FLOAT,  defaultValue: 3.14,  allowNull: false,});
```

The following SQL calls are generated for SQLite:

```
PRAGMA TABLE_INFO(`Person`);CREATE TABLE IF NOT EXISTS `Person_backup` (  `name` VARCHAR(255),  `isBetaMember` TINYINT(1) NOT NULL DEFAULT 0,  `foo` FLOAT NOT NULL DEFAULT '3.14',  `petName` VARCHAR(255));INSERT INTO `Person_backup`  SELECT    `name`,    `isBetaMember`,    `foo`,    `petName`  FROM `Person`;DROP TABLE `Person`;CREATE TABLE IF NOT EXISTS `Person` (  `name` VARCHAR(255),  `isBetaMember` TINYINT(1) NOT NULL DEFAULT 0,  `foo` FLOAT NOT NULL DEFAULT '3.14',  `petName` VARCHAR(255));INSERT INTO `Person`  SELECT    `name`,    `isBetaMember`,    `foo`,    `petName`  FROM `Person_backup`;DROP TABLE `Person_backup`;
```

## Other​

As mentioned in the beginning of this guide, there is a lot more to the Query Interface available in Sequelize! Check the [QueryInterface API](https://sequelize.org/api/v6/class/src/dialects/abstract/query-interface.js~queryinterface) for a full list of what can be done.

---

# Read Replication

> Sequelize supports read replication, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the main writer, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is not handled by Sequelize, but should be set up by database backend).

Version: v6 - stable

Sequelize supports [read replication](https://en.wikipedia.org/wiki/Replication_%28computing%29#Database_replication), i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the main writer, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is **not** handled by Sequelize, but should be set up by database backend).

```
const sequelize = new Sequelize('database', null, null, {  dialect: 'mysql',  port: 3306,  replication: {    read: [      {        host: '8.8.8.8',        username: 'read-1-username',        password: process.env.READ_DB_1_PW,      },      {        host: '9.9.9.9',        username: 'read-2-username',        password: process.env.READ_DB_2_PW,      },    ],    write: {      host: '1.1.1.1',      username: 'write-username',      password: process.env.WRITE_DB_PW,    },  },  pool: {    // If you want to override the options used for the read/write pool you can do so here    max: 20,    idle: 30000,  },});
```

If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options:`host`,`port`,`username`,`password`,`database`.

Sequelize uses a pool to manage connections to your replicas. Internally Sequelize will maintain two pools created using `pool` configuration.

If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above.

Each `write` or `useMaster: true` query will use write pool. For `SELECT` read pool will be used. Read replica are switched using a basic round robin scheduling.

---

# Resources

> Addons & Plugins

Version: v6 - stable

## Addons & Plugins​

### ACL​

- [ssacl](https://github.com/pumpupapp/ssacl)
- [ssacl-attribute-roles](https://github.com/mickhansen/ssacl-attribute-roles)
- [SequelizeGuard](https://github.com/lotivo/sequelize-acl) - Role, Permission based Authorization for Sequelize.

### Auto Code Generation & Scaffolding​

- [meteor modeler](https://www.datensen.com/) - Desktop tool for visual definition of Sequelize models and associations.
- [sequelize-ui](https://github.com/tomjschuster/sequelize-ui) - Online tool for building models, relations and more.
- [sequelizer](https://github.com/andyforever/sequelizer) - A GUI Desktop App for generating Sequelize models. Support for Mysql, Mariadb, Postgres, Sqlite, Mssql.
- [sequelize-auto](https://github.com/sequelize/sequelize-auto) Generating models for SequelizeJS via the command line is another choice.
- [pg-generator](https://www.pg-generator.com/builtin-templates/sequelize/) - Auto generate/scaffold Sequelize models for PostgreSQL database.
- [sequelizejs-decorators](https://www.npmjs.com/package/sequelizejs-decorators) decorators for composing sequelize models
- [hatchify](https://github.com/bitovi/hatchify) - Schema driven Node CRUD API and React Web UI including Sequelize based ORM.

### Autoloader​

- [sequelize-autoload](https://github.com/boxsnake-nodejs/sequelize-autoload) - An autoloader for Sequelize, inspired by [PSR-0](https://www.php-fig.org/psr/psr-0/) and [PSR-4](https://www.php-fig.org/psr/psr-4/).

### Bcrypt​

- [sequelize-bcrypt](https://github.com/mattiamalonni/sequelize-bcrypt) - Utility to integrate bcrypt into sequelize models

### Browser​

- [sequelize-browser](https://npmjs.com/package/sequelize-browser) - A web-browser-compatible build of Sequelize

### Caching​

- [sequelize-transparent-cache](https://github.com/DanielHreben/sequelize-transparent-cache)

### Filters​

- [sequelize-transforms](https://www.npmjs.com/package/sequelize-transforms) - Add configurable attribute transforms.

### Fixtures / mock data​

- [Fixer](https://github.com/olalonde/fixer)
- [Sequelize-fixtures](https://github.com/domasx2/sequelize-fixtures)
- [Sequelize-fixture](https://github.com/xudejian/sequelize-fixture)

### Hierarchies​

- [sequelize-hierarchy](https://www.npmjs.com/package/sequelize-hierarchy) - Nested hierarchies for Sequelize.

### Historical records / Time travel​

- [sequelize-temporal](https://github.com/bonaval/sequelize-temporal) - Temporal tables (aka historical records)

### Integrations​

- [kysely-sequelize](https://www.npmjs.com/package/kysely-sequelize) - A toolkit (dialect, type translators, etc.) that allows using your existing Sequelize instance with [Kysely](https://www.kysely.dev).

### Joi​

- [sequelize-joi](https://github.com/mattiamalonni/sequelize-joi) - Allows specifying [Joi](https://github.com/sideway/joi) validation schema for model attributes in Sequelize.

### Migrations​

- [umzug](https://github.com/sequelize/umzug)
- [sequelizemm](https://github.com/hasinoorit/sequelizemm) - CLI tool to generate a migration script from models

### Slugification​

- [sequelize-slugify](https://www.npmjs.com/package/sequelize-slugify) - Add slugs to sequelize models

### Tokens​

- [sequelize-tokenify](https://github.com/pipll/sequelize-tokenify) - Add unique tokens to sequelize models

### Miscellaneous​

- [sequelize-deep-update](https://www.npmjs.com/package/sequelize-deep-update) - Update a sequelize instance and its included associated instances with new properties.
- [sequelize-noupdate-attributes](https://www.npmjs.com/package/sequelize-noupdate-attributes) - Adds no update/readonly attributes support to models.
- [sqlcommenter-sequelize](https://github.com/google/sqlcommenter/tree/master/nodejs/sqlcommenter-nodejs/packages/sqlcommenter-sequelize) A [sqlcommenter](https://google.github.io/sqlcommenter/) plugin with [support for Sequelize](https://google.github.io/sqlcommenter/node/sequelize/) to augment SQL statements with comments that can be used later to correlate application code with SQL statements.
- [automated-express-backend](https://github.com/ruyd/automated-express-backend) - Sample Sequelize Backend with runtime generation of API
- [@rematter/paranoid-sql](https://www.npmjs.com/package/@rematter/paranoid-sql) - Add conditions to verify rows are not soft deleted.
- [@rematter/sequelize-paranoid-delete](https://www.npmjs.com/package/@rematter/sequelize-paranoid-delete) - Enables onDelete when using paranoid mode.
- [@hatchifyjs/sequelize-create-with-associations](https://github.com/bitovi/sequelize-create-with-associations) - Automatically creates, bulkCreates and updates records that have relationships to each other without extra code.

---

# Scopes

> Scopes are used to help you reuse code. You can define commonly used queries, specifying options such as where, include, limit, etc.

Version: v6 - stable

Scopes are used to help you reuse code. You can define commonly used queries, specifying options such as `where`, `include`, `limit`, etc.

This guide concerns model scopes. You might also be interested in the [guide for association scopes](https://sequelize.org/docs/v6/advanced-association-concepts/association-scopes/), which are similar but not the same thing.

## Definition​

Scopes are defined in the model definition and can be finder objects, or functions returning finder objects - except for the default scope, which can only be an object:

```
class Project extends Model {}Project.init(  {    // Attributes  },  {    defaultScope: {      where: {        active: true,      },    },    scopes: {      deleted: {        where: {          deleted: true,        },      },      activeUsers: {        include: [{ model: User, where: { active: true } }],      },      random() {        return {          where: {            someNumber: Math.random(),          },        };      },      accessLevel(value) {        return {          where: {            accessLevel: {              [Op.gte]: value,            },          },        };      },      sequelize,      modelName: 'project',    },  },);
```

You can also add scopes after a model has been defined by calling [YourModel.addScope](https://sequelize.org/api/v6/class/src/model.js~model#static-method-addScope). This is especially useful for scopes with includes, where the model in the include might not be defined at the time the other model is being defined.

The default scope is always applied. This means, that with the model definition above, `Project.findAll()` will create the following query:

```
SELECT * FROM projects WHERE active = true
```

The default scope can be removed by calling `.unscoped()`, `.scope(null)`, or by invoking another scope:

```
await Project.scope('deleted').findAll(); // Removes the default scope
```

```
SELECT * FROM projects WHERE deleted = true
```

It is also possible to include scoped models in a scope definition. This allows you to avoid duplicating `include`, `attributes` or `where` definitions. Using the above example, and invoking the `active` scope on the included User model (rather than specifying the condition directly in that include object):

```
// The `activeUsers` scope defined in the example above could also have been defined this way:Project.addScope('activeUsers', {  include: [{ model: User.scope('active') }],});
```

## Usage​

Scopes are applied by calling `.scope` on the model definition, passing the name of one or more scopes. `.scope` returns a fully functional model instance with all the regular methods: `.findAll`, `.update`, `.count`, `.destroy` etc. You can save this model instance and reuse it later:

```
const DeletedProjects = Project.scope('deleted');await DeletedProjects.findAll();// The above is equivalent to:await Project.findAll({  where: {    deleted: true,  },});
```

Scopes apply to `.find`, `.findAll`, `.count`, `.update`, `.increment` and `.destroy`.

Scopes which are functions can be invoked in two ways. If the scope does not take any arguments it can be invoked as normally. If the scope takes arguments, pass an object:

```
await Project.scope('random', { method: ['accessLevel', 19] }).findAll();
```

Generated SQL:

```
SELECT * FROM projects WHERE someNumber = 42 AND accessLevel >= 19
```

## Merging​

Several scopes can be applied simultaneously by passing an array of scopes to `.scope`, or by passing the scopes as consecutive arguments.

```
// These two are equivalentawait Project.scope('deleted', 'activeUsers').findAll();await Project.scope(['deleted', 'activeUsers']).findAll();
```

Generated SQL:

```
SELECT * FROM projectsINNER JOIN users ON projects.userId = users.idWHERE projects.deleted = trueAND users.active = true
```

If you want to apply another scope alongside the default scope, pass the key `defaultScope` to `.scope`:

```
await Project.scope('defaultScope', 'deleted').findAll();
```

Generated SQL:

```
SELECT * FROM projects WHERE active = true AND deleted = true
```

When invoking several scopes, keys from subsequent scopes will overwrite previous ones (similarly to [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)), except for `where` and `include`, which will be merged. Consider two scopes:

```
YourModel.addScope('scope1', {  where: {    firstName: 'bob',    age: {      [Op.gt]: 20,    },  },  limit: 2,});YourModel.addScope('scope2', {  where: {    age: {      [Op.lt]: 30,    },  },  limit: 10,});
```

Using `.scope('scope1', 'scope2')` will yield the following WHERE clause:

```
WHERE firstName = 'bob' AND age < 30 LIMIT 10
```

Note how `limit` and `age` are overwritten by `scope2`, while `firstName` is preserved. The `limit`, `offset`, `order`, `paranoid`, `lock` and `raw` fields are overwritten, while `where` is by default shallowly merged (meaning that identical keys will be overwritten). If the flag `whereMergeStrategy` is set to `and` (on the model or on the sequelize instance), `where` fields will be merged using the `and` operator.

For instance, if `YourModel` was initialized as such:

```
YourModel.init(  {    /* attributes */  },  {    // ... other init options    whereMergeStrategy: 'and',  },);
```

Using `.scope('scope1', 'scope2')` will yield the following WHERE clause:

```
WHERE firstName = 'bob' AND age > 20 AND age < 30 LIMIT 10
```

Note that `attributes` keys of multiple applied scopes are merged in such a way that `attributes.exclude` are always preserved. This allows merging several scopes and never leaking sensitive fields in final scope.

The same merge logic applies when passing a find object directly to `findAll` (and similar finders) on a scoped model:

```
Project.scope('deleted').findAll({  where: {    firstName: 'john',  },});
```

Generated where clause:

```
WHERE deleted = true AND firstName = 'john'
```

Here the `deleted` scope is merged with the finder. If we were to pass `where: { firstName: 'john', deleted: false }` to the finder, the `deleted` scope would be overwritten.

### Merging includes​

Includes are merged recursively based on the models being included. This is a very powerful merge, added on v5, and is better understood with an example.

Consider the models `Foo`, `Bar`, `Baz` and `Qux`, with One-to-Many associations as follows:

```
const Foo = sequelize.define('Foo', { name: Sequelize.STRING });const Bar = sequelize.define('Bar', { name: Sequelize.STRING });const Baz = sequelize.define('Baz', { name: Sequelize.STRING });const Qux = sequelize.define('Qux', { name: Sequelize.STRING });Foo.hasMany(Bar, { foreignKey: 'fooId' });Bar.hasMany(Baz, { foreignKey: 'barId' });Baz.hasMany(Qux, { foreignKey: 'bazId' });
```

Now, consider the following four scopes defined on Foo:

```
Foo.addScope('includeEverything', {  include: {    model: Bar,    include: [      {        model: Baz,        include: Qux,      },    ],  },});Foo.addScope('limitedBars', {  include: [    {      model: Bar,      limit: 2,    },  ],});Foo.addScope('limitedBazs', {  include: [    {      model: Bar,      include: [        {          model: Baz,          limit: 2,        },      ],    },  ],});Foo.addScope('excludeBazName', {  include: [    {      model: Bar,      include: [        {          model: Baz,          attributes: {            exclude: ['name'],          },        },      ],    },  ],});
```

These four scopes can be deeply merged easily, for example by calling `Foo.scope('includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName').findAll()`, which would be entirely equivalent to calling the following:

```
await Foo.findAll({  include: {    model: Bar,    limit: 2,    include: [      {        model: Baz,        limit: 2,        attributes: {          exclude: ['name'],        },        include: Qux,      },    ],  },});// The above is equivalent to:await Foo.scope(['includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName']).findAll();
```

Observe how the four scopes were merged into one. The includes of scopes are merged based on the model being included. If one scope includes model A and another includes model B, the merged result will include both models A and B. On the other hand, if both scopes include the same model A, but with different options (such as nested includes or other attributes), those will be merged recursively, as shown above.

The merge illustrated above works in the exact same way regardless of the order applied to the scopes. The order would only make a difference if a certain option was set by two different scopes - which is not the case of the above example, since each scope does a different thing.

This merge strategy also works in the exact same way with options passed to `.findAll`, `.findOne` and the like.

---

# Sub Queries

> Consider you have two models, Post and Reaction, with a One-to-Many relationship set up, so that one post has many reactions:

Version: v6 - stable

Consider you have two models, `Post` and `Reaction`, with a One-to-Many relationship set up, so that one post has many reactions:

```
const Post = sequelize.define(  'post',  {    content: DataTypes.STRING,  },  { timestamps: false },);const Reaction = sequelize.define(  'reaction',  {    type: DataTypes.STRING,  },  { timestamps: false },);Post.hasMany(Reaction);Reaction.belongsTo(Post);
```

*Note: we have disabled timestamps just to have shorter queries for the next examples.*

Let's fill our tables with some data:

```
async function makePostWithReactions(content, reactionTypes) {  const post = await Post.create({ content });  await Reaction.bulkCreate(reactionTypes.map(type => ({ type, postId: post.id })));  return post;}await makePostWithReactions('Hello World', [  'Like',  'Angry',  'Laugh',  'Like',  'Like',  'Angry',  'Sad',  'Like',]);await makePostWithReactions('My Second Post', ['Laugh', 'Laugh', 'Like', 'Laugh']);
```

Now, we are ready for examples of the power of subqueries.

Let's say we wanted to compute via SQL a `laughReactionsCount` for each post. We can achieve that with a sub-query, such as the following:

```
SELECT    *,    (        SELECT COUNT(*)        FROM reactions AS reaction        WHERE            reaction.postId = post.id            AND            reaction.type = "Laugh"    ) AS laughReactionsCountFROM posts AS post
```

If we run the above raw SQL query through Sequelize, we get:

```
[  {    "id": 1,    "content": "Hello World",    "laughReactionsCount": 1  },  {    "id": 2,    "content": "My Second Post",    "laughReactionsCount": 3  }]
```

So how can we achieve that with more help from Sequelize, without having to write the whole raw query by hand?

The answer: by combining the `attributes` option of the finder methods (such as `findAll`) with the `sequelize.literal` utility function, that allows you to directly insert arbitrary content into the query without any automatic escaping.

This means that Sequelize will help you with the main, larger query, but you will still have to write that sub-query by yourself:

```
Post.findAll({  attributes: {    include: [      [        // Note the wrapping parentheses in the call below!        sequelize.literal(`(                    SELECT COUNT(*)                    FROM reactions AS reaction                    WHERE                        reaction.postId = post.id                        AND                        reaction.type = "Laugh"                )`),        'laughReactionsCount',      ],    ],  },});
```

*Important Note: Sincesequelize.literalinserts arbitrary content without escaping to the query, it deserves very special attention since it may be a source of (major) security vulnerabilities. It should not be used on user-generated content.* However, here, we are using `sequelize.literal` with a fixed string, carefully written by us (the coders). This is ok, since we know what we are doing.

The above gives the following output:

```
[  {    "id": 1,    "content": "Hello World",    "laughReactionsCount": 1  },  {    "id": 2,    "content": "My Second Post",    "laughReactionsCount": 3  }]
```

Success!

## Using sub-queries for complex ordering​

This idea can be used to enable complex ordering, such as ordering posts by the number of laugh reactions they have:

```
Post.findAll({  attributes: {    include: [      [        sequelize.literal(`(                    SELECT COUNT(*)                    FROM reactions AS reaction                    WHERE                        reaction.postId = post.id                        AND                        reaction.type = "Laugh"                )`),        'laughReactionsCount',      ],    ],  },  order: [[sequelize.literal('laughReactionsCount'), 'DESC']],});
```

Result:

```
[  {    "id": 2,    "content": "My Second Post",    "laughReactionsCount": 3  },  {    "id": 1,    "content": "Hello World",    "laughReactionsCount": 1  }]
```
