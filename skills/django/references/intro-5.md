# Writing your first Django app, part 6¶ and more

# Writing your first Django app, part 6¶

# Writing your first Django app, part 6¶

This tutorial begins where [Tutorial 5](https://docs.djangoproject.com/en/5.0/tutorial05/) left off.
We’ve built a tested web-poll application, and we’ll now add a stylesheet and
an image.

Aside from the HTML generated by the server, web applications generally need
to serve additional files — such as images, JavaScript, or CSS — necessary to
render the complete web page. In Django, we refer to these files as “static
files”.

For small projects, this isn’t a big deal, because you can keep the static
files somewhere your web server can find it. However, in bigger projects –
especially those comprised of multiple apps – dealing with the multiple sets
of static files provided by each application starts to get tricky.

That’s what `django.contrib.staticfiles` is for: it collects static files
from each of your applications (and any other places you specify) into a
single location that can easily be served in production.

Where to get help:

If you’re having trouble going through this tutorial, please head over to
the [Getting Help](https://docs.djangoproject.com/en/faq/help/) section of the FAQ.

## Customize yourapp’slook and feel¶

First, create a directory called `static` in your `polls` directory. Django
will look for static files there, similarly to how Django finds templates
inside `polls/templates/`.

Django’s [STATICFILES_FINDERS](https://docs.djangoproject.com/en/ref/settings/#std-setting-STATICFILES_FINDERS) setting contains a list
of finders that know how to discover static files from various
sources. One of the defaults is `AppDirectoriesFinder` which
looks for a “static” subdirectory in each of the
[INSTALLED_APPS](https://docs.djangoproject.com/en/ref/settings/#std-setting-INSTALLED_APPS), like the one in `polls` we just created. The admin
site uses the same directory structure for its static files.

Within the `static` directory you have just created, create another directory
called `polls` and within that create a file called `style.css`. In other
words, your stylesheet should be at `polls/static/polls/style.css`. Because
of how the `AppDirectoriesFinder` staticfile finder works, you can refer to
this static file in Django as `polls/style.css`, similar to how you reference
the path for templates.

Static file namespacing

Just like templates, we *might* be able to get away with putting our static
files directly in `polls/static` (rather than creating another `polls`
subdirectory), but it would actually be a bad idea. Django will choose the
first static file it finds whose name matches, and if you had a static file
with the same name in a *different* application, Django would be unable to
distinguish between them. We need to be able to point Django at the right
one, and the best way to ensure this is by *namespacing* them. That is, by
putting those static files inside *another* directory named for the
application itself.

Put the following code in that stylesheet (`polls/static/polls/style.css`):

  `polls/static/polls/style.css`[¶](#id1)

```
li a {
    color: green;
}
```

Next, add the following at the top of `polls/templates/polls/index.html`:

  `polls/templates/polls/index.html`[¶](#id2)

```
{% load static %}

<link rel="stylesheet" href="{% static 'polls/style.css' %}">
```

The `{% static %}` template tag generates the absolute URL of static files.

That’s all you need to do for development.

Start the server (or restart it if it’s already running):

   /  

```
$ python manage.py runserver
```

```
...\> py manage.py runserver
```

Reload `http://localhost:8000/polls/` and you should see that the question
links are green (Django style!) which means that your stylesheet was properly
loaded.

## Adding a background-image¶

Next, we’ll create a subdirectory for images. Create an `images` subdirectory
in the `polls/static/polls/` directory. Inside this directory, add any image
file that you’d like to use as a background. For the purposes of this tutorial,
we’re using a file named `background.png`, which will have the full path
`polls/static/polls/images/background.png`.

Then, add a reference to your image in your stylesheet
(`polls/static/polls/style.css`):

  `polls/static/polls/style.css`[¶](#id3)

```
body {
    background: white url("images/background.png") no-repeat;
}
```

Reload `http://localhost:8000/polls/` and you should see the background
loaded in the top left of the screen.

Warning

The `{% static %}` template tag is not available for use in static files
which aren’t generated by Django, like your stylesheet. You should always
use **relative paths** to link your static files between each other,
because then you can change [STATIC_URL](https://docs.djangoproject.com/en/ref/settings/#std-setting-STATIC_URL) (used by the
[static](https://docs.djangoproject.com/en/ref/templates/builtins/#std-templatetag-static) template tag to generate its URLs) without having to modify
a bunch of paths in your static files as well.

These are the **basics**. For more details on settings and other bits included
with the framework see
[the static files howto](https://docs.djangoproject.com/en/howto/static-files/) and
[the staticfiles reference](https://docs.djangoproject.com/en/ref/contrib/staticfiles/). [Deploying
static files](https://docs.djangoproject.com/en/howto/static-files/deployment/) discusses how to use static
files on a real server.

When you’re comfortable with the static files, read [part 7 of this
tutorial](https://docs.djangoproject.com/en/5.0/tutorial07/) to learn how to customize Django’s
automatically-generated admin site.

---

# Writing your first Django app, part 7¶

# Writing your first Django app, part 7¶

This tutorial begins where [Tutorial 6](https://docs.djangoproject.com/en/5.0/tutorial06/) left off. We’re
continuing the web-poll application and will focus on customizing Django’s
automatically-generated admin site that we first explored in [Tutorial 2](https://docs.djangoproject.com/en/5.0/tutorial02/).

Where to get help:

If you’re having trouble going through this tutorial, please head over to
the [Getting Help](https://docs.djangoproject.com/en/faq/help/) section of the FAQ.

## Customize the admin form¶

By registering the `Question` model with `admin.site.register(Question)`,
Django was able to construct a default form representation. Often, you’ll want
to customize how the admin form looks and works. You’ll do this by telling
Django the options you want when you register the object.

Let’s see how this works by reordering the fields on the edit form. Replace
the `admin.site.register(Question)` line with:

  `polls/admin.py`[¶](#id1)

```
from django.contrib import admin

from .models import Question

class QuestionAdmin(admin.ModelAdmin):
    fields = ["pub_date", "question_text"]

admin.site.register(Question, QuestionAdmin)
```

You’ll follow this pattern – create a model admin class, then pass it as the
second argument to `admin.site.register()` – any time you need to change the
admin options for a model.

This particular change above makes the “Publication date” come before the
“Question” field:

 ![Fields have been reordered](https://docs.djangoproject.com/en/_images/admin07.png)

This isn’t impressive with only two fields, but for admin forms with dozens
of fields, choosing an intuitive order is an important usability detail.

And speaking of forms with dozens of fields, you might want to split the form
up into fieldsets:

  `polls/admin.py`[¶](#id2)

```
from django.contrib import admin

from .models import Question

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None, {"fields": ["question_text"]}),
        ("Date information", {"fields": ["pub_date"]}),
    ]

admin.site.register(Question, QuestionAdmin)
```

The first element of each tuple in
[fieldsets](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.ModelAdmin.fieldsets) is the title of the fieldset.
Here’s what our form looks like now:

 ![Form has fieldsets now](https://docs.djangoproject.com/en/_images/admin08t.png)

## Adding related objects¶

OK, we have our Question admin page, but a `Question` has multiple
`Choice`s, and the admin page doesn’t display choices.

Yet.

There are two ways to solve this problem. The first is to register `Choice`
with the admin just as we did with `Question`:

  `polls/admin.py`[¶](#id3)

```
from django.contrib import admin

from .models import Choice, Question

# ...
admin.site.register(Choice)
```

Now “Choices” is an available option in the Django admin. The “Add choice” form
looks like this:

 ![Choice admin page](https://docs.djangoproject.com/en/_images/admin09.png)

In that form, the “Question” field is a select box containing every question in the
database. Django knows that a [ForeignKey](https://docs.djangoproject.com/en/ref/models/fields/#django.db.models.ForeignKey) should be
represented in the admin as a `<select>` box. In our case, only one question
exists at this point.

Also note the “Add another question” link next to “Question.” Every object with
a `ForeignKey` relationship to another gets this for free. When you click
“Add another question”, you’ll get a popup window with the “Add question” form.
If you add a question in that window and click “Save”, Django will save the
question to the database and dynamically add it as the selected choice on the
“Add choice” form you’re looking at.

But, really, this is an inefficient way of adding `Choice` objects to the system.
It’d be better if you could add a bunch of Choices directly when you create the
`Question` object. Let’s make that happen.

Remove the `register()` call for the `Choice` model. Then, edit the `Question`
registration code to read:

  `polls/admin.py`[¶](#id4)

```
from django.contrib import admin

from .models import Choice, Question

class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None, {"fields": ["question_text"]}),
        ("Date information", {"fields": ["pub_date"], "classes": ["collapse"]}),
    ]
    inlines = [ChoiceInline]

admin.site.register(Question, QuestionAdmin)
```

This tells Django: “`Choice` objects are edited on the `Question` admin page. By
default, provide enough fields for 3 choices.”

Load the “Add question” page to see how that looks:

 ![Add question page now has choices on it](https://docs.djangoproject.com/en/_images/admin10t.png)

It works like this: There are three slots for related Choices – as specified
by `extra` – and each time you come back to the “Change” page for an
already-created object, you get another three extra slots.

At the end of the three current slots you will find an “Add another Choice”
link.  If you click on it, a new slot will be added. If you want to remove the
added slot, you can click on the X to the top right of the added slot. This
image shows an added slot:

 ![Additional slot added dynamically](https://docs.djangoproject.com/en/_images/admin14t.png)

One small problem, though. It takes a lot of screen space to display all the
fields for entering related `Choice` objects. For that reason, Django offers a
tabular way of displaying inline related objects. To use it, change the
`ChoiceInline` declaration to read:

  `polls/admin.py`[¶](#id5)

```
class ChoiceInline(admin.TabularInline): ...
```

With that `TabularInline` (instead of `StackedInline`), the
related objects are displayed in a more compact, table-based format:

 ![Add question page now has more compact choices](https://docs.djangoproject.com/en/_images/admin11t.png)

Note that there is an extra “Delete?” column that allows removing rows added
using the “Add another Choice” button and rows that have already been saved.

## Customize the admin change list¶

Now that the Question admin page is looking good, let’s make some tweaks to the
“change list” page – the one that displays all the questions in the system.

Here’s what it looks like at this point:

 ![Polls change list page](https://docs.djangoproject.com/en/_images/admin04t.png)

By default, Django displays the `str()` of each object. But sometimes it’d be
more helpful if we could display individual fields. To do that, use the
[list_display](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_display) admin option, which is a
list of field names to display, as columns, on the change list page for the
object:

  `polls/admin.py`[¶](#id6)

```
class QuestionAdmin(admin.ModelAdmin):
    # ...
    list_display = ["question_text", "pub_date"]
```

For good measure, let’s also include the `was_published_recently()` method
from [Tutorial 2](https://docs.djangoproject.com/en/5.0/tutorial02/):

  `polls/admin.py`[¶](#id7)

```
class QuestionAdmin(admin.ModelAdmin):
    # ...
    list_display = ["question_text", "pub_date", "was_published_recently"]
```

Now the question change list page looks like this:

 ![Polls change list page, updated](https://docs.djangoproject.com/en/_images/admin12t.png)

You can click on the column headers to sort by those values – except in the
case of the `was_published_recently` header, because sorting by the output
of an arbitrary method is not supported. Also note that the column header for
`was_published_recently` is, by default, the name of the method (with
underscores replaced with spaces), and that each line contains the string
representation of the output.

You can improve that by using the [display()](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.display)
decorator on that method (in `polls/models.py`), as follows:

  `polls/models.py`[¶](#id8)

```
from django.contrib import admin

class Question(models.Model):
    # ...
    @admin.display(
        boolean=True,
        ordering="pub_date",
        description="Published recently?",
    )
    def was_published_recently(self):
        now = timezone.now()
        return now - datetime.timedelta(days=1) <= self.pub_date <= now
```

For more information on the properties configurable via the decorator, see
[list_display](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_display).

Edit your `polls/admin.py` file again and add an improvement to the
`Question` change list page: filters using the
[list_filter](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_filter). Add the following line to
`QuestionAdmin`:

```
list_filter = ["pub_date"]
```

That adds a “Filter” sidebar that lets people filter the change list by the
`pub_date` field:

 ![Polls change list page, updated](https://docs.djangoproject.com/en/_images/admin13t.png)

The type of filter displayed depends on the type of field you’re filtering on.
Because `pub_date` is a [DateTimeField](https://docs.djangoproject.com/en/ref/models/fields/#django.db.models.DateTimeField), Django
knows to give appropriate filter options: “Any date”, “Today”, “Past 7 days”,
“This month”, “This year”.

This is shaping up well. Let’s add some search capability:

```
search_fields = ["question_text"]
```

That adds a search box at the top of the change list. When somebody enters
search terms, Django will search the `question_text` field. You can use as many
fields as you’d like – although because it uses a `LIKE` query behind the
scenes, limiting the number of search fields to a reasonable number will make
it easier for your database to do the search.

Now’s also a good time to note that change lists give you free pagination. The
default is to display 100 items per page. [Changelistpagination](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_per_page), [searchboxes](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields), [filters](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_filter), [date-hierarchies](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.ModelAdmin.date_hierarchy), and
[column-header-ordering](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_display)
all work together like you think they should.

## Customize the admin look and feel¶

Clearly, having “Django administration” at the top of each admin page is
ridiculous. It’s just placeholder text.

You can change it, though, using Django’s template system. The Django admin is
powered by Django itself, and its interfaces use Django’s own template system.

### Customizing yourproject’stemplates¶

Create a `templates` directory in your project directory (the one that
contains `manage.py`). Templates can live anywhere on your filesystem that
Django can access. (Django runs as whatever user your server runs.) However,
keeping your templates within the project is a good convention to follow.

Open your settings file (`mysite/settings.py`, remember) and add a
[DIRS](https://docs.djangoproject.com/en/ref/settings/#std-setting-TEMPLATES-DIRS) option in the [TEMPLATES](https://docs.djangoproject.com/en/ref/settings/#std-setting-TEMPLATES) setting:

  `mysite/settings.py`[¶](#id9)

```
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]
```

[DIRS](https://docs.djangoproject.com/en/ref/settings/#std-setting-TEMPLATES-DIRS) is a list of filesystem directories to check
when loading Django templates; it’s a search path.

Organizing templates

Just like the static files, we *could* have all our templates together, in
one big templates directory, and it would work perfectly well. However,
templates that belong to a particular application should be placed in that
application’s template directory (e.g. `polls/templates`) rather than the
project’s (`templates`). We’ll discuss in more detail in the
[reusable apps tutorial](https://docs.djangoproject.com/en/5.0/reusable-apps/) *why* we do this.

Now create a directory called `admin` inside `templates`, and copy the
template `admin/base_site.html` from within the default Django admin
template directory in the source code of Django itself
([django/contrib/admin/templates](https://github.com/django/django/blob/main/django/contrib/admin/templates)) into that directory.

Where are the Django source files?

If you have difficulty finding where the Django source files are located
on your system, run the following command:

   /  

```
$ python -c "import django; print(django.__path__)"
```

```
...\> py -c "import django; print(django.__path__)"
```

Then, edit the file and replace
`{{ site_header|default:_('Django administration') }}` (including the curly
braces) with your own site’s name as you see fit. You should end up with
a section of code like:

```
{% block branding %}
<div id="site-name"><a href="{% url 'admin:index' %}">Polls Administration</a></div>
{% if user.is_anonymous %}
  {% include "admin/color_theme_toggle.html" %}
{% endif %}
{% endblock %}
```

We use this approach to teach you how to override templates. In an actual
project, you would probably use
the [django.contrib.admin.AdminSite.site_header](https://docs.djangoproject.com/en/ref/contrib/admin/#django.contrib.admin.AdminSite.site_header) attribute to more easily
make this particular customization.

This template file contains lots of text like `{% block branding %}`
and `{{ title }}`. The `{%` and `{{` tags are part of Django’s
template language. When Django renders `admin/base_site.html`, this
template language will be evaluated to produce the final HTML page, just like
we saw in [Tutorial 3](https://docs.djangoproject.com/en/5.0/tutorial03/).

Note that any of Django’s default admin templates can be overridden. To
override a template, do the same thing you did with `base_site.html` – copy
it from the default directory into your custom directory, and make changes.

### Customizing yourapplication’stemplates¶

Astute readers will ask: But if [DIRS](https://docs.djangoproject.com/en/ref/settings/#std-setting-TEMPLATES-DIRS) was empty by
default, how was Django finding the default admin templates? The answer is
that, since [APP_DIRS](https://docs.djangoproject.com/en/ref/settings/#std-setting-TEMPLATES-APP_DIRS) is set to `True`,
Django automatically looks for a `templates/` subdirectory within each
application package, for use as a fallback (don’t forget that
`django.contrib.admin` is an application).

Our poll application is not very complex and doesn’t need custom admin
templates. But if it grew more sophisticated and required modification of
Django’s standard admin templates for some of its functionality, it would be
more sensible to modify the *application’s* templates, rather than those in the
*project*. That way, you could include the polls application in any new project
and be assured that it would find the custom templates it needed.

See the [template loading documentation](https://docs.djangoproject.com/en/topics/templates/#template-loading) for more
information about how Django finds its templates.

## Customize the admin index page¶

On a similar note, you might want to customize the look and feel of the Django
admin index page.

By default, it displays all the apps in [INSTALLED_APPS](https://docs.djangoproject.com/en/ref/settings/#std-setting-INSTALLED_APPS) that have been
registered with the admin application, in alphabetical order. You may want to
make significant changes to the layout. After all, the index is probably the
most important page of the admin, and it should be easy to use.

The template to customize is `admin/index.html`. (Do the same as with
`admin/base_site.html` in the previous section – copy it from the default
directory to your custom template directory). Edit the file, and you’ll see it
uses a template variable called `app_list`. That variable contains every
installed Django app. Instead of using that, you can hard-code links to
object-specific admin pages in whatever way you think is best.

When you’re comfortable with the admin, read [part 8 of this
tutorial](https://docs.djangoproject.com/en/5.0/tutorial08/) to learn how to use third-party packages.

---

# Writing your first Django app, part 8¶

# Writing your first Django app, part 8¶

This tutorial begins where [Tutorial 7](https://docs.djangoproject.com/en/5.0/tutorial07/) left off. We’ve
built our web-poll application and will now look at third-party packages. One of
Django’s strengths is the rich ecosystem of third-party packages. They’re
community developed packages that can be used to quickly improve the feature set
of an application.

This tutorial will show how to add [Django Debug Toolbar](https://django-debug-toolbar.readthedocs.io), a commonly used third-party
package. The Django Debug Toolbar has ranked in the top three most used
third-party packages in the Django Developers Survey in recent years.

Where to get help:

If you’re having trouble going through this tutorial, please head over to
the [Getting Help](https://docs.djangoproject.com/en/faq/help/) section of the FAQ.

## Installing Django Debug Toolbar¶

Django Debug Toolbar is a useful tool for debugging Django web applications.
It’s a third-party package maintained by the [Jazzband](https://jazzband.co) organization. The toolbar helps you understand how your
application functions and to identify problems. It does so by providing panels
that provide debug information about the current request and response.

To install a third-party application like the toolbar, you need to install
the package by running the below command within an activated virtual
environment. This is similar to our earlier step to [install Django](https://docs.djangoproject.com/en/topics/install/#installing-official-release).

   /  

```
$ python -m pip install django-debug-toolbar
```

```
...\> py -m pip install django-debug-toolbar
```

Third-party packages that integrate with Django need some post-installation
setup to integrate them with your project. Often you will need to add the
package’s Django app to your [INSTALLED_APPS](https://docs.djangoproject.com/en/ref/settings/#std-setting-INSTALLED_APPS) setting. Some packages
need other changes, like additions to your URLconf (`urls.py`).

Django Debug Toolbar requires several setup steps. Follow them in [its
installation guide](https://django-debug-toolbar.readthedocs.io/en/latest/installation.html).
The steps are not duplicated in this tutorial, because as a third-party
package, it may change separately to Django’s schedule.

Once installed, you should be able to see the DjDT “handle” on the right side
of the browser window when you refresh the polls application. Click it to open
the debug toolbar and use the tools in each panel. See the [panels
documentation page](https://django-debug-toolbar.readthedocs.io/en/latest/panels.html) for more
information on what the panels show.

## Getting help from others¶

At some point you will run into a problem, for example the
toolbar may not render. When this happens and you’re unable to
resolve the issue yourself, there are options available to you.

1. If the problem is with a specific package, check if there’s a
  troubleshooting of FAQ in the package’s documentation. For example the
  Django Debug Toolbar has a [Tips section](https://django-debug-toolbar.readthedocs.io/en/latest/tips.html) that
  outlines troubleshooting options.
2. Search for similar issues on the package’s issue tracker. Django Debug
  Toolbar’s is [on GitHub](https://github.com/jazzband/django-debug-toolbar/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc).
3. Consult the [Django Forum](https://forum.djangoproject.com/).
4. Join the [Django Discord server](https://discord.gg/xcRH6mN4fa).
5. Join the #Django IRC channel on [Libera.chat](https://libera.chat/).

## Installing other third-party packages¶

There are many more third-party packages, which you can find using the
fantastic Django resource, [Django Packages](https://djangopackages.org/).

It can be difficult to know what third-party packages you should use. This
depends on your needs and goals. Sometimes it’s fine to use a package that’s
in its alpha state. Other times, you need to know it’s production ready.
[Adam Johnson has a blog post](https://adamj.eu/tech/2021/11/04/the-well-maintained-test/) that outlines
a set of characteristics that qualifies a package as “well maintained”.
Django Packages shows data for some of these characteristics, such as when the
package was last updated.

As Adam points out in his post, when the answer to one of the questions is
“no”, that’s an opportunity to contribute.

## What’s next?¶

The beginner tutorial ends here. In the meantime, you might want to check out
some pointers on [where to go from here](https://docs.djangoproject.com/en/5.0/whatsnext/).

If you are familiar with Python packaging and interested in learning how to
turn polls into a “reusable app”, check out [Advanced tutorial: How to
write reusable apps](https://docs.djangoproject.com/en/5.0/reusable-apps/).
